# 《数学原理》中的符号 notation in (Bernard Linsky)


*首次发表于2004年8月19日；实质性修订于2022年4月5日。*

《数学原理》[PM]是 A.N.怀特海德和伯特兰·罗素于 1910 年至 1913 年在剑桥大学出版的三卷本著作，其中使用了符号逻辑的概念和原理推导了大部分数学。该作品中的符号表示法已被 20 世纪逻辑学的后续发展所取代，以至于初学者很难完全阅读《数学原理》。本文介绍了《数学原理》的符号体系，展示了如何将该符号体系翻译成更现代的表示法，使用的概念对于任何学过符号逻辑或集合论的人来说应该是熟悉的。这种翻译是为了帮助学习原始符号体系，而原始符号体系本身是一个学术争议的主题，并且包含了实质性的逻辑原理，因此不能简单地用现代符号体系替代。因此，学习符号体系是学习《数学原理》独特的逻辑原理的第一步。

 

---

## 1. 为什么要学习《数学原理》中的符号主义？

《数学原理》是由阿尔弗雷德·诺思·怀特黑德和伯特兰德·罗素共同撰写的，历时数年，并于 1910 年至 1913 年间出版了三卷。它提出了一种符号逻辑系统，然后转向数学基础，通过逻辑主义的项目，以逻辑概念来定义数学概念，并将数学的基本公理证明为逻辑的定理。虽然在逻辑、数学哲学以及更广泛的“早期分析哲学”的发展中具有重要意义，但这部作品本身已不再研究这些主题。因此，这部作品的符号表示对于当代逻辑学学生来说已经变得陌生，这成为了学习《数学原理》的障碍。我们包括了一系列关于超限基数、良序集、有理数和实数等概念的定义。这些概念在《数学原理》的类型理论中与公理集合论中的定义不同。

这个条目旨在帮助 PM 的学生阅读工作的符号部分。接下来是符号的部分翻译成更现代的符号，这应该是从本百科其他文章中熟悉的，并且在当代符号逻辑的教科书中是相当标准的。没有提供完整的算法，而是提供了各种建议，旨在帮助读者学习 PM 的符号。只使用当代符号就会预先判断许多解释问题，并且许多 PM 独特的细节取决于该符号。如下所示，PM 的符号中融入了物质的教义，包括一些更有争议的方面。用更现代的符号替换符号将会极大地改变这本书的内容。

## 2. 数学逻辑的原始符号（第一部分）

在下面的顺序中，读者将找到按照 PM 中引入的顺序，以下符号的简要描述。更详细的信息将在接下来提供。

∗发音为“星号”；表示一个数字或章节，如∗1或∗20。·一个居中的点（英国旧式小数点）；表示按照第一个数字的顺序编号的句子（所有0在所有1之前，依此类推）。∗1的第一个定义和命题说明了这种“词典”排序：1·01，1·1，1·11，1·2，1·3，1·4，1·5，1·6，1·7，1·71，1·72.⊢断言符号；在断言之前，可以是公理（即原始命题，也标注为“Pp”）或定理。Df定义符号；跟在定义之后。..，：，：.，::等是用于分隔标点符号的点；在当代逻辑中，我们使用（），[]，{}等。p，q，r等是命题变量。∨，⊃，∼，≡和.，：，：.等是熟悉的命题连接词，分别对应于“或”，“如果-那么”，“非”，“当且仅当”和“和”。（点既用于连接又用于标点的双重用途将在下面解释。）在《数学原理》的第二版（1925-1927）中，Sheffer Stroke“∣”是一个原始的连接词。它表示“不是同时……和___”。x，y，z等是个体变量，应以“典型的模糊性”阅读，即应填入它们的逻辑类型（见下文）。a，b，c等是个体常量，代表个体（最低类型的）。它们仅出现在《数学原理》的引言中，而不出现在正式系统中。xRy，aRb，R(x)等是原子谓词，其中由变量或常量命名的对象在关系R中或具有属性R。它们仅出现在引言中。“a”和“b”仅在第二版中作为常量出现。谓词R(x)，R(x,y)等仅在第二版中使用。ϕ，ψ，χ等。
f、g 等是高阶变量，它们范围涵盖命题函数，无论这些函数是简单还是复杂。ϕx、ψx、ϕ(x,y)等是开放原子公式，其中“x”和“ϕ”都是自由变量。[另一种解释是将“ϕx”视为一个代表变量“x”自由的公式的示意字母。]^插入符号；当放置在开放公式的变量上方（如“ϕ^x”）时，结果是一个函数的术语。[这个问题有争议。参见 Landini 1998。]当插入符号的变量位于复杂变量之前时，结果表示一个类，如^xϕx，它是ϕ的 x 的类，现代符号表示为{x∣ϕx}。ϕ^x、ψ^x、ϕ(^x,^z)等是命题函数的术语。以下是这类术语的示例，它们是常量：“^x 是快乐的”、“^x 秃头且^x 快乐”、“4<^x&lt;6”等。例如，如果我们将函数“^x 秃头且^x 快乐”应用于特定个体 b，结果是命题“b 秃头且 b 快乐”。∃和( )是量词“存在”和“对于所有”（“每个”）。例如，当ϕx 是一个简单或复杂的开放公式时，

| (∃x)ϕx  | asserts | “存在一个 x 使得ϕx”          |
| ----------- | --------- | --------------------------------- |
| (∃ϕ)ϕx | asserts | “存在一个命题函数ϕ使得ϕx”   |
| (x)ϕx    | asserts | 每个 x 都是这样的，即ϕx        |
| (ϕ)ϕx   | asserts | 每个命题函数ϕ都是这样的，即ϕx |

[这些是由 Peano 使用的。最近，为了与∃保持对称性，添加了∀。一些学者将量词(ϕ)和(∃ϕ)视为替代的。]ϕx⊃xψx
ϕx≡xψx 这是用于缩写普遍量化变量的符号。在现代符号中，它们分别变为∀x(ϕx⊃ψx)和∀x(ϕx≡ψx)。请参阅下面第 3.2 节末尾关于这个符号的定义！发音为“shriek”，表示函数是谓词，如ϕ!x 或ϕ!^x。请参阅第 7 节。=身份符号；表示身份，这是 PM 中的一个定义概念，而不是当代逻辑中的原始概念。ι读作“the”，是倒置的 iota 或描述运算符，用于确定描述的表达式，例如(ιx)ϕx（读作：满足ϕx 的 x）。[(ιx)ϕx]是方括号中的确定描述；这是确定描述的范围指示符。E!在∗14·02 中定义，上下文为 E!(ιx)ϕx，表示描述(ιx)ϕx 是适当的，即存在一个且仅有一个满足ϕ的事物。∃!在∗24·03 中定义，上下文为∃!α，表示类α是非空的，即有一个成员。

这些原始符号从 Peano 的符号系统中演变而来，详见 Elkind 和 Zach（即将出版）。

## 3. PM 中使用点的方式

阅读《数学原理》的一个直接障碍是不熟悉使用点号作为标点符号，而不是更常见的括号和方括号。这个系统很精确，只需要一点练习就可以学会。使用点号作为标点符号并不是《数学原理》独有的。它起源于皮亚诺，后来被阿隆佐·邱奇、W.V.O.奎因等人使用，但现在已经基本消失了。艾伦·图灵在 1942 年从计算的角度对使用点号进行了研究，可能是在他在布莱切利公园破解恩尼格玛机密码的工作之余。图灵认为，使用并置来表示连词与使用并置算术来表示乘法类似：

> 在大多数系统中，有一些操作只需简单地并置，而不需要任何特殊的运算符。在邱奇的系统中，这是将函数应用于其参数；在罗素的系统中，这是连词；在代数中，这是乘法。”（图灵 1942 年，151）

在他早期的作品《数学原理》（1903 年）中，罗素遵循皮亚诺的做法，通过简单地并置公式来表示连词。因此，p 和 q 的连词写作 pq。罗素从 1905 年开始使用点号来表示连词。逻辑中使用点号作为标点符号现在只具有历史意义，尽管一些教科书使用升高的点号 p⋅q 来表示连词。下面我们将解释《数学原理》中点号作为标点符号和连词的双重用途。

学习使用它的最佳方法是查看一些示例，这些示例使用括号将其转换为公式，从而对其有所了解。接下来是《数学原理》第9-10页中的解释，然后是一些示例，用来说明每个子句。

> 点的使用。符号线上的点有两种用途，一种是用来括起命题，另一种是用来表示两个命题的逻辑乘积。紧接着“∨”或“⊃”或“≡”或“⊢”或“(x)”或“(x,y)”或“(x,y,z)”…或“(∃x)”或“(∃x,y)”或“(∃x,y,z)”…或“[(ιx)(ϕx)]”或“[R‘y]”或类似表达式的点，用来括起一个命题；其他情况下出现的点用来标记逻辑乘积。一般原则是，点的数量越多，表示外部括号，点的数量越少，表示内部括号。关于点所表示的括号范围的确切规则是通过将点的出现分为三组来确定的，我们将其命名为 I、II 和 III。第 I 组由紧邻蕴涵符号(⊃)或等价符号(≡)或析取符号(∨)或定义相等符号(=Df)的点组成。第 II 组由跟随表示表面变量的括号的点组成，例如(x)或(x,y)或(∃x)或(∃x,y)或[(ιx)(ϕx)]或类似表达式。第 III 组由位于命题之间以表示逻辑乘积的点组成。第 I 组的力量大于第 II 组，第 II 组的力量大于第 III 组。由任意数量的点表示的括号范围向前或向后延伸，直到达到所断言命题的末尾，或者达到更多数量的点，或者达到属于力量相等或更高的组的相等数量的点。表示逻辑乘积的点的范围向前和向后都起作用；其他点只能从相邻的析取、蕴涵或等价符号处向外或从第 II 组中列举的其他类型的相邻符号向前起作用。一些例子将有助于说明点的使用。（《数学原理》，9-10）

关于点符号的更深入讨论，请参见附录。

用点号作为标点符号和连接词的使用。

### 3.1 一些基本例子

考虑以下一系列扩展例子，我们将逐步讨论如何将 PM 中的命题翻译成现代符号。 （下面的符号有时被用作它们自己的名称，从而避免了一些本来需要的引号。罗素经常被指责混淆使用和提及，因此这种做法可能存在一些危险。）

#### 示例 1

∗1⋅2⊢:p∨p.⊃.pPp

这是“星号”1 的第二个断言。事实上，它是一个公理或“原始命题”，如“Pp”所示。通过使用“⊢”，表明这是一个断言（公理或定理），而不是一个定义。（相比之下，定义会省略断言符号，但以“Df”符号结尾。）现在，将∗1·2 翻译成现代符号的第一步是注意到冒号。回想一下，从上面引用的段落中，“更多的点表示外部括号，较少的点表示内部括号”。因此，这里的冒号（由比∗1·2 行上的单个点更多的点组成）表示外部括号。方括号“[”和“]”表示∗1·2 中的冒号。因此，冒号的范围延伸到任何较少的点（即一个点）到公式的末尾。由于公式是从左到右阅读的，表达式“past”表示“在右边”。

所以，第一步是将∗1·2 翻译为：

⊢[p∨p.⊃.p]

接下来，现代符号表示法中的“⊃”周围的点由前提和结论周围的括号表示。回想一下，在上面的段落中，我们发现“…点只在离析取、蕴涵或等价的相邻符号远处起作用…”。因此，翻译过程的下一步是转换为公式：⊢[(p∨p)⊃(p)]

最后，标准现代约定允许我们删除外部括号和单个字母周围的括号，得到：

⊢(p∨p)⊃p

我们的下一个例子涉及合取：

#### 示例 2

∗3⋅01p.q.=.∼(∼p∨∼q)Df

通过仔细研究《数学原理》第 9 至 11 页上关于点的使用的段落的细节，可以理解点的双重用途，即“指示”连词和标点符号。首先尝试将点解读为标点符号，如果这样不起作用，那么这些点必须表示连词。

∗3·01 定义了使用点号表示连词的方法。（当作为标点符号阅读时，第一个点号会一直延伸到相等数量的点号，即等号前的点号，从而产生不连贯的表达式：“( p(q)=df(∼(∼p∨∼q)) ”。因此，它必须表示一个连词。）定义=df 的等号周围的点号属于第一组，因此替代它们的括号延伸到表达式的两端：

(p.q)=df(∼(∼p∨∼q))然后，我们删除右边和左边的外部括号，因为它们在解释公式时是不必要的，所以我们有：p.q=df∼(∼p∨∼q)在现代符号中，p&q=df∼(∼p∨∼q)

注意，在∗3·01 中，否定符号“∼”的作用范围并没有用点号表示，即使在 PM 系统中也是如此，而是使用括号表示。

#### 示例 3

∗9⋅01∼{(x).ϕx}.=.(∃x).∼ϕxDf

我们应用“点号仅适用于离析取、蕴涵或等价符号的相邻符号之外，或者从第二组中列举的其他类型符号的相邻符号开始”规则（其中第二组包括“(∃x)”）。在这种情况下，第一个点号延伸到允许用来替代点号的标点符号 } 。在现代等价式中，量词后（或否定后）没有出现这样的标点符号，等价式为：∼(x)ϕx=df(∃x)∼ϕxor∼∀xϕx=df∃x∼ϕx

相对于“力量”或范围，逻辑学中的连接词排名是一个标准惯例。如果没有明确的括号来指示连接词的范围，那些在排名中具有优先权的连接词被认为是主要连接词，依此类推对于子公式。因此，我们现在将以下的德摩根定律的表述从繁琐的形式改写为：

[(∼p)∨(∼q)]≡[∼(p&q)]

现在我们将其写为：

∼p∨∼q≡∼(p&q)

这个更简单的表述是基于以下约定：≡的范围比∨和&更广，而后者的范围比∼更广。实际上，在≡的范围比⊃更广的另一个约定下，括号通常不需要用在≡周围。因此，公式 p⊃q≡∼p∨q 变得明确无误。我们可以通过将连接词按照范围从广到窄的顺序分组来表示这些约定：

≡⊃&,∨∼

然而，对于怀特海德和罗素来说，第一组中的符号⊃，≡，∨和…=…Df 具有相等的力量。第二组包括变量绑定表达式、量词和确定描述的范围指示符，第三组包括连词。否定位于所有这些之下。因此，在《数学原理》中的排名将是：

⊃，≡，∨和…=…Df(x),(x,y)…(∃x),(∃x,y)…[(ιx)ϕx]p.q∼

这就是怀特海德和罗素所说的“第一组比第二组更有力量，第二组比第三组更有力量”的意思。考虑以下内容：

#### 示例 4

∗3⋅12⊢:∼p.∨.∼q.∨.p.q

这个定理说明了如何在一个公式中读取相同数量的点的多个用法。根据从左到右的约定和定义，将点和多个析取的系列进行“左结合”。

∗2⋅33p∨q∨r.=.(p∨q)∨rDf

在∗3·12 中，围绕∨的前两个点简单地“远离”连接词。第二个“延伸”直到与下一个相同编号的点相遇（第三个单点）。第三个点和第四个点“远离”第二个∨，最后一个点表示最小力量的连接。以最大明确性的所有可能标点符号来表达的结果是：

{[(∼p)∨(∼q)]∨(p&q)}

如果我们采用所有省略括号的标准约定，这将变为：

(∼p∨∼q)∨(p&q)

这说明了上述引文中所说的“由任何一组点所指示的括号的范围向前或向后延伸，超过任何较小数量的点，或者来自较小力量的一组相等数量的点，直到我们达到所断言命题的结尾，或者更多数量的点，或者属于相等或更高力量的一组相等数量的点。”

在我们看更广泛的例子之前，一个涉及量化变量的详细例子将会很有教育意义。怀特海德和罗素遵循皮亚诺的做法，用有界变量作为条件符号下的下标来表示普遍量化的条件（例如“所有的ϕ都是ψ”）。同样地，对于普遍量化的双条件（“只有ϕ才是ψ”），也是如此。也就是说，“ϕx⊃xψx”和“ϕx≡xψx”的定义如下：

∗10⋅02ϕx⊃xψx.=.(x).ϕx⊃ψxDf∗10⋅03ϕx≡xψx.=.(x).ϕx≡ψxDf

并且分别对应以下更现代的公式：

∀x(ϕx⊃ψx)∀x(ϕx≡ψx)

作为一项练习，读者可能倾向于制定一个严格的算法，将 PM 转换为特定的现代符号（带有省略括号的约定），但学习该系统的最佳方法是查看更多的翻译示例，然后直接开始阅读公式。

### 3.2 更多示例

在下面的示例中，每个公式编号首先是《数学原理》的符号，然后是其现代翻译。请注意，在∗1·5 中，括号除了点号之外还用于标点符号。（原始命题∗1·2、∗1·3、∗1·4、∗1·5 和∗1·6 共同构成了 PM 中命题逻辑的公理。）命题∗1·5 在 1926 年由保罗·伯奈斯证明是多余的。它可以从其他命题的适当实例和推理规则中推导出来。

| ∗1·3  | ⊢:q.⊃.p∨qPp<br />q⊃p∨q                                  |
| --------- | ---------------------------------------------------------- |
| ∗1·4  | ⊢:p∨q.⊃.q∨pPp<br />p∨q⊃q∨p                            |
| ∗1·5  | ⊢:p∨(q∨r).⊃.q∨(p∨r)Pp<br />p∨(q∨r)⊃q∨(p∨r)        |
| ∗1·6  | ⊢:.q⊃r.⊃:p∨q.⊃.p∨rPp<br />(q⊃r)⊃(p∨q⊃p∨r)         |
| ∗2·03 | ⊢:p⊃∼q.⊃.q⊃∼p<br />(p⊃∼q)⊃(q⊃∼p)                  |
| ∗3·3  | ⊢:.p.q.⊃.r:⊃:p.⊃.q⊃r<br />[(p&q)⊃r]⊃[p⊃(q⊃r)]       |
| ∗4·15 | ⊢:.p.q.⊃.∼r:≡:q.r.⊃.∼p<br />[(p&q)⊃∼r]≡[(q&r)⊃∼p] |

| ∗5·71 | ⊢:.q⊃∼r.⊃:p∨q.r.≡.p.r<br />(q⊃∼r)⊃{[(p∨q)&r]≡(p&r)} |
| --------- | ------------------------------------------------------------ |
| ∗9·04 | p.∨.(x).ϕx:=.(x).ϕx∨pDf<br />p∨∀xϕx=df∀x(ϕx∨p)       |

| ∗9·521 | ⊢::(∃x).ϕx.⊃.q:⊃:.(∃x).ϕx.∨.r:⊃.q∨r<br />[(∃xϕx)⊃q]⊃[((∃xϕx)∨r)⊃(q∨r)]                |
| ---------- | ------------------------------------------------------------------------------------------------------ |
| ∗10·55 | ⊢:.(∃x).ϕx.ψx:ϕx⊃xψx:≡:(∃x).ϕx:ϕx⊃xψx<br />∃x(ϕx&ψx)&∀x(ϕx⊃ψx)≡∃xϕx&∀x(ϕx⊃ψx) |

注意，在∗10·55 中有两个使用双点“:”表示连词的地方。

## 4. 命题函数

PM 中有两种函数。命题函数，如“^x 是一个自然数”，与更熟悉的数学函数有所区别，后者被称为“描述函数”（PM，第∗31 章）。描述函数是使用关系和明确描述来定义的。描述函数的例子有 x+y 和“n 的后继”。

专注于命题函数，怀特海德和罗素区分了带有自由变量的表达式（如“x受伤”）和函数的名称（如“^x受伤”）（《数学原理》，14-15页）。通过为自由变量“x”分配允许的值，从公式中得出的命题被称为函数的“模糊值”。使用帽子符号的表达式，如ϕ^x，仅出现在《数学原理》的技术部分的引言材料中，而不是技术部分本身（除了关于类理论的部分），这导致一些学者说这样的表达式实际上并不存在于《数学原理》的形式系统中。这个问题与解释这些符号的问题是不同的。它们是将开放式公式转化为函数名称的“术语形成运算符”，还是仅仅是一个语法设备，一个占位符，用于指示可以在开放式公式中进行替换的变量？如果它们被视为术语形成运算符，ϕ^x的现代符号将是λxϕx。λ符号的优点是清楚地显示变量x被术语形成运算符λ所约束，它接受一个谓词ϕ并产生一个术语λxϕx（在某些逻辑中，这是一个可以出现在句子的主语位置的特殊术语，而在其他逻辑中，它是一个复杂的谓词表达式）。与λ符号不同，使用帽子符号的《数学原理》符号不能表示范围。函数表达式“ϕ(^x,^y)”在λ符号之间存在歧义，即λxλyϕxy和λyλxϕxy，除非有进一步的约定。事实上，怀特海德和罗素在关于外延关系的引言材料中明确规定了这个约定（在∗21的第200页上，涉及变量的顺序），但是使用λ符号最清楚地显示了这种歧义：第一个表示的是ϕxy的x和y的关系，而第二个表示的是ϕxy的y和x的关系。

## 5. 类型和顺序的缺失符号

本节解释了《数学原理》中没有的符号。除了∗63 中的一些“相对”类型的符号以及第二卷的早期部分，著名的是《数学原理》中没有类型的符号！句子通常被视为“典型的模糊”，因此代表了整个类型范围的表达式，因此既没有个体或谓词常量，也没有任何特定类型的特定函数。因此，人们不仅看不到如何符号化这个论证：

 所有人都是有限的
苏格拉底是一个人
因此，苏格拉底是有限的

但是对于函数“^x 是有限的”没有任何逻辑类型的指示。PM 的项目是将数学归纳为逻辑的一部分，而在这个项目背后的逻辑观点的一部分是逻辑真理都是完全普遍的。从定义和逻辑真理推导出数学真理将不涉及任何特定的常量，除了通过纯逻辑概念从定义引入的常量。因此，PM 中不包括描述这些类型的符号。希望将 PM 视为可以应用的逻辑的人，必须补充一些类型的指示。

读者应注意，下面概述的类型解释与《数学原理》文本中关于类型的陈述不一致。阿隆佐·丘奇[1976]根据《数学原理》文本的暗示，对简单类型和分叉类型理论的符号进行了简单而合理的重构。（类型理论还有其他等价的符号表示法。）完整的理论可以看作是简单类型理论的发展。

### 5.1 简单类型

简单类型的定义如下：

* ι（希腊字母 iota）是表示个体类型的符号。
* 当τ1，…，τn 为任意类型时，┌(τ1，…，τn)┐表示一个命题函数的类型，其参数分别为τ1，…，τn。
* ┌( )┐表示命题的类型。

这里有一些直观理解类型定义的方法。假设“苏格拉底”指代一个个体。（我们在这里忽略罗素的观点，即这些普通个体实际上是感知数据类的类，因此属于更高级别的类型。）那么个体常量“苏格拉底”将属于类型ι。以个体为参数的一元命题函数属于类型(ι)。假设“是有死性的”是一个表示个体属性的谓词。函数“^x 是有死性的”将属于类型(ι)。两个个体之间的二元关系属于类型(ι,ι)。因此，“父母关系”这样的关系表达式和函数“^x 是^z 的父母”将属于类型(ι,ι)。

类型(ι)的命题函数通常被称为“一阶”；因此，对于只有一阶函数的参数的常见逻辑，称为“一阶逻辑”。参数为类型τ的一元函数属于类型(τ)，因此这样的函数的函数属于类型((τ))。“二阶逻辑”将具有这样的函数的参数（以及个体的变量）。类型τ的函数之间的二元关系属于类型(τ,τ)，对于具有超过 2 个参数的关系也是如此。混合类型由上述定义。个体和命题之间的关系（例如“^x 相信^P”）将属于类型(ι,( )。

### 5.2 分层类型

要构建 PM 的全面分层类型理论的符号表示，还必须在符号中编码另一部分信息。教堂将结果系统称为 r-类型之一。分层类型的关键思想是，使用对某个给定类型的函数进行量化定义的任何函数都必须比那些函数的“阶数”更高。以罗素的例子为例：

^x 具有所有伟大将军所具有的品质

是一个对个体（即人）真实的函数，并且从简单类型理论的角度来看，它具有与个体的特定品质（如勇敢和果断）相同的简单逻辑类型。然而，在分层类型理论中，上述函数将比个体的特定品质具有更高的阶数，因为与那些特定品质不同，它涉及对这些品质的量化。因此，虽然表达式“^x 是勇敢的”表示 r-类型（ι）/1 的函数，但表达式“^x 具有所有伟大将军所具有的品质”将具有 r-类型（ι）/2。在这些 r-类型中，“/”后面的数字表示函数的级别。函数的顺序将根据以下定义进行确定和计算。

教堂将 r 类型定义如下：

* ι（希腊字母 iota）是个体的 r 类型。
* 其中τ1，…，τm 是任意的 r 类型，n 是正整数，┌(τ1，…，τm)/n┐是一个 r 类型；这是一个级别为 n 的 m 元命题函数的 r 类型，其参数为 r 类型τ1，…，τm。

实体的顺序定义如下（在这里我们不再遵循 Church 的定义，因为他为变量（即表达式）定义了顺序，而不是为变量范围内的事物定义顺序）：

* 个体（r-类型ι）的顺序为 0，
* r-类型（τ1，...，τm）/n 的函数的顺序为 n+N，其中 N 是参数τ1，...，τm 的顺序中最大的值。

这两个定义随附一个原理，该原理确定了特定定义函数的级别，即定义函数的级别应比在该函数的定义中出现的具有名称或变量的最高阶实体高一级。

要了解这些定义和原理如何用于计算函数“^x 具有所有伟大将军所具有的品质”的阶数，请注意函数可以表示如下，其中“x，y”是变量，范围是 r-类型ι（阶数 0），“GreatGeneral(y)”是一个谓词，表示 r-类型（ι）/1 的命题函数（因此是阶数 1），而“ϕ”是一个变量，范围是 r-类型（ι）/1 的命题函数（因此是阶数 1），例如伟大将军、勇气、领导力、技能、远见等。

(ϕ){[(y)(GreatGeneral(y)⊃ϕ(y)]⊃ϕ^x}

首先我们注意到，根据上述原理，该函数的 r-类型为(ι)/2；级别为 2，因为该函数的 r-类型的级别必须比定义中命名的任何实体（或变量的范围内的实体）的最高阶数高一级。在这种情况下，GreatGeneral 的指称和变量“ϕ”的范围的阶数为 1，没有其他表达式命名或范围超过更高阶的实体。因此，上述函数的级别被定义为 2。最后，我们计算上述函数的阶数，如其定义：级别加上上述函数参数的最大阶数之和。由于上述函数中的唯一参数是个体（阶数为 0），我们的函数的阶数就是 2。

在定义新函数时，对 r-类型（τ）/n 的函数进行量化会产生 r-类型（τ）/n+1 的函数，因此阶数会增加一个单位，即 k+1。因此，第二阶的函数有两种类型：（1）个体的一阶函数，r-类型为((ι)/1)/1，（2）r-类型为(ι)/2 的函数，例如我们的例子“^x 具有所有伟大将军所具有的品质”。后者是对拿破仑等个体成立的函数，但比“^x 勇敢”这样的简单函数的阶数高，后者的 r-类型为(ι)/1。

今天的逻辑学家使用不同的“顺序”概念。现代的一阶逻辑是一种只有个体变量的逻辑。二阶逻辑是一种既有个体变量又有个体属性变量的逻辑。三阶逻辑是一种既有个体变量又有个体属性变量和个体属性属性变量的逻辑。依此类推。相比之下，邱奇将分别称这些逻辑为类型为(ι)/1 和(ι,…,ι)/1 的函数逻辑，类型为((ι)/1)/1 和((ι,…,ι)/1,…,(ι,…,ι)/1)/1 的函数逻辑，以及类型为(((ι)/1)/1)/1 等的函数逻辑（即前一类型函数的一级函数）。根据邱奇的定义，这些分别是一阶、二阶和三阶函数逻辑，与现代的“第 n 阶逻辑”术语相符。

## 6. 变量

如前所述，PM 的形式系统中没有个体或谓词常量，只有变量。然而，引言部分在讨论原子事实时使用了“a 在关系 R 中与 b 有关”的例子（PM，43 页）。虽然“R”后来被用作范围为扩展关系的变量，“a，b，c，…”是个体变量，但为了讨论 PM 中变量的使用，让我们暂时将它们添加到系统中作为谓词和个体常量。

《数学原理》对“真实”或自由变量和“表面”或约束变量之间的区别进行了特殊运用。由于“x”是一个变量，“xRy”将成为我们扩展语言中的一个原子公式，其中“x”和“y”是真实变量。当这样的公式与命题连接词∼、∨等结合时，结果是一个矩阵。例如，“aRx.∨.xRy”将成为一个矩阵。

正如我们之前所看到的，还有一些变量可以涵盖函数：“ϕ, ψ, …,f,g”等等。因此，“ϕx”包含两个变量，并代表一个命题，特别是将函数ϕ应用于个体 x 的结果。

定理是用真实变量陈述的，这使它们在理论上具有特殊意义。例如，

∗10⋅1⊢:(x).ϕx.⊃.ϕyPp

是 PM 的量化理论的基本公理。在这个原始命题中，“ϕ”和“y”是真实的（自由的）变量，“x”是明显的（约束的）。由于系统中没有常量，这是 PM 最接近普遍实例化规则的规则。

Whitehead 和 Russell 将“(x).ϕx”解释为“断言ϕ^x 的所有值的命题”（PM 41）。在类型理论中，“所有”一词具有特殊意义。他们提出了潜藏在类型理论中的恶性循环原则：

> … 一般来说，给定任何一组对象，假设该组具有一个总体，那么它将包含预设这个总体的成员，那么这样的集合就不能有一个总体。当我们说这个集合“没有总体”时，主要是指不能对“所有成员”做出重要的陈述。（《数学原理》，37 页）

具体来说，一个量化表达式，因为它谈论（预设）一个整体的“所有”成员，必须表达一个不同、更高的逻辑类型的成员，以遵守恶性循环原则。因此，在解释一个绑定变量时，我们必须假设它范围在特定类型的实体上，并且类型必须分配给公式中表示的其他实体，以遵守类型理论。

然而，一旦人们意识到 PM 中的原始命题和定理（如∗10·1）被认为是“通常模糊的”（即，与类型有关的模糊），就会出现一个问题。这些陈述实际上是示意图，并代表了通过适当解释类型可以得出的所有可能的具体断言。但是，如果像∗10·1 这样的陈述是示意图，但又具有绑定变量，那么我们如何为绑定变量的范围内的实体分配类型呢？答案是首先确定陈述中的自由变量范围的类型。例如，假设∗10·1 中的变量 y 范围在个体（类型为ι）上，那么变量ϕ必须范围在类型为（ι）/n 的函数上，其中 n 是某个数。然后，绑定变量 x 也将范围在个体上。然而，如果我们假设∗10·1 中的变量 y 范围在类型为（ι）/1 的函数上，那么变量ϕ必须范围在类型为((ι)/1)/m 的函数上，其中 m 是某个数。在这种情况下，绑定变量 x 将范围在类型为（ι）/1 的函数上。

因此，在∗10·1 中，y 和ϕ被称为“实际”变量，不仅因为它们是自由的，而且因为它们可以涵盖任何类型。怀特海德和罗素经常说，实际变量被模糊地表示为它们的“任何”实例，而约束变量（也模糊地表示）则涵盖它们的“所有”实例（在合法的整体内，即类型）。

## 7. 预测函数和恒等式

在变量后面加上感叹号“!”表示函数，并在参数前面加上感叹号，例如“f!^x”，“ϕ!x”，“ϕ!^x”，表示该函数是预测的，即它是可以应用于其参数的最低阶函数。在教堂的符号中，这意味着预测函数都是一级的，类型形式为（…）/1。因此，预测函数的阶数将比其任何参数的最高阶数高一级。这种分析是基于《数学原理》引言中的以下引文：

> 当我们将一个变量的函数定义为谓词时，它的阶数比其参数的阶数高一阶，即与其具有该参数的最低阶数相容。（《数学原理》，53 页）

不幸的是，在∗12 的总结中，我们发现“谓词函数是不包含明显变量的函数，即矩阵”（《数学原理》，167 页）。将这个陈述与引言中的定义相调和是学者们面临的一个问题。

要看到感叹号符号的作用，请考虑以下对恒等性的定义：

∗13⋅01x=y.=:(ϕ):ϕ!x.⊃.ϕ!yDf

这意味着，如果且仅当 y 具有 x 拥有的每个谓词函数ϕ时，x 与 y 是相同的。（当然，“=”的第二次出现表示定义，而不是独立具有意义。它是关于个体 x 和 y 的第一次出现被定义的。）

为了看到这个定义如何归结为更熟悉的同一性定义（即对象当且仅当它们共享相同的属性时是相同的），我们需要可约性公理。可约性公理规定，对于任何函数，都存在一个等价函数（即对所有相同参数都为真的函数），它是谓词的。

可简化公理：∗12⋅1⊢:(∃f):ϕx.≡x.f!xPp

要看到这个公理如何暗示更熟悉的等同定义，请注意更熟悉的等同定义是：

x=y.=:(ϕ):ϕx.⊃.ϕyDf

对于“任意”类型的ϕ。（注意，这与∗13·01 不同，因为感叹号不再出现。）现在要证明这一点，假设∗13·01 和可化约性公理都成立，并且假设为了通过反证法证明 x=y，ϕx，但不是ϕy，其中ϕ是任意类型的函数。然后，可化约性公理∗12·1 保证将存在一个谓词函数ψ！，它与ϕ具有相同的外延，使得ψ！x 成立但ψ！y 不成立，这与∗13·01 矛盾。

## 8. 确定描述

PM 中使用倒置的希腊字母 iota“ι”，后面总是跟着一个变量，用于开始一个确定描述。（ιx）ϕx 被读作“x 是ϕ的那个 x”，或更简单地说，“ϕ”。这样的表达式可以出现在主语位置，例如ψ（ιx）ϕx，读作“ϕ是ψ”。罗素著名的“确定描述理论”的形式部分包括一个定义所有包含描述的公式“…ψ（ιx）ϕx…”。为了区分描述的范围与包含表达式ψ（ιx）ϕx 的更大句子的其余部分（由上面的省略号表示），在方括号内重复确定描述。

[(ιx)ϕx].ψ(ιx)ϕx

范围的概念旨在解释罗素在《论指称》（1905）中著名讨论的一个区别。罗素说，“法国现任国王不秃头”这句话有两种解读：（1）它说法国现任国王不秃头，（2）它否认法国现任国王秃头。前一种解读要求在不秃头的事物列表中有一个唯一的法国现任国王，而后一种解读只是说在秃头的事物列表中没有唯一的法国现任国王。罗素说后者可以在没有法国现任国王的情况下成立，但前者不行。罗素将这种差异分析为定指的范围问题，尽管我们将看到，一些现代逻辑学家倾向于将这种情况视为否定符号的范围问题。因此，罗素引入了一种指示定指范围的方法。

要了解罗素的范围方法如何适用于这种情况，我们必须理解引入定指（即倒置的 iota 运算符）的定义。怀特海德和罗素定义：

∗14⋅01[(ιx)ϕx].ψ(ιx)ϕx.=:(∃b):ϕx.≡x.x=b:ψbDf

这种定义被称为上下文定义，与显式定义相对。对于定义描述的显式定义必须类似于以下内容：

(ιx)(ϕx)=:…Df

这将允许在任何上下文中用填充省略号的任何定义表达式替换明确的描述。相比之下，∗14·01 显示了一个句子如何被替换为另一个句子（涉及ϕ和ψ），这个句子在上下文ψ中存在一个描述（ιx）（ϕx）。为了发展这个定义的一个实例，从以下示例开始：

 示例。
法国现任国王是秃头。

使用 PKFx 来表示法国现任国王的命题函数，使用 B 来表示秃头的命题函数，Whitehead 和 Russell 将上述主张表示为：

[(ιx)(PKFx)].B(ιx)(PKFx)

这根据∗14·01 的意思是：

(∃b):PKFx.≡x.x=b:Bb

用文字来说，存在一个且仅有一个 b，它是法国现任国王且 b 是秃头的。用现代符号，将 b 非标准地用作变量，可以表示为：

(∃b)[∀x(PKFx≡x=b)&Bb]

现在我们回到这个例子，展示了描述的范围如何产生差异：

 例子。
法国现任国王不秃头。

表示这个句子有两种选择。

[(ιx)(Kx)].∼B(ιx)(Kx)

 和

∼[(ιx)(Kx)].B(ιx)(Kx)

在第一个中，描述具有“广泛”的范围，在第二个中，描述具有“狭窄”的范围。罗素说，在前者中，描述具有“主要出现”，在后者中，描述具有“次要出现”。根据定义∗14·01，上面的两个 PM 公式立即被展开为原始符号表示：

(∃b):PKFx≡xx=b:∼Bb∼(∃b):PKFx≡xx=b:Bb

在现代符号中，它们变成了：

∃x[∀y(PKFy≡y=x)&∼Bx]∼∃x[∀y(PKFy≡y=x)&Bx]

前者表示法说的是，存在一个且仅有一个对象是法国现任国王，并且这个对象不是秃头的；也就是说，法国现任国王只有一个，并且他不是秃头的。鉴于现在没有法国现任国王，这种解释是错误的。后者表示法说的是，不存在一个且仅有一个对象是法国现任国王，并且这个对象是秃头的。鉴于现在连一个法国现任国王都没有，这种解释是正确的。

虽然怀特海德和罗素认为这些例子中的描述是具有范围的表达式，但以上在扩展的 PM 符号和现代符号中的解读表明为什么一些现代逻辑学家认为这里的解读差异是否定符号范围的问题。

## 9. 类、关系和函数

在公式前面的变量上方使用帽子符号“ˆ”来表示一个类，因此^xψx 是那些满足ψx 的事物 x 的类。在现代符号中，我们将这个类表示为{x∣ψx}，读作：那些满足ψx 的 x 的类。请记住，“ϕ^x”，带有谓词变量后面的帽子符号，表示具有ϕx 的 x 的命题函数。在 PM 的类型理论中，类^xϕx 与函数ϕ^x 具有相同的逻辑类型。这使得使用以下上下文定义是合适的，它允许将类项^xψx 从上下文 f:∗20⋅01f{^z(ψz)}中消除。=:(∃ϕ):ϕ!x.≡x.ψx:f{ϕ!^z}D 在现代符号中:f{z∣ψz}=df∃ϕ[∀x(ϕx≡ψx)&f(λxϕx)]其中ϕ是 x 的谓词函数

注意，f 必须被解释为一个高阶函数，该函数是对函数ϕ!^z 的谓词。在上述使用的现代符号中，语言必须是一种允许在参数位置使用λ表达式的类型化语言。正如后来指出的（Chwistek 1924，Gödel 1944 和 Carnap 1947），类表达式应该有范围指示符，就像对于确定描述一样。 （关于类的命题中可能存在范围歧义的可能性在引言的最后一句中提到（PM I，84））。例如，Chwistek 建议复制确定描述的符号，从而用[^z(ψz)].f{^z(ψz)}.=:(∃ϕ):ϕ!x.≡x.ψx:f{ϕ!^z}替换∗20·01：

[^z(ψz)].f{^z(ψz)}.=:(∃ϕ):ϕ!x.≡x.ψx:f{ϕ!^z}

当当代集合论的形式化需要形如∃x∀y(y∈x≡…y…)的“存在”定理时，它们使用类似这些上下文定义，以便证明引入一个特定术语{y∣…y…}的合理性。参见 Suppes（1960）。根据外延性定律，从∃x∀y(y∈x≡…y…)可以得出存在唯一这样的集合。在 PM 中，类的成员关系∈是通过首先定义对象和命题函数之间的类似关系来定义的：∗20⋅02x∈(ϕ!^z).=.ϕ!xD，用现代符号表示为 x∈λzϕz=dfϕx。

∗20·01 和∗20·02 一起用来定义类的更熟悉的成员概念。形式表达式“y∈{^z(ϕz)}”现在可以看作是类术语出现的上下文，然后通过上下文定义∗20·01 被消除。（练习）

在《数学原理》中，有一个所有类的类，Cls，定义为：∗20⋅03Cls=^α{(∃ϕ).α=^z(ϕ!z)}Df

《数学原理》还使用希腊字母表示类：α，β，γ等。它们将出现为绑定（实际）变量，显式（自由）变量以及用于类的命题函数的抽象，如ϕ^α。只有绑定的希腊变量的定义出现在正文中，其他变量在引言中非正式地定义：∗20⋅07(α).fα.=.(ϕ).f{^z(ϕ!z)}Dfor，在现代符号中，∀αfα=df∀ϕf{z∣ϕz}，其中ϕ是一个谓词函数。

因此，普遍量化的类变量是通过量化谓词函数来定义的。对于存在量化也是如此：∗20⋅071(∃α).fα.=.(∃ϕ).f{^z(ϕ!z)}D，用现代符号表示为∃αfα=df∃ϕf{z∣ϕz}，其中ϕ是一个谓词函数。

在∈左边带有希腊变量的表达式被定义为：∗20⋅081α∈ψ!^α.=.ψ!αDf

这些定义并不涵盖所有可能出现的希腊变量。在《数学原理》的引言中，对 fα和 f^α提出了进一步的定义，但指出这些定义在某种程度上是特殊的，并且它们不出现在作品的正文中。对于 f^α的定义如下：

f^α.=.(∃ψ).^ϕ!x≡xψ!x.f{ψ!^z}

或者，用现代符号表示，

λαfα=dfλϕf{x∣ϕx}

也就是说，f^α是一个表达式，用来命名一个将函数ϕ映射到断言 f 的类的函数。（现代符号表示，在 PM 符号中对 f^α的定义中，我们不应该期望α出现在定义中，因为它实际上是 f^α中的一个约束变量；同样，我们不应该期望ϕ出现在定义中，因为它是定义中的一个约束变量。）人们也可能期望像∗20·07 和∗20·071 这样的定义适用于将罗马字母“z”替换为希腊字母的情况。因此，PM 中的定义并不完整，但可以猜测如何扩展这些定义以涵盖所有希腊字母的出现。这将完成“无类”类理论的项目，通过展示如何将所有关于类的讨论归纳为命题函数理论。

## 10. 结束数理逻辑

虽然哲学学生通常只读到 PM 中的∗20，但实际上这是数学“构建”的起点。∗21 提出了“关系的一般理论”（关系的外延理论；在现代逻辑中，这些被视为有序对的集合，遵循 Wiener 的方法）。^x^yψ(x,y)是当ψ(x,y)为真时，x 和 y 之间的关系。在现代符号中，我们将其表示为有序对的集合{⟨x,y⟩∣ψ(x,y)}，读作：有序对⟨x,y⟩，使得 x 与 y 之间存在关系ψ。

下面的上下文定义 (∗21·01) 允许将关系项 ^x^yψ(x,y) 从上下文 f 的出现中消除：

f{^x^yψ(x,y)}.=:.(∃ϕ):ϕ!(x,y).≡x,y.ψ(x,y):f{ϕ!(^u,^v)}Df

或者用现代符号表示：

f{⟨x,y⟩∣ψ(x,y)}=df∃ϕ[∀xy(ϕ(x,y)≡ψ(x,y))&f(λuλvϕ(u,v))]

其中ϕ是 u 和 v 的谓词函数。

《数学原理》不是通过有序对的集合来分析关系（或数学函数），而是将命题函数的概念作为原始概念，并以此来定义关系和函数。大写字母 R、S 和 T 等在∗21 之后用来表示这些“外延关系”，并通过在参数之间书写来与命题函数区分开。因此，ψ(x,y)是在命题函数符号之后带有参数的，而 xRy。从∗21 开始，“ϕ和ψ”等函数消失了，只有外延关系 R、S 和 T 等出现在《数学原理》的页面中。虽然命题函数可能是“内涵的”，即两个函数可能对相同的对象成立但不相等，但没有不同的外延关系对所有相同的对象成立。因此，《数学原理》的逻辑是“外延的”，从第一卷的第 200 页一直到第三卷的末尾。

∗22关于“类的微积分”介绍了交集、并集和空集的基本集合论，这通常是其他类型的初等数学中使用的全部集合论。想要将Principia的集合论与Zermelo-Fraenkel系统进行比较的学生，需要在文本的后面查看各种数字。选择公理在∗88被定义为“乘法公理”，无穷公理的一个版本在第二卷的∗120处被称为“Infin ax”。Principia的集合论在各种熟悉的公理系统中最接近1908年Zermelo的公理，这意味着它缺乏现在标准的Zermelo-Fraenkel集合论公理中的基础公理和替换公理。Principia系统与Zermelo的一个重要区别在于它是在简单类型理论中构建的。因此，例如，没有量词涵盖所有集合，并且每种类型都有一个包含所有事物的集合。

∗30 关于“描述性函数”的部分提供了怀特海德和罗素对数学函数的分析，其中涉及关系和明确描述。弗雷格在他的逻辑系统中使用了函数的概念，作为数学意义上的基本概念。因此，弗雷格的“概念”是一个从对象作为参数到两个“真值”之一的函数。对于每个概念适用的对象，概念的值为“真”，对于其他所有对象，概念的值为“假”。罗素在发现他的描述理论之前，就更倾向于用每个参数和值之间的关系以及“唯一性”的概念来分析函数。用现代符号表示，他的观点可以表达如下。对于每个函数λxf(x)，都会存在某个关系（在范围内），使得函数对于参数 a 的值，即 f(a)，将是唯一的个体，该个体与 a 之间具有关系 R。结果是，在《数学原理》中没有函数符号。正如怀特海德和罗素所说，熟悉的数学表达式如“sinπ/2”将被分析为一个关系和一个明确描述，作为一个“描述性函数”。这个“描述性函数”R‘y（y 的 R）的定义如下：

∗30⋅01R‘y=(ιx)xRyDf

如果关系 R 是在 x 和 y 之间，当 x 是 y 的父亲时，函数将以个体 y 作为参数，将值 x 作为他们的父亲。例如，如果 xRy 是关系“x 是 y 的父亲”，那么 R‘y 是将 y 映射到他的父亲的函数（如果他存在）。注意，在这里左边的参数 x 对应于函数的值，而 R 的右边参数 y 是函数 R‘y 的参数或输入。同样，如果 xSy 是一个数字与其后继的关系，n 与 n+1，那么 S‘y 将是将 y 映射到它的后继数字的函数的参数，而不是表示将一个数字映射到其后继的“后继函数”。这与现在常用的关联函数和关系的顺序相反。现在我们将函数简化为第一个参数中的二元关系和第二个参数中的值之间的关系。这可能会在下面关系的定义中导致一些混淆，例如关系的定义域和值域。

我们通过在第一卷的其余部分中提供一些著名的例子来结束本节，包括它们的直观含义、在《数学原理》中的位置、在《数学原理》中的定义以及现代版本。（其中一些数字是定理而不是定义。）然而，请注意，现代的表述有时在逻辑上与《数学原理》中的原始版本不同，例如将关系视为有序对的类等。更重要的是，《数学原理》中的做法是将概念定义为关系，或者是由这些关系决定的关系之间的高阶关系，而不是作为函数。在他对《数学原理》逻辑的解释中，W.V.奎因（1951）对这种符号与公理集合论相比的复杂性甚至冗余性提出了异议。然而，这些公式可以通过逐步应用定义来解决。

对于每个公式编号，我们以以下格式呈现信息：

| PM Symbol | （直观意义）[位置]<br /> 《数学原理》定义<br /> 现代版本 |
| ----------- | -------------------------------------------------- |

 ∗22 类的微积分

| α⊂β | (α是β的子集) [∗22·01]<br />x∈α.⊃x.x∈β<br />α⊆β           |
| -------- | -------------------------------------------------------------- |
| α∩β | (α和β的交集) [∗22·02]<br />^x(x∈α.x∈β)<br />α∩β           |
| α∪β | (α和β的并集) [∗22·03]<br />^x(x∈α∨x∈β)<br />α∪β          |
| −α   | (α的补集) [∗22·04]<br />^x(x∼∈α) [即，^x∼(x∈α) 通过 ∗20·06]<br />{x∣x∉α} |
| α−β | (α减去β) [∗22·05]<br />α∩−β<br />{x∣x∈α&x∉β}            |

∗23 关系的微积分

| R⊂⋅S | (R 是 S 的子关系) [∗23·01]<br />xRy.⊃x,y.xSy<br />∀x∀y(xRy⊃xSy) |
| -------- | --------------------------------------------------------------- |
| R˙∩S | (R 和 S 的交集) [∗23·02]<br />^x^y(xRy.xSy)<br />{⟨x,y⟩              |
| ˙−R  | (R 的否定) [∗23·04]<br />˙−R=^x^y{∼(xRy)}<br />{⟨x,y⟩             |

∗24 类的存在

| V     | (通用类) [∗ 24·01]<br />^x(x = x)<br /> V 或 {x∣x=x}    |
| ------- | ---------------------------------------------------- |
| Λ    | （空类）[∗24·02]<br />−V<br />∅                        |
| ∃!α | (类别 α 存在) [∗24·03]<br />(∃x).x∈α<br />∃x(x∈α) |

∗25 关系的存在

| ˙∃!R | (关系 R 存在) [∗25·03]<br />(∃x,y).xRy<br />∃x∃yRxy |
| -------- | -------------------------------------------------- |

∗30 描述性函数

| R‘y | (y 的 R) (一个描述性函数) [∗30·01]<br />(ιx)(xRy)<br />R'y 是（可能是部分的）函数，其中 fR(y)=x，如果 x Ry 且此 x 是唯一的，否则未定义。 |
| ------ | ------------------------------------------------------------------------------------------------------------------------------------- |

∗31 关系的逆

| Cnv | (关系与其逆关系之间的关系) [∗31·01]<br />^Q^P{xQy.≡x,y.yPx}<br />{⟨Q,P⟩∣∀x∀y(Qxy≡Pyx)} |
| ----- | -------------------------------------------------------------------------------------- |
| ˘R | (R 的逆) [∗31·02]<br />^x^z(zRx)<br />{⟨x,z⟩∣Rzx}                                          |

∗32 给定术语的指称和关联

| →R‘y | (y 的 R-前身) [∗32·01]<br />^x(xRy)<br />{x∣Rxy} |
| -------- | --------------------------------------------- |
| ←R‘x | (x 的 R-后继) [∗32·02]<br />^z(xRz)<br />{z∣Rxz} |

∗33 关系的定义域和值域

| D‘R | (关系 R 的定义域) [∗33·01]<br />^x{(∃y).xRy}<br /> {x∣∃yRxy} 也称为：D‘R     |
| ------ | ---------------------------------------------------------------------------- |
| D‘R | (R 的逆域（值域）) [∗33·02]<br />^z{(∃x).xRz}<br /> {z∣∃xRxz} 也是 R‘R       |
| C‘R | (R 的领域) [∗33·03]<br />^x{(∃y):xRy.∨.yRx}<br /> {x∣∃y(Rxy∨Ryx)} 也是 F‘R |

∗34 两个关系的相对积

| R∣S | (R 和 S 的相对乘积) [∗34·01]<br />^x^z{(∃y).xRy.ySz}<br />R∘S 或{⟨x,z⟩∣∃y(Rxy&Syz)} |
| ------ | ---------------------------------------------------------------------------------- |

∗35 有限域和逆域

| α↿R  | （R 的域限制为α）[∗35·01]<br />^x^y[x∈α.xRy]<br />{⟨x,y⟩∣x∈α&Rxy}                                       |
| -------- | -------------------------------------------------------------------------------------------------------- |
| R↾β  | (R 的范围限制为β) [∗35·02]<br />^x^y[xRy.y∈β]<br />{⟨x,y⟩∣Rxy&y∈β}                                      |
| α↑β | (α的成员与β的成员之间的关系) [∗35·02].<br />^x^y[x∈α.y∈β]<br />{⟨x,y⟩∣x∈α&y∈β}，α和β的笛卡尔积。 |

∗36 有限域的关系

| P↾⇂α | (R 对α的限制) [∗36·01]<br />α↿P↾α<br />{⟨x,y⟩∣x∈α&y∈α&Rxy} |
| --------- | ------------------------------------------------------------------ |

∗37 复数描述函数

| R‘‘β | (具有与β的成员之间关系 R 的术语) [∗37·01] ∗<br />^x{(∃y).y∈β.xRy}<br />{x∣∃y(y∈β&Rxy)}                            |
| --------- | ---------------------------------------------------------------------------------------------------------------------- |
| R∈     | (当α是具有 R 与β的成员的术语类时，α与β的关系) [∗37·02]<br />^α^β(α=R‘‘β)<br />{⟨α,β⟩∣x∈α&∃z(y∈z&z∈β&Ryz)} |

∗38 双重描述函数。《数学原理》使用一个元语言变量“♀”，可以被个体、类或关系之间的一系列关系替换，这些关系被视为对它们的参数进行操作。交集操作可以表示为其第一个参数的高阶函数。因此，∩β‘α=α∩β。

| ♀y | （对于任何 x，x♀y 与 x 的关系）[∗38·02]<br />^u^x(u=x♀y)<br />{⟨u,x⟩∣u=x♀y} |
| ----- | -------------------------------------------------------------------------- |

这个概念将在后面使用。相对乘积概念的一个实例是这样的：

| ∣R     | （R 的一个幂与下一个幂之间的关系）[∗38·02]<br />^P^S(P=R∣S)<br />{⟨P,S⟩∣P=R∘S}               |
| --------- | ------------------------------------------------------------------------------------------ |
| α♀,,y | (x 是α时，x♀y 的值的类) [∗38·03]<br /> ♀y " α<br />{u∣∃x(x∈α&u=x♀y)}                  |
| s‘κ   | (κs 的和或并集) [∗40·02]<br />^x{(∃α).α∈κ.x∈α}<br /> ∪κ，或者{x∣∃β(β∈κ&x∈β)} |
| ˙s‘λ | （λ中的关系之和）[∗41·02]<br />^x^y{(∃R).R∈λ.xRy}<br />{⟨x,y⟩∣∃R(R∈λ&Rxy)}              |

## 11. 《数学原理》中的基数算术导言（第二部分）

当代哲学家们认为数学的转变始于集合论（或者是太大以至于不能被视为集合的适当类），但在《数学原理》中，这也是数理逻辑的一部分。因此，《算术前奏》从逻辑角度出发，以明确的算术概念定义开始，如基数 1 和 2。

| I     | （身份关系）[∗50·01]<br />I=^x^y(x=y)<br />{⟨x,y⟩∣x=y}                                                                                                                                                                      |
| ------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| J     | (多样性的关系) [∗50·02]<br />I=˙−I<br />{⟨x,y⟩∣x≠y}                                                                                                                                                                   |
| ι‘x | (x 的单位类)根据定理[∗51·1]从定义[∗51·01]定义<br />^y(y=x)<br />{y∣y=x}（单元素 x）                                                                                                                                      |
| 1     | （基数 1）[∗52·01]<br />^α{(∃x).α=ι‘x}<br />{α∣∃x(α={x})}（所有单例的类）<br />变量 x 在这里通常是模糊的，因此对于 x 可以假设的每种类型，将有一个不同的数字 1。<br />这也适用于 2 以及所有自然数，正如我们将在下面看到的。 |
| 2     | (基数 2) [∗54·02]<br />^α{(∃x,y).x≠y.α=ι‘x∪ι‘y}<br />{α∣∃y∃z(y≠z&α={y}∪{z})} (所有对的类)                                                                                                                   |
| x↓y  | (x 和 y 的序偶) [∗55·01]<br />ι‘x↑ι‘y<br />⟨x,y⟩ (有序对⟨x,y⟩)                                                                                                                                                     |

《数学原理》的平装简化版只到∗56，所以剩下的定义只有那些能够访问完整的三卷本《数学原理》的人才能够获得。罗素并没有决定在这一点上结束 1962 年的简化版本，但这个选择是可以理解的。正是在这里，当代集合论开始与《数学原理》看起来更加不同。集合论遵循诺伯特·维纳（1914 年）的做法，将关系表示为有序对的集合，这些有序对本身被定义为集合。（维纳的提议⟨x,y⟩=df{{{x},∅},{{y}}}通常被库拉托夫斯基的更简单的{{x},{x,y}}所取代）。《数学原理》的剩余部分研究了导致自然数和实数的数学以及可以在类型论中进行的超限集合理论的结构。这与公理集合论中这些概念的发展非常不同。

|Cl ‘α|（α的子类的类）[∗60·12]<br /> ^β（β⊂α）}℘α，α的幂集，{x|x⊆α}|| ------------| -----------------------------------------------------------------------------||Cl ex ‘α|（α的存在子类的类）[∗60·13]^β(β⊂α.∃!β)}<br />{x|x⊆α&x≠∅}|
|Rl ‘P|(P 的子关系类) [∗61·12]<br />^R{R⊂⋅P}{R∣∀x∀y(⟨x,y⟩∈R⊃⟨x,y⟩∈P)}||∈|(属于一个类的关系) [∗62·01]^x^α(x∈α)<br />{⟨x,y⟩∣x∈y}|

∗63 相对类型的类。PM 中的类型理论允许表达不同类型的类之间的表达式。PM 中集合论和类论之间的差距来自于缺乏任何类型的类的累积理论。这些 PM 系统允许定义个体和个体类之间的关系，例如在第三卷中以类的类的比率的形式解释实数所需的关系。

| t‘x                 | (其中 x 是成员的类型) [∗63·01]<br />ι‘x∪−ι‘x<br />{x}∪{y∣y∉{x}}                                                                                                                                                           |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| t0‘α               | (α所包含的类型) [∗63·02]<br />α∪−α<br />α∪{x∣x∉α}                                                                                                                                                                        |
| t1‘κ               | （κ所包含的下一个类型）[∗63·03]<br /> t0 的'κ<br />∪{∪{α∣α∈κ},{β∣β∉∪{α∣α∈κ}}}                                                                                                                                   |
| t11‘α              | （类型为 t1'α的类对的类型）[∗64·022]<br />t‘(t1‘α↑t1‘α)<br />给定类型的一对类的类型将与这些类的类的类型相同。这个定义本身是有序的，但是用当代符号来写会非常复杂。我们将其作为一个开放问题留给读者来设计一个简洁的公式表达。 |
| α→β               | （在α中具有指示物的关系和在β中具有关联物的关系）（从α到β）[∗70·01]<br />^R(→R“D‘R⊂α.←R“D‘R⊂β)<br />{R∣∀x∀y(Rxy⊃[{z∣Rxz}∈α&{u∣Rxu}∈β}]}<br />由于 1 是单例类的类，(1→1)将是一对一（满射）关系的类。            |
| α¯¯¯¯¯¯¯smβ | (α和β之间的相似关系类) [∗73·03]<br />{R∣R∈1→1.α=D‘R.β=D‘R}<br />{f∣f:α1−1⟶β}                                                                                                                                         |
| sm                   | (相似关系) [∗73·02]<br />^α^β(∃!α¯¯¯¯¯¯¯smβ)<br />α≈β                                                                                                                                                                   |

∗80 选择。对于一个类κ，选择函数 f 是一个将κ的每个元素 x 映射到 x 的成员的函数。这些用∈Δ‘κ表示。两个类α和β的乘积的基数是从α和β中选择的所有成员对的类的基数，因此保证这样的选择存在被称为 PM 中的乘法公理。现在这被称为选择公理，它在 1904 年由恩斯特·策梅洛在集合论中被确定为一个假设。在 PM 中，它被定义为断言如果一个类κ是一组互斥的非空类的集合，则存在一个类μ，它包含κ的每个元素的一个成员。

| ∈Δ‘κ     | (对于∈的选择关系) [∗80·01]<br />(1→Cls)∩Rl‘∈∩←D‘κ<br />{f∣∀α(α∈κ⊃f(α)∈α)}                                                                                                |
| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Cls2 excl    | (相互排斥类的类) [∗84·01]<br />^κ(α,β∈κ.α≠β.⊃α,β.α∩β=Λ)<br />{κ∣∀α∀β(α,β∈κ&α≠β⊃α∩β=∅)}                                                                     |
| Cls ex2 excl | (相互排斥的非空类的类) [∗84·03]<br />Cls2excl−←∈‘Λ<br />{κ∣∀α(α∈κ⊃α≠∅)& ∀α∀β[α∈κ&β∈κ⊃(α=β∨α∩β=∅)]}                                                        |
| Mult ax      | (乘法公理) [∗88·03 ]<br />κϵClsex2excl.⊃κ:(∃μ):αϵκ.⊃α.μ∩αϵ1<br />∀κ{[∀α(α∈κ⊃α≠∅)& ∀α∀β(α∈κ&β∈κ⊃(α=β∨α∩β=∅))]⊃ ∃μ∀α∃x(α∈κ⊃μ∩α={x})} |

∗90 归纳关系。第一卷的结尾部分提出了自然数结构的一般化，这是数学归纳原理的基础。

| R∗        | (R 的祖先) [∗90·01]<br />^x^y{x∈C‘R:˘R“μ⊂μ.x∈μ.⊃μ.y∈μ}<br />{⟨x,y⟩∣x∈F‘R& ∀μ[∀z∀w[(z∈μ&Rzw)⊃w∈μ]⊃y∈μ]}<br />现在写作 R∗，这遵循弗雷格的定义：y 在包含 x 的所有 R-遗传类中。 |
| ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Rts        | (R 与其幂级数 Rn（n>0）之间的关系，即 R（=R1），R2，R3 等）[∗91·02]<br />(∣R)∗<br />{⟨P,S⟩∣P=Rn&S=Rn+1}                                                                                        |
| Pot ‘R    | (R 的正幂，即 R 的 Potentia) [∗91·03]<br />→Rts‘R<br />{S∣∃n>0(S=Rn)}                                                                                                                           |
| Rpo        | (R 的正幂的并集) [∗91·05]<br />˙s‘Pot‘R<br />{⟨x,y⟩∣∃S∃n>0(S=Rn&Sxy)}                                                                                                                       |
| xB‘P      | (x 开始关系 P) [∗93·01]<br />x∈D‘P−D‘P<br />{x∣∃yPxy&∼∃zPzx}                                                                                                                                |
| x minP‘α | ( x 是α相对于 P 的最小成员) [∗93·02]<br />x∈α∩C‘P−˘P‘‘α<br />x∈α&x∈FP&∼∃z(Pzx&z∈α)                                                                                                 |
| ↔R‘x     | ( R 的家族，祖先和后代) [∗97·01]<br />→R‘x∪(ι‘x∩C‘R)∪←R‘x<br />{y∣Rxy∨(y=x&x∈F‘R)∨Rxy}                                                                                               |

## 12. 基数算术（第三部分）

在第二卷开始时，以《数学原理》的形式，终于开始了基数数学理论的发展，其中将数字定义为等势类的类，采用了弗雷格-罗素定义。

| Nc      | （类与其基数之间的关系）[∗100·01]<br />−→sm<br />{⟨α,β⟩∣β={γ∣γ≈α}}                                                                                                                                        |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| NC      | （基数）[∗100·02]<br /> D'Nc<br />{α∣∃β(α={γ∣γ≈β}}                                                                                                                                                           |
| 0       | (the cardinal number 0)    [∗101·01]<br />0=Nc‘Λ<br />{∅}<br />所有与空集等势的类的类集只是包含空集的单例集。                                                                                                           |
| N0c‘α | (α的同类基数) [∗103·01]<br />Nc‘α∩t‘α<br />{β∣β≈α} 对于与α类型相同的β                                                                                                                                     |
| N0C     | (同次基数) [∗103·02]<br /> D'N0c<br />{α∣∃β(α是β的同次基数)}                                                                                                                                                     |
| α+β   | (α和β的算术和) [∗110·01]<br />↓(Λ∩β)“ι“α∪(Λ∩α)↓“ι“β<br />这是将α和β进行配对，使它们成为不相交的集合后的并集。类别α和β与空类Λ相交，以调整和的元素类型。<br />{⟨{a},∅⟩∣a∈α}∪{∅,{b}⟩∣b∈β} |
| μ+cν  | (μ和ν的基数和) [∗110·02]<br />^ξ{(∃α,β).μ=N0c‘α.ν=N0c‘β.ξsm(α+β)}<br />基数加法是同类基数的算术和：<br />当α和β是同类基数时，{γ∣∃α∃β[γ≈(α+β)]}。                                                |

读者现在可以理解为什么这个基本定理直到《数学原理》第二卷的第 83 页才被证明：

∗110⋅6431+c1=2

Whitehead 和 Russell 指出：“上述命题偶尔有用。它至少被使用了三次，在……”。这个笑话提醒我们，自然数理论在弗雷格的作品中是如此核心，而在《数学原理》中只是一般基数和序数理论以及更一般的同构结构类的特例。

| β×α    | （类的乘积）[∗113·02]<br />s‘α↓,,‘‘β<br />{⟨x,y⟩∣x∈β&y∈α}                                                                         |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| μ×cν   | （同类基数的乘积）[∗113·03]<br />^ξ{(∃α,β).μ=N0c‘α.ν=N0c‘β.ξsm(α×β)}<br />如果 μ=¯¯α&ν=¯¯β，则 μ×ν={β∣β≈(α×β)} |
| α exp β | （类的乘方）[∗116·01]<br /> 产品 ' α↓,,‘‘ β<br />{f∣Df=β&Rf⊆α}                                                                        |
| μν      | （基数的乘方）[∗116·02]<br />^γ{(∃α,β).μ=N0c‘α.ν=N0c‘β.γ sm (α exp β)}<br />{γ∣∃α∃β(μ=¯¯α&ν=¯¯β&γ≈αβ)}          |

《数学原理》中的下面的定理，即幂集的基数等于α的基数的 2 的α的基数次方，¯¯℘α=2¯¯α，被称为“康托尔的命题”，并被认为是“非常有用的”（PM II，140）：

∗116⋅72Nc‘Cl‘α=2Nc‘α

接下来是关于任意基数的大于的概念，有限和无限的。α的基数大于β的基数，当且仅当存在α的一个子集与β等势，但不存在β的一个子集与α等势。康托尔著名的“对角线论证”表明，实数类的基数ℵc 大于自然数类的基数ℵ0。

| μ>ν | (大于) [∗117·01]<br />(∃α,β).μ=N0c‘α.ν=N0c‘β.∃!Cl‘α∩Nc‘β.∼∃!Cl‘β∩Nc‘α<br />∃δ(δ∈℘α&δ∈¯¯β)&∼∃γ(γ∈℘β&γ∈¯¯α) |
| ------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |

更为熟知的结果，康托尔定理证明了α的幂集严格更大，2¯¯α>¯¯α。

∗117⋅661μ∈N0C.⊃.2μ>μ

| NC induct | (归纳基数) [∗120·01]<br />^α{α(+c1)∗0}<br />{x∣0S∗x}<br />归纳基数是“自然数”，即 0 和所有通过“后继关系”S 与 0 相关的基数，其中 xSy 当且仅当 y=x+1。 |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| Infin ax  | （无穷公理）[∗120·03]<br /> α∈NC 归纳。⊃α.∃!α<br />∀α(α∈{x∣0S∗x}⊃α≠∅)                                                                    |

《数学原理》中的无穷公理断言所有归纳基数都是非空的。（回想一下，0 = {∅}，所以 0 不是空的。）无穷公理不是一个“原始命题”，而是作为一个“假设”列出的，即作为条件语句的前提，其中后件将被认为依赖于该公理。从技术上讲，它不是 PM 的公理，因为[∗120·03]是一个定义，所以这只是 PM 中的进一步符号！

| Prog | (进展，或ω排序) [∗122·01]<br />(1→1)∩^R(D‘R=←−R∗‘‘B‘R)<br />{R∣R 与每个定义域的子集都有第一个元素的关系的祖先同构。} |
| ------ | --------------------------------------------------------------------------------------------------------------------------- |

"通过“进展”我们指的是一个类似于按大小顺序排列的归纳基数的系列（假设所有的归纳基数都存在），即一个其项可以称为 1R，2R，3R，…νR，…的系列。将进展定义为一个与归纳基数的系列在序数上相似的系列并不方便，因为这个定义只适用于我们假设无穷公理的情况，并且无论如何我们都必须证明（在假设无穷公理的情况下）归纳基数的系列具有某些性质，这些性质可以用来提供进展的直接定义。”（《数学原理》第二卷，245 页）

| ℵ0 | （康托尔的超限基数中最小的）[∗123·01]<br />D‘‘Prog<br />¯¯ω |
| ----- | ------------------------------------------------------------ |

## 13. 关系算术（第四部分）

关系数的概念是将良序的概念推广到任意关系上。正如在《数学原理》中将基数定义为等势类的类，任意关系数是一类序相似的关系。

| S;Q                            | (S 是 Q 的相关器) [∗150·01]<br />S∣Q∣˘S<br />S∘Q∘S−1                                                              |
| -------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| P¯¯¯¯¯¯¯¯¯¯¯¯smorQ | (P 和 Q 之间的相似性类) [∗151·01]<br />^S{S∈1→1.C‘Q=D‘S.P=S;Q}<br />{f∣FP1−1⟶FQ&∀x∀y[(x∈Df)⊃Pxy≡Qf(x)f(y)]} |
| P smor Q                       | (P 与 Q 是普通相似的) [∗151·02]<br />{⟨P,Q⟩∣∃!P¯¯¯¯¯¯¯¯¯¯¯¯smorQ}<br />P≅Q（P 与 Q 同构）。            |
| Nr‘P                          | （P 的关系编号）[∗152·01]<br />−−−→smor‘P<br />{Q∣P≅Q}                                                           |

∗170 首差异的关系根据成员的排序来对类进行排序。该方法是对类的词典中的字母顺序的变体。参见 Fraenkel（1968）。PM 使用两个版本的概念。

| Pcl | （按照 P 的首差异对类进行排序）[∗170·01]<br />^α^β{α,β∈Cl‘C‘P.∃!α−β−˘P‘‘(β−α)}<br />对于≺个体的排序，α≺clβ是<br />{⟨α,β⟩∣α , β⊆F(≺)&α⊈β&∀x∀y(x∈β&y∉α⊃y≺x)} |
| ----- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

这在《数学原理》的∗170 总结中解释：“α和β分别从 C'P 中挑选出项，这些项由 P 赋予顺序；我们假设α和β最早选择的项可能相同，但是迟早，如果α≠β，我们必须遇到属于其中一个而不属于另一个的项。我们假设这类项的最早项属于α而不属于β；在这种情况下，α对β具有关系 Pcl。也就是说，在α和β开始不同的地方，我们遇到的是α的项，而不是β的项。我们不假设有一个属于α但不属于β的第一个项，因为这会在 P 没有良序的情况下引入不必要的限制。”（《数学原理》第二卷，399 页）

| Plc | （通过 P 的首次差异的逆序排列）[∗170·02]<br />Cnv ‘(˘P)cl<br />{⟨α,β⟩∣α≺clβ} |
| ----- | ---------------------------------------------------------------------------------- |

"因此，αPlcβ大致意味着β-α的时间比α-β的时间更长，就像αPclβ意味着α-β开始得更早一样。如果 P 是时间上的先后关系，α和β分别是 A 和 B 起床的时间，“αPclβ”将意味着 A 比 B 早起床，“αPlcβ”将意味着 B 比 A 晚上床。”（《数学原理》II，401）

## 14. 级数（第五部分）

《数学原理》中的“Series”是线性排序。第二卷在这一部分中进行了一半的结论，第三卷从∗250 开始，讨论了良序理论。这些概念以现在的标准方式定义。这一部分之所以对现代读者来说陌生，是因为符号的使用。

| trans P  | (P 是传递关系) [∗201·1]<br />P2⊂⋅P<br />∀x∀y∀z(Pxy&Pyz⊃Pxz)                                                  |
| ---------- | -------------------------------------------------------------------------------------------------------------- |
| connex P | (P 是连通的) [∗202·1]<br />x∈C‘P.⊃x.↔P‘x=C‘P<br />∀x∀y[(x,y∈FP)&x≠y⊃Pxy∨Pyx]                           |
| Ser      | (*series*)    [∗204·01]<br />Rl ‘J∩ trans ∩ connex<br />{P∣∀x∀y(Pxy⊃x≠y)&P 是可传递的&P 是连通的}或者 P 是线性排序 |
| sect     | (*sections*)    [∗211·01]<br />sect ‘P=^α(α⊂C‘P.P“α⊂α)<br />{α∣α⊂FP&∀x[∃y(y∈α&Pxy)⊃x∈α]}                 |

"《数学原理》中，将一系列分为两个类别的分离模式的理论，其中一个类别完全在另一个类别之前，并且两个类别共同构成整个系列，具有基本重要性。...我们称任何可以成为这样一对中的第一个类别的类别为我们系列的一个部分。”（PM II，603）

| ς‘P | （P 的分段系列）[∗212·01]<br />Plc↾⇂ D‘P∈ |
| ------- | --------------------------------------------- |

《数学原理》第 211 条解释了定义如下：“D‘Pϵ的成员被称为由 P 生成的系列的段。在一个每个子类都有最大值或者一个顺序[直接后继(参见∗206)]的系列中，D‘Pϵ=→P‘C‘P (∗211⋅38)，即一个类的前任总是一个单个术语的前任，即类的最大值（如果存在）或者顺序（如果不存在最大值）。…因此，一般来说，段的系列将比原始系列更大。例如，如果我们的原始系列是按大小顺序的有理数系列，那么段的系列就是连续数系列的类型，即连续数的类型。”（《数学原理》第二卷，603 页）

> 根据∗211·13，我们不需要为截面系列使用特殊的符号，它是 ς‘P∗….（《数学原理》第二卷，628 页）

第三卷以∗250 开始，讨论良序关系。然后将序数定义为一类普通相似的良序关系。

| Bord | （良序关系 - Bene ordinata）[∗250·01]<br />^P{ Cl ex ‘C‘P⊂D‘minP}<br />{P∣∀α[(α⊆FP&α≠∅)⊃∃x(x∈α&∀z(z∈α⊃∼Pzx))] (Principia Mathematica to 《数学原理》) |
| ------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Ω   | (the well ordered series) [∗250·02] (有序数列)<br /> Ser ∩ Bord (Ser ∩ Bord)<br />Ω是良序线性序集的类。                                                                 |
| NO   | （序数）[∗251·01]<br /> Nr“ Ω<br />序数是同构的良序线序的类。                                                                                                            |

“策取公理”即乘法公理蕴含了每个集合都可以被良序排列，这个定理在∗258 中推导出来。这最初是由策梅洛（1904）证明的。

∗258⋅32μ∼∈1.∃!∈Δ‘Cl ex‘μ.⊃.μϵC“Ω

## 15. 数量（第六部分）

PM 的最后一节研究有理数和实数。它们是由实体之间的关系构建而成的，例如比较长度或重量，可以用尺子或天平来测量。当代测量理论研究实体之间的关系，以确定可以分配给它们作为表示其所具有的各种属性（如长度或重量）的“数量”的各种独立特征数字的比例尺或系统。请注意，实数不是作为有理数的类别构建的，而是作为一系列比例的类别中的“戴德金切割”。在 PM 中，与当代数学一样，由于有理数类（段）{r|r2≤2}没有有理数作为最小上界，该类本身将与无理数√2 等同。有理数 1/2 与其（较低的）有理数段{r|r<1/2}等同。

| U                   | （对于归纳基数而言大于）[∗300·01]<br />(+c1)po↾⇂(NC 归纳−ι‘Λ)<br />{⟨n,m⟩∣n>m}                                                                                                                             |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Prm                 | (相对质数) [∗302·01]<br />^ρ^σ{ρ,σϵNC 归纳: ρ=ξ×cτ.σ=η×cτ.⊃ξ,η,τ.τ=1}<br />randsare 相对质当且仅当∀j∀l∀k[(r=j×k&s=l×k)⊃k=1]                                                                     |
| (ρ,σ)Prmτ(μ,ν) | (ρ/σ在最简形式下为μ/ν，τ是μ和ν的最大公因数) [∗302·02]<br />ρPrmσ.τ∈NC 归纳−ι‘0.μ=ρ×cτ. ν=σ×cτ<br />r/s 的比率在最简形式下为 m/n，其中 k 是它们的最大公因数=定义为 r 和 s 互质且 m=r×k&n=k×s |
| (ρ,σ)Prm(μ,ν)   | (比率 ρ/σ是μ/ν的最简形式) [∗302·03]<br /> (∃τ)。(ρ,σ)Prmτ(μ,ν)<br />r/s 的比率在最简形式下为 m/n =df∃k（r/s 的比率在最简形式下，k 为其最大公因数）                                                      |
| μ/ν               | （关系μ和ν的比率）[∗303·01]<br />^R^S{(∃ρ,σ)。（ρ,σ）Prm（μ,ν）。˙∃!Rσ˙∩Sρ}<br />{⟨R,S⟩∣∃r∃s(r/s 是最简分数 m/n 且∃x∃y(Rsxy&Srxy)}                                                               |

"一条线上的距离是一个一对一的关系，其逆关系的定义域（以及它的定义域）是整个线。如果我们称这两个距离为 R 和 S，我们可以说它们的比率为μ/ν，如果从某一点 x 开始，R 的ν次重复带我们到达与 S 的μ次重复带我们到达的同一点 y，即 xRνy.xSμy。”（《数学原理》III，260）

| Rat def | （确定比率）[∗303·05]<br />^X{(∃μ,ν).μ,νϵD‘U∩D‘U.X=(μ/ν)↾⇂t11‘μ}<br />《数学原理》中限定为给定类型成员的比率类别。<br />注意以下定义不依赖于无穷公理。 |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| X<rY    | (小于比率之间) [∗304·01]<br />(∃μ,ν,ρ,σ). μ,ν,ρ,σϵNc induct.σ≠0. μ×cσ<ν×cρ.X=μ/ν.Y=ρ/σ<br />X<Y=df∃j∃k∃m∃n (j×m<k×n&X=j/k&Y=n/m)      |
| H       | (在确定比率之间的小于关系) [∗304·02]<br />^X^Y{X,Y∈Rat def.X<rY}<br />{⟨r,s⟩∣ris rational&sis rational&r<s}<br />"H"是大写的 eta "η"，康托尔用于表示有理数的符号。  |
| Θ      | （实数）[∗310·01]<br /> （ς'H）↾⇂（−ι'Λ−ι'D'H）                                                                                                       |

“除了 0 和无穷大之外的实数序列”（PM III, 316）是有理数段的序列，除了空类和整个序列。

## 16. 结论

这个摘要引用了《数学原理》中约 110 个定义。第二版（1925 年）第一卷的最后八页（667-674）包含了来自三卷的 498 个定义的完整列表。伯特兰·罗素档案中的通信证实了这是由多萝西·林奇编制的。她的列表可以用来追溯《数学原理》中的其他定义表达式与本条目讨论的符号之间的关系。

## Bibliography

* Boolos G. , Burgess, J., and Jeffrey, R., 2007, *Computability and Logic*, 5th edition, Cambridge: Cambridge University Press.
* Carnap, R., 1947, *Meaning and Necessity*, Chicago: University of Chicago Press.
* Church, A., 1976, “Comparison of Russell’s Resolution of the Semantical Antinomies with That of Tarski”, *Journal of Symbolic Logic*, 41: 747–60.
* Chwistek, L., 1924, “The Theory of Constructive Types”, *Annales de la Société Polonaise de Mathématique* (*Rocznik Polskiego Towarzystwa Matematycznego*), II: 9–48.
* Curry, H.B., 1937, “On the use of Dots as Brackets in Logical Expressions”, *Journal of Symbolic Logic*, 2: 26–28.
* Elkind, Landon D.C., and Zach, R., forthcoming, “The Genealogy of ∨”, *Review of Symbolic Logic*, 2022.
* Feys, R. and Fitch, F.B., 1969, *Dictionary of Symbols of Mathematical Logic*, Amsterdam: North Holland.
* Fraenkel, A.A., 1968, *Abstract Set Theory*, Amsterdam: North Holland.
* Gödel, K., 1944, “Russell’s Mathematical Logic”, in P.A. Schilpp, ed., *The Philosophy of Bertrand Russell*, LaSalle: Open Court, 125–153.
* Krivine, J-L., 1971, *Introduction to Axiomatic Set Theory*, Dordrecht: D. Reidel.
* Landini, G., 1998, *Russell’s Hidden Substitutional Theory*, New York and Oxford: Oxford University Press.
* Linsky, B., 1999, *Russell’s Metaphysical Logic*, Stanford: CSLI Publications.
* –––, 2009, “From Descriptive Functions to Sets of Ordered Pairs”, in *Reduction – Abstraction – Analysis*, A. Hieke and H. Leitgeb (eds.), Ontos: Munich, 259–272.
* –––, 2011, *The Evolution of Principia Mathematica: Bertrand Russell’s Manuscripts and Notes for the Second Edition*, Cambridge: Cambridge University Press.
* Quine, W.V.O., 1951, “Whitehead and the Rise of Modern Logic”, *The Philosophy of Alfred North Whitehead*, ed. P.A. Schilpp, 2nd edition, New York: Tudor Publishing, 127–163.
* Russell, B., 1905, “On Denoting”, *Mind* (N.S.), 14: 530–538.
* Suppes, P., 1960, *Axiomatic Set Theory*, Amsterdam: North Holland.
* Turing, A.M., 1942, “The Use of Dots as Brackets in Church’s System”, *Journal of Symbolic Logic*, 7:146–156.
* Whitehead, A.N. and B. Russell, [PM], *Principia Mathematica*, Cambridge: Cambridge University Press, 1910–13, 2nd edition, 1925–27.
* Whitehead, A.N. and B. Russell, 1962, *Principia Mathematica to ∗56*, Cambridge: Cambridge University Press.
* Zermelo, E., 1904, “Proof that every set can be well-ordered”, in *From Frege to Gödel*, J. van Heijenoort (ed.), Cambridge, Mass: Harvard University Press, 1967, 139–141.

## Academic Tools

> | ![sep man icon](https://plato.stanford.edu/symbols/sepman-icon.jpg) | [How to cite this entry](https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=pm-notation). |
> | --- | --- |
> | ![sep man icon](https://plato.stanford.edu/symbols/sepman-icon.jpg) | [Preview the PDF version of this entry](https://leibniz.stanford.edu/friends/preview/pm-notation/) at the [Friends of the SEP Society](https://leibniz.stanford.edu/friends/). |
> | ![inpho icon](https://plato.stanford.edu/symbols/inpho.png) | [Look up topics and thinkers related to this entry](https://www.inphoproject.org/entity?sep=pm-notation&redirect=True) at the Internet Philosophy Ontology Project (InPhO). |
> | ![phil papers icon](https://plato.stanford.edu/symbols/pp.gif) | [Enhanced bibliography for this entry](https://philpapers.org/sep/pm-notation/) at [PhilPapers](https://philpapers.org/), with links to its database. |

## Other Internet Resources

* [*Principia Mathematica*](http://quod.lib.umich.edu/cgi/t/text/text-idx?c=umhistmath;cc=umhistmath;view=toc;idno=AAT3201.0001.001), first edition (1910–13), reproduced in the University of Michigan Historical Math Collection.
* [Russell’s “On Denoting”](http://cscs.umich.edu/~crshalizi/Russell/denoting/), from the reprint in *Logic and Knowledge* (R. Marsh, ed., 1956) of the original article in *Mind* 1905, typed into HTML by Cosma Shalizi (Center for the Study of Complex Systems, U. Michigan)

## Related Entries

[Frege, Gottlob](https://plato.stanford.edu/entries/frege/) | [Frege, Gottlob: theorem and foundations for arithmetic](https://plato.stanford.edu/entries/frege-theorem/) | [generalized quantifiers](https://plato.stanford.edu/entries/generalized-quantifiers/) | [measurement: in science](https://plato.stanford.edu/entries/measurement-science/) | [*Principia Mathematica*](https://plato.stanford.edu/entries/principia-mathematica/) | [Russell, Bertrand](https://plato.stanford.edu/entries/russell/) | [schema](https://plato.stanford.edu/entries/schema/) | [set theory: alternative axiomatic theories](https://plato.stanford.edu/entries/settheory-alternative/) | [type theory](https://plato.stanford.edu/entries/type-theory/) | [Whitehead, Alfred North](https://plato.stanford.edu/entries/whitehead/)

### Acknowledgments

The author would like to thank: Gregory Landini, Dick Schmitt, Franz Fritsche, Rafal Urbaniak, Adam Trybus, Pawel Manczyk, Kenneth Blackwell, and Dirk Schlimm for corrections to this entry. Axel Boldt studied the most recent revisions and found numerous mathematical errors and among other insights pointed out the use of double dots for conjunction at [∗10·55] and the oddity involved in the PM notions of the domain and range of a function.

[Copyright © 2022](https://plato.stanford.edu/info.html#c) by  
[Bernard Linsky](https://www.ualberta.ca/arts/about/people-collection/bernard-linsky) <[*bernard.linsky@ualberta.ca*](mailto:bernard%2elinsky%40ualberta%2eca)>
