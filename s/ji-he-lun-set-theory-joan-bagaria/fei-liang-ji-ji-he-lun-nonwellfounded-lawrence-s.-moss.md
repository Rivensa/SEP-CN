# 非良基集合论 non-wellfounded (Lawrence S. Moss)

*首次发表于 2008 年 4 月 16 日，实质修订于 2018 年 4 月 24 日*

这篇文章讨论了两种循环性：对象循环性，其中一个对象在某种意义上被认为是自身的一部分；以及定义循环性，其中一个集合是以自身为基础进行定义的。这两种循环性的实例有时是有问题的，有时则不是。在这篇文章中，我们主要关注对象循环性，特别是在尝试用集合论对其进行建模时看起来有问题的实例。但我们也将讨论循环定义。

非良基集合这个术语指的是包含自身作为成员的集合，更一般地说，是一系列集合的一部分，其中每个术语都是前一个集合的元素。因此，它们以明显的方式展示了对象循环性。在集合论的历史上，对这样的集合的讨论非常古老，但是由于基础公理（FA），非良基集合被排除在策梅洛-弗兰克尔集合论（标准理论）之外。碰巧的是，这个公理 FA 有替代方案。本文特别关注其中之一，这是由 Marco Forti 和 Furio Honsell 在 1983 年的一篇论文中首次提出的公理。现在，按照 Peter Aczel 在 1988 年撰写的一本有影响力的书中的处理方式，将这个原理称为反基础公理（AFA）已经成为标准。

使用 AFA 的吸引力在于它提供了一套工具来对各种循环现象进行建模。这些工具与重要的循环定义相关联，正如我们将看到的那样。我们还将关注将数学和基础直觉置于更广泛的背景中，这个背景是从对余代数的研究中得出的。将范畴论的概念和结果纳入其中，余代数引导我们到核递归和余归纳等概念；从某种意义上说，这些是对更标准的递归和归纳概念的对偶。

这个条目的主题还与博弈论（普遍的哈尔萨尼类型空间）、语义学（特别是情境理论解释或其他允许“世界”成为其一部分的解释）、分形集和其他自相似集合、递归分析、范畴论以及集合论的哲学方面有关联。

***

## 1. 集合论中的循环现象

一般来说，很难确定何为循环定义。在本条目中，我们只关注各种数学定义。考虑方程式 x = ½x + 1。这是对数字 2 的循环定义吗？从某种意义上说，确实如此：一个数字是以自身为基础进行定义的。但这个方程式并没有问题，所以人们可能会想知道为什么它与 x = x + 1 或 x = x 这类方程式处于同一类别。在集合论的背景下，我们经常使用循环定义和集合、类的特征描述。例如，可以通过特征描述集合 HF，即继承有限集合的集合。

> (1) HF 是所有 x 的集合，使得 x 是 HF 的有限子集。

经过一些工作，可以证明(1)在标准集合论 ZFC 中定义了一个唯一的集合。然而，(1)更像是一种表征而不是教科书上的定义。换句话说，如果将(1)作为一种假定的定义呈现给某人，那么理解它的第一步将是通过提供一个不同的集合定义 D 来“纠正”循环性，然后检查每个满足 D 的集合是否满足定义 HF 的属性，反之亦然。

想象循环对象比想象循环定义更容易。即便如此，在阅读本条目时，将循环定义牢记于心将会很有用。最显著的循环对象形式是一个将自身作为元素的集合；更糟糕的是，一个集合 x 满足 x = {x}。对于那些有标准集合论背景的人来说，这些集合在公理中被排除在外，而且不清楚为什么要改变公理以允许它们。如果一个人确实采取了改变一个成熟理论公理的激进步骤，那么会发生什么变化呢？本条目是对这个问题及相关问题的详细讨论。

### 1.1 流

本条目中的许多思想可以用流来说明。一串数字是一个有序对，其第一个坐标是一个数字，第二个坐标又是一串数字。第一个坐标被称为头部，第二个坐标被称为尾部。给定流的尾部可能与它不同，但也可能是同一个流。例如，考虑流 s，其头部为 0，尾部为 s 本身。因此，s 的尾部的尾部就是 s 本身。我们有 s = ⟨0, s⟩，s = ⟨0, ⟨0, s⟩⟩，等等。这个流 s 展示了对象的循环性。将其定义“展开”为：

> (0,0,…,0,…)

将未解开的形式理解为无限序列是很自然的；通常情况下，无限序列被视为定义域为自然数集 N 的函数。因此，我们可以将未解开的形式视为取值为 0 的常函数。我们希望在本条目中以一般方式探讨上述描述的流 s 是否应该被视为这个函数的问题。请注意，由于我们将 s 定义为有序对，根据普通数学中对有序对的构造方式，s 本身不会是常数序列 0。

定义流的一种方法是使用它们的方程系统。例如，以下是这样一个系统：

| (2) | *x* ≈ ⟨0,*y* ⟩ |
| --- | ------------ |
|     | *y* ≈ ⟨1,*z* ⟩ |
|     | *z* ≈ ⟨2,*x* ⟩ |

我们应该对这里的 ≈ 符号进行评论。我们关注的是在集合论中对各种普通数学对象进行建模，而我们想要建模的一种对象是方程系统。这是一件不寻常的事情。为了预见即将发生的事情，我们使用 ≈ 符号表示我们想要解决的方程。因此，在我们上面讨论的 x = ½x + 1 中，我们更愿意写成 x ≈ ½x + 1。关键是，这里的‘x’是一个符号，但无论我们认为符号是什么，几乎从不会出现符号 x 与表达式‘½x + 1’或与之相关的任何内容完全相同的情况。对于方程或方程组的解，我们将使用“dagger”来表示解。因此，对于这个方程，x† = 2；2 满足方程的原因是 2 = ½(2)+ 1（这里我们使用=而不是 ≈）。

返回到方程（2），我们将其定义为流 x†，y†和 z†。这些满足以下方程：

|   | x† = ⟨0，y†⟩     |
| - | --------------- |
|   | y† = ⟨1，z†⟩     |
|   | *z*† = ⟨2,*x*†⟩ |

这些流体然后具有解开的形式。例如，y†的解开形式是（1,2,0,1,2,0，…）。

有一个自然的“合并”两个流的操作。也称为“合并”，它的定义是

| (3) | zip(*s*,*t*) = ⟨ head(s), zip(t, tail(s)) ⟩ |
| --- | ------------------------------------------- |

因此，要将两个流 s 和 t 进行压缩，首先从 s 的头部开始，然后再次开始相同的压缩过程，但这次是先用 t，然后用 s 的尾部。例如，如果 x†、y†和 z†是方程（2）中系统的解，那么我们可能希望考虑 zip(x†, y†)。展开形式为

> (0,1,1,2,2,0,0,1,1,2,2,0,...)。

但请注意，我们对 zip 的定义并不像人们期望的那样通过递归来工作；首先，流中没有“基本情况”。

我们甚至可以询问关于用 zip 表示的方程组的解。很容易看出，像 x = zip(x, x)这样的方程只有常数流才能满足。像

> *x* = zip(head(*x*) + 1, *x*)

没有任何解。但是如果我们做得对，我们可以定义非常有趣的流。例如，考虑

| (4) | *x* | ≈ | ⟨1，zip（x，y）⟩ |
| --- | --- | - | ------------ |
|     | *y* | ≈ | ⟨0，zip（y，x）⟩ |

该系统有唯一解。x†的展开形式开始为

> (1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,0,…)

y†的开始

> (0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,…).

这些中的第一个是一个著名的序列，Thue-Morse 序列 t（实际上 x† = tail(t)）\[1]。

#### 1.1.1 将流减少为函数

我们一直强调流的不同之处，即我们最初所说的流和它们在自然数上的展开形式作为函数之间的区别。在这一点上，我们想更仔细地研究这个问题。

在我们转向细节之前，让我们考虑一下将序列解释为自然数上的函数的并行问题。任何教授关于某种（无限）序列的人，比如整数序列或实数序列，可能在某个时候需要解释序列的实际含义。当然，在初级课程中通常不会经常这样做：通常会给出示例而不是正式定义，或者通过某种方式使用它们来说明序列的用途。无论如何，在通常的集合论建模数学中，实数序列将被视为从自然数集到实数集的函数。因此，我们将一种对象，序列，简化为另一种对象，函数。当然，然后将函数简化为有序对的集合，有序对简化为某种形式的集合，自然数简化为另一种形式的集合，实数以其自己的方式简化。关于这种简化，我们应该始终问自己它是否是必要的或愚蠢的，以及对于那些首次使用数学对象的人来说是否有用。在我们回到序列时，这一切都值得记住。

让 N∞ 表示自然数流的集合，N\*\*N 表示从 N 到 N 的函数的集合。简化使用了两个函数

| φ | : | *N* ∞     | → | *N\*\*N* |
| - | - | -------- | - | -------- |
| ψ | : | *N\*\*N* | → | *N* ∞     |

定义如下：对于 φ，我们首先将一个流 s 映射到一个函数 f\*\*s：N → N∞。这次我们使用递归：

| *f\*\*s*(0)     | = | *s*                 |
| --------------- | - | ------------------- |
| *f\*\*s*(*n*+1) | = | tail(*f\*\*s*(*n*)) |

然后从 f 我们得到一个函数 φ(s) : N → N，通过 g(n) = head(f\*\*s(n))。这定义了 φ，我们之前所说的解开的精确定义。在另一个方向上，我们需要无限方程组。给定一个函数 f : N → N，考虑

| (5) | _x_0     | = | ⟨*f*(0),_x_1⟩         |
| --- | -------- | - | --------------------- |
|     | _x_1     | = | ⟨*f*(1),_x_2⟩         |
|     |          | … |                       |
|     | *x\*\*n* | = | ⟨ *f*(*n*),*x\*\*n*+1⟩ |
|     |          | … |                       |

然后这个系统有一个解，我们取 ψ(f) = x0†。然后可以证明，一个方向上的组合 ψ ⋅ φ 是 N∞ 上的恒等映射，而另一个方向上的组合 φ ⋅ ψ 是 N\*\*N 上的恒等映射。简单来说，我们可以从流到数字函数之间进行转换，也可以反过来。

在这一点上，我们可以对简化进行提问。首先，我们会思考关于实体的本体论问题：

> 设 A 是一组抽象对象（比如从自然数到自然数的函数），并假设人们相信 A 中的对象存在。设 B 是另一组抽象对象。假设 A 和 B 之间有一种自然对应关系，并且关于 B 中的对象所说的一切都可以用不同的语言说出它们在 A 中的对应物。那么，人们是否应该相信 B 中的对象也存在？

对于 N 上的流和函数，询问这个问题与询问任何其他类型的数学对象的归约没有任何区别。对此的讨论将引导我们进入超出本条目目标的数学哲学问题。然而，关于这个问题还有两点需要说明。

首先，集合论中对于对偶的标准建模\[2]会让我们相信，从本节开始，我们一直在谈论不存在的事物：根据我们的字面定义，根本就没有任何数字流！我们在 2.2.1 节中详细讨论了这一点，当我们谈论集合论的基础公理时。关键是，这个公理禁止了对象层面的循环，这样就排除了我们所拥有的确切形式的流。因此，如果我们想要对我们引入的直观概念进行建模，我们需要说类似于：“通过流，我们指的是对数字的函数。我们采用特殊的符号来使其看起来像是某种类型的对偶，但实质上它们只是对数字的函数。”

继续讨论将流归约为函数的问题，我们可以问是否使用流与使用函数有任何概念上的区别。当然，它们代表了不同的观点，因此同时拥有它们应该是有用的。为了看到区别，让我们回到流合并的问题。用函数 f，g：N → N 来完成，合并后的版本将会是

| zip(*f*,*g*)(*n*) | = | { | <p> <em> f </em>(<em> n </em>/2)<br> <em> g </em>((<em> n </em> −1)/2))</p> | <p> 如果 n 是偶数 <br> 如果 n 是奇数 </p> |
| ----------------- | - | - | ---------------------------------------------------------------- | --------------------------- |

使用这种方法将方程（4）通过递归转化为两个序列的定义会更加困难。\[3] 结果是，当我们使用一种表示方法而不是另一种表示方法时，我们可以开始看到某种差异。这将引出我们关于将流降低到函数的第二个观点：在这种降低的表面下可能隐藏着值得探索的概念上的差异。

在这一点上，我们已经完成了对流的讨论。当然，我们将在后面的章节中重新讨论它们，以阐明各种观点。我们还广泛预示了本条目的主要观点：

* 通过改变集合论的通常公理，可以更接近人们对循环定义的流和其他对象的直觉方式来建模。特别是，在相对一致的集合论中可以处理对象级别的循环性，并且可能有理由这样做。
* 在改变的理论中，我们还发现了关于以自身为基础定义的集合的不同结果。我们已经从（1）中看到了这样一个集合，HF。当改变集合论时，循环定义的状态也会发生变化，这导致了对几个问题的更广泛的研究。
* 还有一个更深层次的概念问题，远远超出了与集合论相关的自上而下与自下而上处理各种现象的问题。

### 1.2 无限树

我们希望从流转移到一个更复杂的例子，即无限树。我们提出的一些观点与我们对流所见的情况密切相关，而一些观点则提出了新的问题。

这里有一类我们称之为树的对象：\[4]

1. 只有变量 x 和 y 本身就是树。
2. 如果 t 是一棵树，那么在 t 作为唯一子树的情况下，添加一个标记为•的单个节点作为新的根节点会得到一棵树。
3. 如果 s 和 t 是树，则将一个标记为\*的单个节点作为新的根节点添加到 s 作为左子树和 t 作为右子树，再次得到一棵树。
4. 树是通过任意次数的操作（包括无限次操作）获得的。

树可以通过树系统（方程组）来指定。以下是一个这样的系统：

> (6) s ≈

|     |   |    |    |     |
| --- | - | -- | -- | --- |
|     |   | \* |    |     |
|     | / |    | \\ |     |
| *t* |   |    |    | *u* |

|     |   |              |
| --- | - | ------------ |
| *t* | ≈ | <p>•<br> </p> |

> *u* ≈

|     |   |    |    |     |
| --- | - | -- | -- | --- |
|     |   | \* |    |     |
|     | / |    | \\ |     |
| *x* |   |    |    | *y* |

再次，我们在需要解决的变量中使用 ≈ 符号，并在解决方案中用一个 dagger 上标表示变量。在这种情况下，这个系统的唯一解可能被描绘为

> *s*† =

|   |   |   |   |     |    |    |    |     |    |    |    |     |
| - | - | - | - | --- | -- | -- | -- | --- | -- | -- | -- | --- |
|   |   |   |   |     |    |    |    | \*  |    |    |    |     |
|   |   |   |   |     |    |    | /  |     | \\ |    |    |     |
|   |   |   |   |     |    | •  |    |     |    | \* |    |     |
|   |   |   |   |     | /  |    |    |     | /  |    | \\ |     |
|   |   |   |   | \*  |    |    |    | *x* |    |    |    | *y* |
|   |   |   | / |     | \\ |    |    |     |    |    |    |     |
|   |   | • |   |     |    | \* |    |     |    |    |    |     |
|   | / |   |   |     | /  |    | \\ |     |    |    |    |     |
| … |   |   |   | *x* |    |    |    | *y* |    |    |    |     |

|      |   |              |
| ---- | - | ------------ |
| *t*† | = | <p>•<br> </p> |

> *u*† =

|     |   |    |    |     |
| --- | - | -- | -- | --- |
|     |   | \* |    |     |
|     | / |    | \\ |     |
| *x* |   |    |    | *y* |

用对和三元组的术语重新定义我们的树将是有用的：

1. 符号 x 和 y 本身就是树。
2. 如果 t 是一棵树，则 ⟨•, t⟩ 是一棵树。
3. 如果 s 和 t 是树，则 ⟨\*, s, t⟩ 是一棵树。
4. 树可以是“无限深”。

然后我们上面的系统是

| *s* | ≈ | ⟨\*,*t*,*u* ⟩ |
| --- | - | ------------ |
| *t* | ≈ | ⟨•,*s* ⟩      |
| *u* | ≈ | ⟨\*,*x*,*y* ⟩ |

所以现在我们有了更像流的东西。但是对于流，我们有一个展开的形式，所以我们可能会想知道树的展开形式是什么样的。在某种程度上，它将是我们已经看到的图片。特别是，可以将树按照我们定义的方式进行构造，并给出如何构造图片的描述。（当然，完整的构造将需要很长时间，但我们在流上的工作也是如此。）相反，给定一张图片，可以为它设置一个树系统，其中“树系统”是一个像方程（6）中的方程组一样的系统。（一般来说，树系统可能是无限的，但如果在图片中找到了规则的结构，那么系统可能是有限的。）

另一方面，尽管已经进行了大量的工作并继续进行工作来恢复图片的地位，但图片并不完全被视为标准的数学对象。对于树的工作，需要更复杂的定义。我们不打算介绍其中任何内容。

更多的“作弊”。让 Tr 表示我们一直在讨论的树的集合。那么我们用 Tr 的定义将会是：

> (7) *Tr* = {*x*, *y*} ∪ ({•} × *Tr*) ∪ ({\*} × *Tr* × *Tr*).

现在再次，集合论中的标准建模给我们带来了一个问题：在 ZF 集合论中可以证明 Tr 根本没有解。这与我们的图像和直觉相矛盾。标准的解决方法是将(7)中的等号=改为其他符号。对于大多数数学工作来说，这是完全可以的，但这是我们在本条目中探讨的一种方法。

### 1.3 超集合

让我们从流和树转向集合。在介绍刚才所见的一些类比之前，看一下集合的图片。为了使讨论具体化，考虑集合：

> *x* = {∅, \{{∅}, ∅\}}

让我们称这个集合为 x。我们想要画出这个集合的图像，所以我们从一个我们认为是 x 本身的点开始。由于 x 有两个元素，我们添加两个子节点：

|     |                                                                                              | *x* |                                                                                              |     |
| --- | -------------------------------------------------------------------------------------------- | --- | -------------------------------------------------------------------------------------------- | --- |
|     | ![southwest arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/swarrow.jpg) |     | ![southeast arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/searrow.jpg) |     |
| *y* |                                                                                              |     |                                                                                              | *z* |

同样地，我们代表成员画出箭头。我们将 y 设为 ∅，将 z 设为\{{∅}， ∅}。我们不给 y 添加任何子节点，因为它是空的。但是我们想要给 z 添加两个子节点，一个是 w = {∅}，一个是 ∅。所以我们有

|     |                                                                                              | *x* |                                                                                              |     |
| --- | -------------------------------------------------------------------------------------------- | --- | -------------------------------------------------------------------------------------------- | --- |
|     | ![southwest arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/swarrow.jpg) |     | ![southeast arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/searrow.jpg) |     |
| *y* |                                                                                              | ←   |                                                                                              | *z* |
|     |                                                                                              |     |                                                                                              | ↓   |
|     |                                                                                              |     |                                                                                              | *w* |

我们通过从 w 指向 y 的箭头来得出结论，因为 ∅ ∈ {∅}。

|     |                                                                                              | *x*                                                                                          |                                                                                              |     |
| --- | -------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------- | --- |
|     | ![southwest arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/swarrow.jpg) |                                                                                              | ![southeast arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/searrow.jpg) |     |
| *y* |                                                                                              | ←                                                                                            |                                                                                              | *z* |
|     |                                                                                              | ![northwest arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/nwarrow.jpg) |                                                                                              | ↓   |
|     |                                                                                              |                                                                                              |                                                                                              | *w* |

现在我们想要忘记节点的身份。我们可以交换我们用于数字的四个集合（只是提到一种方式），或者完全回避这个问题。我们将得到下面的其中一张图片：

|   |                                                                                              |                                                                                              |                                                                                              |   |
| - | -------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------- | - |
|   |                                                                                              | 1                                                                                            |                                                                                              |   |
|   | ![southwest arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/swarrow.jpg) |                                                                                              | ![southeast arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/searrow.jpg) |   |
| 2 |                                                                                              | ←                                                                                            |                                                                                              | 3 |
|   |                                                                                              | ![northwest arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/nwarrow.jpg) |                                                                                              | ↓ |
|   |                                                                                              |                                                                                              |                                                                                              | 4 |

|                                                                                |                                                                                              |                                                                                              |                                                                                              |                                                                                |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
|                                                                                |                                                                                              | ![circ](https://plato.stanford.edu/entries/nonwellfounded-set-theory/circ.jpg)               |                                                                                              |                                                                                |
|                                                                                | ![southwest arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/swarrow.jpg) |                                                                                              | ![southeast arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/searrow.jpg) |                                                                                |
| ![circ](https://plato.stanford.edu/entries/nonwellfounded-set-theory/circ.jpg) |                                                                                              | ←                                                                                            |                                                                                              | ![circ](https://plato.stanford.edu/entries/nonwellfounded-set-theory/circ.jpg) |
|                                                                                |                                                                                              | ![northwest arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/nwarrow.jpg) |                                                                                              | ↓                                                                              |
|                                                                                |                                                                                              |                                                                                              |                                                                                              | ![circ](https://plato.stanford.edu/entries/nonwellfounded-set-theory/circ.jpg) |

顺便提一下，在构建这个图时，我们允许自己在两次到达 ∅ 时共享节点 y。可以通过使用不同的节点来避免这样做。最终结果将是一棵树：

|                                                                                |                                                                                              | ![circ](https://plato.stanford.edu/entries/nonwellfounded-set-theory/circ.jpg) |                                                                                              |                                                                                |                                                                                              |                                                                                |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
|                                                                                | ![southwest arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/swarrow.jpg) |                                                                                | ![southeast arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/searrow.jpg) |                                                                                |                                                                                              |                                                                                |
| ![circ](https://plato.stanford.edu/entries/nonwellfounded-set-theory/circ.jpg) |                                                                                              |                                                                                |                                                                                              | ![circ](https://plato.stanford.edu/entries/nonwellfounded-set-theory/circ.jpg) |                                                                                              |                                                                                |
|                                                                                |                                                                                              |                                                                                | ![southwest arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/swarrow.jpg) |                                                                                | ![southeast arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/searrow.jpg) |                                                                                |
|                                                                                |                                                                                              | ![circ](https://plato.stanford.edu/entries/nonwellfounded-set-theory/circ.jpg) |                                                                                              |                                                                                |                                                                                              | ![circ](https://plato.stanford.edu/entries/nonwellfounded-set-theory/circ.jpg) |
|                                                                                |                                                                                              | ↓                                                                              |                                                                                              |                                                                                |                                                                                              |                                                                                |
|                                                                                |                                                                                              | ![circ](https://plato.stanford.edu/entries/nonwellfounded-set-theory/circ.jpg) |                                                                                              |                                                                                |                                                                                              |                                                                                |

图是一个二元组（G,→），其中→是 G 上的关系（一组有序对的集合）。我们的想法是将图看作集合的符号表示，就像方程组是流的符号表示一样。这可以通过装饰的概念来解释：图 G 的装饰 d 是一个定义域为 G 且具有以下属性的函数

> *d*(*g*) = {*d*(*h*) : *g* → *h*}.

例如，让我们为树状图中的节点引入名称，然后找到它的装饰：

|   |                                                                                              | 1 |                                                                                              |   |                                                                                              |   |
| - | -------------------------------------------------------------------------------------------- | - | -------------------------------------------------------------------------------------------- | - | -------------------------------------------------------------------------------------------- | - |
|   | ![southwest arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/swarrow.jpg) |   | ![southeast arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/searrow.jpg) |   |                                                                                              |   |
| 2 |                                                                                              |   |                                                                                              | 3 |                                                                                              |   |
|   |                                                                                              |   | ![southwest arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/swarrow.jpg) |   | ![southeast arrow](https://plato.stanford.edu/entries/nonwellfounded-set-theory/searrow.jpg) |   |
|   |                                                                                              | 4 |                                                                                              |   |                                                                                              | 5 |
|   |                                                                                              | ↓ |                                                                                              |   |                                                                                              |   |
|   |                                                                                              | 6 |                                                                                              |   |                                                                                              |   |

由于 6 没有子节点，d(6)必须是 ∅。同样，d(5)和 d(2)也是 ∅。d(4) = {d(6)} = {∅}。d(3) = {d(4), d(5)} = { {∅}, ∅}。而 d(1) = {d(2), d(3)} = {∅, { {∅}, ∅} }。请注意，这就是我们开始的集合 x。这不是偶然的，鼓励你思考为什么会这样。相关的一点是：对于像方程（8）中的图形，我们使用涉及的集合作为图形的节点，你应该检查恒等函数是否是一个装饰。

然而，当涉及到类似于循环图的例子时，事情变得更有趣

> <img src="https://plato.stanford.edu/entries/nonwellfounded-set-theory/loop.jpg" alt="loop" data-size="original">
>
> * xt: x\*

设 d 是这个图的一个装饰。那么我们会有 d(x) = {d(x)}。因此，将 Ω 表示为 d(x)，我们有 Ω = {Ω}。这个集合 Ω 是对象循环性的最显著例子：一个是自身成员的集合。（实际上，Ω 是它唯一的成员。）

最后，我们想考虑一个回溯到第 1.1 节中流系统（2）的例子。

> <img src="https://plato.stanford.edu/entries/nonwellfounded-set-theory/graph1.jpg" alt="graph1" data-size="original">

让我们试着理解这个图的装饰 d 将是什么。为了理解下面的讨论，您应该记住从集合论中，前几个自然数的标准表示是通过

>

并且有序对 ⟨x, y⟩ 的标准定义是 \{{x},{x, y\}}。

由于 x0 没有子集，d(x0) 必须是 ∅。然后可以得出 d(y0) = {d(x0)} = {∅} = 1。现在

> d(z0) = {d(x0), d(y0) } = {0,1} = 2。

此外，d(z1) = {2}。现在可以得出

| d(x1) = {0}， | d(y1) = {1}， | *d*(_z_1) = {2}. |
| ------------ | ------------ | ---------------- |

然后

| *d*(_x_2) | = | {*d*(_y_3),*d*(_x_1)} | = | \{{0,*d*(_y_2)}, {0} } | = | ⟨0,*d*(_y_2)⟩ |
| --------- | - | --------------------- | - | ---------------------- | - | ------------- |
| *d*(_y_2) | = | {*d*(_z_3),*d*(_y_1)} | = | \{{1,*d*(_z_2)}, {1} } | = | ⟨1,*d*(_z_2)⟩ |
| *d*(_z_2) | = | {*d*(_x_3),*d*(_z_1)} | = | \{{2,*d*(_x_2)}, {2} } | = | ⟨2,*d*(_x_2)⟩ |

结果是我们可以回到方程（2）中的原始流系统，然后通过放置我们的大图并装饰它来解决它。解决方案将是

| *x*† =*d*(_x_2), | *y*† =*d*(_y_2), | *z*† =*d*(_z_2). |
| ---------------- | ---------------- | ---------------- |

一个超集或非良基集合是通过装饰任意图形获得的集合。

另一种思考超集的方式是通过集合方程系统来思考，就像我们对流和树所做的那样。通过这样的系统，我们指的是一个集合 X，我们将其视为变量（任何集合都可以），然后有一个从 X 到其幂集 ℘X 的函数 e。也就是说，每个变量上的 e 的值又是一组变量。集合系统和相关概念与图形的概念对应如下：

| 图形（G,→）    | 集合方程系统 (X, e) |
| ---------- | ------------- |
| G 的节点      | 变量集合 X        |
| 节点上的关系 →   | 函数 e : X → ℘X |
| G 中 x 的子节点 | 集合 e(x) ∈ ℘X  |
| 图的装饰       | 系统的解决方案       |

每个图形对应于一个集合方程系统，反之亦然。例如，对应于（9）中的图片，我们会取

*X* = {_x_0, _y_0, _z_0, _x_1, _y_1, _z_1, _x_2, _y_2, _z_2, _x_3, _y_3, _z_3}

| *e*(_x_0) = ∅           | *e*(_x_1) = {_x_0} | *e*(_x_2) = {_x_1,_y_3} | *e*(_x_3) = {_z_0,_x_2} |
| ----------------------- | ------------------ | ----------------------- | ----------------------- |
| *e*(_y_0) = {_x_0}      | *e*(_y_1) = {_y_0} | *e*(_y_2) = {_y_1,_z_3} | *e*(_y_3) = {_x_0,_y_2} |
| *e*(_z_0) = {_x_0,_y_0} | *e*(_z_1) = {_z_0} | *e*(_z_2) = {_z_1,_x_3} | *e*(_z_3) = {_y_0,_z_2} |

所以从图像到函数的方法是，每个集合 e(v)都是 v 的子集。根据我们之前看到的符号表示方式，我们更倾向于以省略 e 的方式来书写这个系统：

| _x_0 ≈ ∅           | _x_1 ≈ {_x_0} | _x_2 ≈ {_x_1,_y_3} | _x_3 ≈ {_z_0,_x_2} |
| ------------------ | ------------- | ------------------ | ------------------ |
| _y_0 ≈ {_x_0}      | _y_1 ≈ {_y_0} | _y_2 ≈ {_y_1,_z_3} | _y_3 ≈ {_x_0,_y_2} |
| _z_0 ≈ {_x_0,_y_0} | _z_1 ≈ {_z_0} | _z_2 ≈ {_z_1,_x_3} | _z_3 ≈ {_y_0,_z_2} |

非良基集合的研究提出将每个图形视为唯一集合的图像。为了使这个工作起效，集合论需要进行某种改变。原因是像 Ω = {Ω}这样的集合在最常用的集合论 ZFC 中不存在。这是由于基础公理（FA）的原因：我们将在下面的第 2 节进一步讨论这个问题。目前，FA 意味着唯一带有装饰的图形是那些没有无限点序列跟随箭头的图形。我们所做的集合论改变只是用一个叫做 AFA 的不同公理来替换这个 FA 公理。AFA 的内容是每个图形都有唯一的装饰（或者说每个集合方程系统都有唯一的解）。

同时，超集的减少到普通集合。这意味着可以将所有关于超集的讨论仅仅看作是缩写。这种减少相当复杂，我们将适时地介绍它。

采用 AFA 不仅有助于循环定义的集合，还有助于流和树。正如我们所提到的，如果使用 FA，根据我们的定义，没有流或树存在。也就是说，根据 FA，N∞ 实际上是空集，Tr 也是空集。但是使用 AFA，这些集合是非空的。此外，可以证明在 AFA 下，N∞ 和 Tr 具有我们希望它们具有的属性。（例如，可以证明 N∞ 与我们讨论过的函数空间 N\*\*N 相对应。）最后，推导出的理论为研究循环定义对象的集合提供了有用的工具，例如流和树。关键是这个 AFA 公理给了我们所有这些，甚至更多。

#### 1.3.1 术语和历史

AFA 公理首次由 Marco Forti 和 Furio Honsell 在 1983 年研究。他们的论文（Forti 和 Honsell 1983）研究了一些与基础公理 FA 相矛盾的公理，延续了集合论中处理 FA 替代方案的更古老的研究线。他们称之为 X1 的公理与现在被称为 AFA 的公理等价。

Peter Aczel 的书（1988 年）涉及了许多与 FA 相矛盾的公理，但它最关注的是 AFA。它还证明了该主题中的许多重要结果，包括本条目中提到的结果。Aczel 自己进入这个领域是因为他一直在研究与通信系统演算（CCS）有关的语义建模领域。他发现提出一个集合论语义是很自然的，但最明显的建模似乎在基础公理方面遇到了问题。为了使该学科应用起来，建议改变集合论公理总是一个大胆的举措。通常这是一个鲁莽的举动。大多数人都抵制这个想法：当提议可以用更标准的形式表达时（使用 AFA 的工作可以这样做），人们会想知道为什么要篡改一个标准理论；当无法以标准方式表达时，接受程度甚至更糟。

Aczel 的工作对两个研究领域产生了影响。他在 1985 年访问了斯坦福大学，当时 Jon Barwise 是语言和信息研究中心的主任（本文作者当时是那里的博士后）。Barwise 认识到这项工作的价值，部分原因是他在自己关于情境语义的工作中也遇到了基础问题，部分原因是他在这项工作中看到了一种吸引人的集合概念，这与他和几乎所有在主流数理逻辑传统中成长的人所接受的迭代概念相悖\[5]。他认为非良基集合应该被称为反映概念变化的名称，并建议将它们称为超集，与非标准分析中的超实数相对应。这个术语在很大程度上并没有被广泛接受，但也并非完全过时。在本条目中，我们将两个术语互换使用。

或许我们在本条目中研究的工具的第一个严肃应用来自这个时期。这是 Barwise 和 Etchemendy 的书《说谎者》（Barwise and Etchemendy 1987）。它的提议是真理理论的贡献。由于我们主要不关心超集的这些应用，我们抵制了进一步讨论这些问题的诱惑。

Aczel 的书对在理论计算机科学中研究语义问题的人们也产生了立即的影响。这并不是因为它提出了关于集合论的问题，而是因为它展示了使用范畴论概念的价值。书中的主要用途是将某些概念组织成一个优雅的主题。但很快就明显地看出，这个余代数的概念可以单独研究，书中的主题比纯粹的集合论有更广泛的应用领域。

这个条目反映了所有这些来源的影响。确保我们将看到使用 AFA 获得的集合论的主要结果。此外，我们还介绍了足够的理论，以便需要阅读使用该理论的论文的人能够开始这样做。我们还强调了该主题的概念基础，并将其与更标准的基础工作进行了比较。这在该主题的技术论文中几乎从未被做过，但对哲学的几个领域的人们应该是有兴趣的。最后，我们的工作融入了在 Aczel 1988 出版后几年来来自共代数研究社区的许多思想和结果。

我们在本节中总结了以下两个补充文件的链接：

> [通用的 Harsanyi 类型空间](https://plato.stanford.edu/entries/nonwellfounded-set-theory/harsanyi-type-spaces.html) [实数的自相似集合](https://plato.stanford.edu/entries/nonwellfounded-set-theory/self-similar-sets.html)

这些包含了我们将在本条目末尾重新讨论的两个问题的入门点（同样，在补充文件中）。分开讨论的原因是所讨论的问题一方面涉及博弈论和测度论，另一方面涉及分形和度量空间。也就是说，这些讨论并非完全集合论的。此外，我们所有补充内容的数学先决条件都比本条目的主体更高。可以省略这些内容而不会丢失主线。然而，我们强调本条目中呈现的整体理论确实将所有这些循环性的实例“放在同一个屋檐下”。

## 2. 基础和反基础公理

我们故事中的集合论部分与两个公理相关，即基础公理和反基础公理。我们在这里介绍它们，并讨论一些相关的集合概念。

### 2.1 集合论背景

我们首先回顾一些集合论的基本事实。可以在任何关于这个主题的教科书中找到更多内容，还有关于集合论的条目，特别是其附加文档基本集合论。

幂集。对于任意集合 s，s 的幂集是 s 的所有子集的集合。我们将这个集合写作 ℘(s)或者简写为 ℘s。

配对。两个集合 a 和 b 的 Kuratowski 有序对 ⟨a,b⟩ 定义为\{{a}, {a,b\}}。\[6] 集合论的标准表述通过这个配对操作来定义和研究关系、函数等。所有关于这些概念的数学事实都可以在集合论中得到证明。

自然数。我们也可以通过以下方式定义自然数：0 = ∅, 1 = {∅}，等等。同样，关于数和在其上的函数的所有事实都可以在集合论中得到证明。实际上，几乎所有数学事实都可以在集合论中以形式化的方式陈述并得到证明。

并集和传递闭包。对于任意集合 a，∪a 是 a 的元素的元素的集合。如果一个集合的每个元素也是它的子集，则该集合是传递的。a 的传递闭包是

> *a* ∪ ∪ *a* ∪ ∪∪ *a* ….

这个集合被表示为 tc(a)。它是包含 a 作为子集的最小传递集合。

> 定理【康托尔】。对于所有集合 s 和所有函数 f：s → ℘s，f 不是满射。实际上，{x ∈ s : x ∉ f(x)}不在图像集 f\[s]中。（这里，图像集 f\[s] = {f(x) : x ∈ s}。）

> 证明。设 c = {x ∈ s: x ∉ f(x)}。假设反证法，假设 c ∈ f\[s]。固定一个 a ∈ s，使得 c = f(a)。那么 a ∈ c 当且仅当 a ∉ f(a)当且仅当 a ∉ c。

> 推论。对于所有集合 s，℘s 不是 s 的子集。

> 证明。如果 ℘s ⊆ s，我们构造一个从 s 到 ℘s 的函数 f：如果 a ∈ s，则让 ff(f) = a，否则让 ff(f) = ∅。因此，我们不能有 ℘s ⊆ s，否则我们将违反康托尔的定理。

> 推论\[罗素悖论]。不存在一个集合 R，使得每个集合都属于 R。

> 证明。这样一个集合将对所有集合 s 都有 ℘s ⊆ R，特别地，℘R ⊆ R，与我们上一个结果相矛盾。

鉴于其内容，我们将最后的结果称为罗素悖论。我们的陈述和证明都不是最标准的。

良序集合和序数。我们在几个地方需要序数的概念。

一个良序集合是一个二元组 W = (W, <)，其中<是集合 W 上的一个严格线性序关系，并且具有这样的性质：W 的每个非空子集都有一个最小元素。例如，(N, <)是一个良序，其中<由...给出。

> 0 < 2 < 4 < … 1 < 3 < 5 < …

使用替代性公理可以证明，每个良序集 W 都有一个唯一的装饰 d。序数（或序数）是形式为 d（w）的集合，其中 w ∈ W，对于某个良序集（W，<）。

通常使用希腊字母如 α 和 β 表示序数，如果 α ∈ β，则写作 α < β。关于序数有一些标准事实，包括以下事实：

1. 如果 α 是一个序数，那么 α∪{α}也是一个序数。
2. 自然数的标准建模将它们表示为序数，自然数集 ω 也是一个序数。
3. 序数的集合不是一个集合。
4. 除了不是一个集合之外，具有<的序数具有所有良序集的属性。

如果 α = β ∪ {β}对于某个（其他）序数 β，则序数 α 是一个后继序数。既不是 0 也不是后继序数的序数称为极限序数。最小的极限序数是 ω；对于我们上面看到的良序，它是 d（1），0 < 2 < 4 < … 1 < 3 < 5 < …

累积层次。存在一个将序数 α 映射到集合 Vα 的唯一操作，使得

| _V_0   | = | ∅                  |
| ------ | - | ------------------ |
| _V_α+1 | = | ℘_V_α              |
| _V_λ   | = | ∪β<λ Vβ，其中 λ 是一个极限序数 |

ZFC 公理。我们不会在这里陈述它们，但请参阅集合论条目。

类。集合论的公理不仅仅是关于集合的，更多地是关于集合的宇宙。理论的一个直观原则是，数学对象的任意集合“应该是”集合。由于悖论，这个直观原则在标准集合论中没有直接形式化。从某种意义上说，已有的公理旨在提供足够的集合来构成一个数学宇宙，同时又不会有太多集合以至于冒着不一致的风险。但是，在这种联系中，自然要考虑一些明显不是集合的对象集合。这些被称为真类。术语“类”非正式地指的是数学对象的集合。在集合论中，类通常不是一流对象。（当然，在最标准的集合论 ZFC 中不是。然而，关于替代性公理集合论的 SEP 条目确实提到了一些将类作为一流对象处理的理论。）相反，关于类的陈述被视为对一些其他（更复杂且通常不太直观）关于集合的陈述的释义。这可能不是讨论形式化细节的好地方；一个有用的参考资料是 Azriel Levy（1979）的第 1 章。

就我们的目的而言，类可以被看作是集合宇宙的可定义子集合。例如，如果 a 是任意集合，则不包含 a 作为元素的所有集合的类是{x：a∉x}。在指定类时，可以使用具有成员关系符号和逻辑中的其余语法的一阶语言，并且还可以使用特定的集合作为参数，就像我们刚刚做的那样。

所有集合的类 V 是{x：x = x}。这里的可定义性是在一阶逻辑中，只有一个成员关系符号 ∈，量词范围是集合（而不是类）。另一个有趣的类是 WF，即所有良基集合的类。这与 ∪α Vα 相同，即属于某个序数 α 的 Vα 中的集合。

如果 C 是一个类，我们通过以下方式定义 C 的幂集 ℘C：

> ℘C = {x : 对于所有的 y，如果 y ∈ x，则 φC(y)},

这里 φC 是定义类 C 的公式。重要的是，在这个定义中，x 的范围是集合而不是类；所使用的形式语言一开始并没有直接涉及类。例如，℘V = V，℘(WF) = WF。我们也以同样的一般方式定义其他操作对类的作用。例如，有限幂集 ℘fin 将类 C 映射为 C 的有限子集的类。

### 2.2 集合论基础公理

集合论基础公理（FA）可以用不同的方式陈述。以下是一些表述；在其他公理存在的情况下，它们的等价性是基本集合论的一个标准结果。

1. 不存在无限序列的集合

> _x_0  ∋  _x_1  ∋  _x_2  ∋  … *x\*\*n*  ∋  *x\*\*n+1*  ∋  …

每个术语都是前一个术语的元素。

2. 对于每个非空集合 x，存在某个 y ∈ x，使得 y∩x =∅。
3. 设 a 为任意集合，f: ℘a → a 为函数。设 b 为任意传递集合。则存在唯一函数 g: b → a，使得对于所有 x ∈ b，g(x) = f(g\[x])。
4. 对于每个集合 x，存在一个序数 α，使得 x ∈ Vα。
5. V = WF。

这些中的第一个可能是最容易记住和思考的。第二个很重要，因为它是最容易用一阶逻辑表达的。第三个是一个递归原理；我们将在第 4.4 节中考虑一个密切相关的原理。

#### 2.2.1 集合的迭代概念

正如我们所见，FA 的一个表述是每个集合都属于某个 Vα。这是集合的迭代概念的数学表述：集合只是通过在良序的序数类上迭代幂集操作得到的。我们从空集开始，即 V0。然后我们形成 V1 = ℘V0。然后 V2 = ℘V1。继续下去，当我们到达第一个极限序数 ω 时，我们将 Vω 定义为所有集合 V\*\*n 的并集。然后我们继续到 Vω+1 = ℘ Vω。我们像这样永远继续下去，穿过“所有的序数”。所描述的集合是集合的宇宙 V。

这种描述迭代图像的方式表明，序数在所有迭代发生之前就以某种方式存在，或者至少它们与其他集合有着独立的生命。还有一种理解迭代概念的方式，强调幂集操作的迭代与替代公理之间的和谐：随着迭代幂集公理，越来越多的良序集出现。替代公理允许我们装饰这些良序集，在此过程中创建新的序数。因此，整个图像是一个平衡的。实际上，关于平衡的这一点可以毫不涉及任何“迭代”：在集合论宇宙中，幂集公理的“横向”推动与替代公理的“向上”推动之间存在着一个平衡。\[8]

使用基础公理。基础公理在数学的形式化或无限研究中没有起到任何作用。它是数学的“可选附加项”。基础公理用于澄清我们对集合的图像，就像我们所描述的那样。这通常伴随着大致以下形式的隐含论证：

一个论证。人们很容易沿以下线路证明基础公理的合理性：

1. 罗素悖论表明没有所有集合的集合：类 V 不能是自身的成员。
2. 迭代图解释了为什么没有集合可以是自身的成员。
3. 迭代图还暗示了 FA 的形式，即每个集合都属于某个 Vα。
4. 因此，FA 反映了一个避免了罗素悖论的图景，因此接受它是明智的。

这里的反驳是可能存在其他直观的图景或集合概念，也能解释或从悖论中得到教训。因此，在这方面，它们与 FA 一样合理。

由于 FA 在概念上起作用而不是数学上的作用，所以对于它是否是标准集合论 ZFC 的重要组成部分存在广泛不同的观点并不令人意外。有关 FA 角色的引用集合，请参见 Barwise 和 Moss（1991）。

基础公理和对象循环性。我们在与流相关的讨论中提到，根据标准集合论，数字流是不存在的。这是推理的原因。回想一下，我们将流定义为一个数字和另一个流的对。假设存在一个流 s，使得流的集合 N∞ 非空。回想一下，我们通过递归定义了一个函数 fs：N→N∞：

| *f\*\*s*(0)     | = | *s*                 |
| --------------- | - | ------------------- |
| *f\*\*s*(*n*+1) | = | tail(*f\*\*s*(*n*)) |

为了在这一点上节省一些符号，让我们写 hn 代表 head(f **s(n))，tn 代表 tail(f** s(n))。对于所有的 n，

> *f\*\*s*(*n*) = ⟨ *hn*, *tn* ⟩ = \{{*hn*}, \{{*hn*, *tn*\}}};

这对于任意一对都是正确的。请注意

> f **s(n+1) = tn ∈ {hn, tn} ∈ f** s(n)。

所以我们有

> *f\*\*s*(*0*) ∋ {*h0*, *t0*} ∋ *f\*\*s*(*1*) ∋ {*h1*, *t1*} ∋ *f\*\*s*(*2*) ∋ …

这是一个成员关系中的降序序列，这是 FA 所禁止的。

对于我们讨论的无限树以及超集，同样的评论也适用。结论是，如果想在具有 FA 的集合论中使用这些对象，那么必须间接地这样做。

### 2.3 反基础公理

反基础公理（AFA）的陈述如下：

> 每个图形都有唯一的装饰。

ZFA 理论是将 FA 替换为 AFA 的 ZFC 理论。尽管首字母缩写中没有 "C"，但它包括选择公理。

集合的共迭代概念。AFA 引发或反映了与迭代概念相悖的集合概念。由于没有更好的名称，我们称之为共迭代概念。根据这个概念，集合是通过取一个图 G（一个带有关系的集合），然后将图中的每个节点 x 关联到一个集合，使得与 x 关联的集合是 G 中 x 的子节点关联的集合的集合。这种关联是我们之前称之为装饰的。这种关联可以被视为过程性的，但不一定要这样解释。我们可以假设装饰和幂集之间存在一种和谐关系。\[9]

AFA 带来了哪些变化，又有哪些不变？AFA 为集合系统的系统提供了唯一的解决方案；这几乎可以从公理和集合系统与图之间的密切关系中立即得出。但它也为流系统和树系统提供了唯一的解决方案。关于与流和对相关的图的装饰的详细信息，我们之前已经看到了。

所有在集合论中不使用 FA 的结果，在用 AFA 替换它时仍然成立。特别是以下主题保持不变：罗素悖论和分离（子集）公理；有序对、关系和函数的建模；自然数、实数等；良序和序数；对良序和良基关系的超限递归；选择公理；关于无限集大小的问题和结果。唯一的区别在于对各种循环定义对象的建模问题，正如我们一直在讨论的那样。

就循环性建模而言，AFA 提供了几个新的概念和技术。这些将在我们的下一节中描述。

## 3. 使用 AFA

本节为非良基集合论的核心部分提供了一个快速介绍：使用该理论和阅读相关论文所需了解的内容。

### 3.1 仿射关系

仿射关系是处理非良基集合的早期目标之一。

设(G,→)为一个图。如果关系 R 在 G 上是一个双模拟，则满足以下条件：无论何时 x R y，

1. 如果 x → x′，那么存在一些 y → y′，使得 x′ R y′。
2. 如果 y → y′，那么存在一些 x → x′，使得 x′ R y′。

这些有时被称为具有启示性的名称 zig 和 zag。

图之间的双模拟。在给出示例之前，我们应该澄清一些用法。在某些情况下，我们将讨论两个图 G 和 H 之间的双模拟，而不是单个图上的双模拟。这可以用相同的一般方式定义。还要注意，可以取图 G 和 H 的不相交并 G + H，然后 G 和 H 之间的双模拟将是 G + H 上的双模拟。

回到图上的双模拟。举个例子，让我们看一下下面的图 G：

> <img src="https://plato.stanford.edu/entries/nonwellfounded-set-theory/fig1.png" alt="fig1" data-size="original">

所有的 3 个点都没有子节点。（点 3d 没有从任何其他点到达，但是指向节点的箭头不重要。）因此，只涉及 3 个点的每个关系都是 G 上的双模拟。具体来说，

> {(3_a_, 3_b_), (3_c_, 3_a_), (3_d_, 3_d_)}

很容易看出是一个双模拟。

对此而言，空关系也是 G 上的一个双模拟关系。

另一个双模拟关系是

> {(2_a_, 2_b_), (2_b_, 2_c_), (2_c_, 2_a_), (3_a_, 3_b_), (3_b_, 3_c_), (3_c_, 3_a_)}.

让我们称这个关系为 R。要验证 R 是否是一个双模拟需要进行大量的检查。这里只是其中的两个项目：我们看到 2b R 2c。现在 2c → 2b。因此我们需要一个节点 x，使得 x R 2b 并且 2b → x。为此，我们取 2a。对于我们的第二个验证点，再次注意到 2b R 2c。由于 2b → 3b，我们需要一个节点 x，使得 2c → x 并且 3b R x。我们取 x = 3c。

我们图 G 上最大的双模拟是将 1 与自身相关联，将所有 2 点与所有 2 点相关联，将所有 3 点与所有 3 点相关联的关系。注意这是一个等价关系：自反的，对称的和传递的。这不是偶然的。

> 命题 对于任何图 H，存在一个 H 上的最大双模拟。这个关系是一个等价关系，用 ≡b 表示，并且它的特征是
>
> > x ≡b y 当且仅当存在一个关于 H 的双模拟关系将 x 和 y 相关联。

这个关系 ≡b 被称为双模拟相似性。

我们总是可以使用最大的双模拟关系来构建商图。以下是使用上述 G 作为示例的工作原理。在 G/≡b 中，我们将有三个节点，对应于最大双模拟关系下的三个等价类；让我们称这些类为 1、2 和 3。如果第一个类的某个（每个）元素与第二个类的某个元素之间存在箭头，则在它们之间放置一个箭头。通过这种方式，我们构建了商图。以下是 G 的图片，以及其在最大双模拟关系下的商图 G/≡b：

> <img src="https://plato.stanford.edu/entries/nonwellfounded-set-theory/fig1.png" alt="fig1" data-size="original"> <img src="https://plato.stanford.edu/entries/nonwellfounded-set-theory/fig2.png" alt="fig2" data-size="original">

从 G 到 G/≡b 的映射将 2 个点映射到点 2，将 3 个点映射到点 3。

到目前为止，我们已经说了什么是双模拟，但我们没有描述它与其他任何事物的关系。为了纠正这个问题，这里是主要结果。

> 定理 假设 AFA。设 G 是一个图，x 和 y 是 G 的节点，d 是 G 的装饰。那么以下命题是等价的：
>
> 1. *d*(*x*) = *d*(*y*).
> 2. 存在一个双模拟关系与 x 和 y 相关。

我们不会在这里完整证明这个定理，而是给出两个提示。要证明(1)蕴含(2)，请检查 d 的核关系。

> {(*u*, *v*) : *d*(*u*) = *d*(*v*)}

是 G 上的一个双模拟。

反过来，思路是将一个双模拟转化为一个图本身，然后提取出两个装饰；根据 AFA 的唯一性部分，它们必须重合。以下是一个具体示例中的操作方法。我们之前看到

> R = {(2a, 2b), (2b, 2c), (2c, 2a), (3a, 3b), (3b, 3c), (3c, 3a)}。

是一个双模拟。我们通过取乘积关系将其转化为图形。这给出了以下我们称之为 H 的图形：

> <img src="https://plato.stanford.edu/entries/nonwellfounded-set-theory/fig3.png" alt="fig3" data-size="original">

设 d 是 G 的一个装饰（不，是唯一的装饰）。我们得到 H 的两个装饰，k 和 l，定义如下：

> k(u, v) = d(u)，而 l(u, v) = d(v)。

（检查一下这些是否真的是 H 的装饰物是很好的。）但是 H 只能有一个装饰物。所以 k = b。然后，对应于 2a R 2c 这个事实，例如，我们有

> d(2a) = k(2a,2b) = l(2a,2b) = d(2b)。

这就是我们的概述。更多细节请参阅 Aczel（1988）。

### 3.2 不使用 AFA

我们在上面对于双模拟的工作可以用来将非良基集合的问题归约到普通集合的问题上，这与我们在第 1.1 节中对于流和函数的看法非常相似。有几种方法可以描述这样的归约。

一个有向图是一个三元组(G,→, g)，其中→是 G 上的关系，g ∈ G。一个有向图(G,→, g)和(H,⇒, h)之间的双模拟是一个在(G,→)和(H,⇒)之间的双模拟 R，使得 g   R   h。

在本讨论的剩余部分，我们用 p，q，…表示有向图。如果 p 和 q 之间存在一个双模拟，我们写作 p ≡b q。如果存在一个有向图(G,→, g)和 G 中的某个 g → h，使得 p ≡ (G,→, h)和 q ≡ (G,→, g)。

> p ≡ (G,→, h)和 q ≡ (G,→, g)。

集合论语言中的句子讨论集合，并且我们通过将所有量词限制在指向图的类上，然后将 ∈ 翻译为 ε，将 ≡ 翻译为=，将它们翻译为关于指向图的句子。例如，外延公理

> ∀ *x*,*y*(*x*=*y* → ∀ *z*(*z* ∈ *x* → *z* ∈ *y*)).

将被翻译为（其中 p，q，r 为指向图的范围）：

> ∀ *p*,*q*(*p* ≡ *q* → ∀ *r*(*r* ε *p* → *r* ε *q*)).

这最后一句话是可以证明的。（提示：图上任意一组双模拟的并集仍然是它的双模拟。）

实际上，ZFA 的所有公理都是可以证明的，包括 AFA。这是一个相当冗长和乏味的验证过程，但并不是很棘手。它的一个版本（用于具有非集合元素的集合论，即不是集合的对象）是 Barwise 和 Moss（1996）一章的主题。

人们还可以更进一步：不是将恒等关系=翻译成更复杂的东西，而是保持语言简单并复杂化解释。我们想用“≡-类的指向图”来替换“指向图”。由于这些不是集合，我们使用斯科特的技巧，而是使用“节点集相等的良基指向图的集合，并且具有没有更小等级的指向图也与它们相等的属性。”

做所有这些会导致相对一致性结果：

> 定理。如果 ZFC 是一致的，那么 ZFA 也是一致的，反之亦然。

### 3.3 扩展图

我们所呈现的图、装饰和 AFA 的方式是非常“极简主义”的。如果有人希望将图 G 的某个节点装饰为某个集合 a，最明显的方法是在 G 中添加 tc({x})的所有元素作为新节点，其中 y→z 当且仅当 z ∈ y。这意味着如果 tc({x})中的某些集合已经是 G 中的节点，则必须新建副本。这通常很麻烦：在处理图和装饰时，人们可能希望尽可能预先指定节点上的装饰值。有几种方法可以使用 AFA 来实现这一点，我们将在这里指出一种方法。

如果两个集合的交集为空，则它们是不相交的。当将两个集合 a 和 b 的并集时，有时最好确保没有元素同时出现在两个集合中。要做到这一点，可以将 a 和 b 中的一个或两个替换为副本。

集合 a 和 b 的不相交并集是 a+ b，定义为

> *a*+*b* = (*a*  × {0}) ∪ (*b*   × {1}).

很容易看出并集中的两个集合是不相交的：a+ b 的元素“标志着”它们来自哪个集合。

不相交并集带有两个自然函数：

> inl：a → a+ b 和 inr：b → a+ b

由 inl(x) = ⟨x,0⟩ 和 inr(x) = ⟨x,1⟩ 定义。\[ 10]

一个带有集合参数的扩展图（或简称为扩展图）是一个集合 G 和一个函数 e：G→ ℘G+V 的组合。如果 e(g)的形式为 ⟨s,0⟩，其中 s ⊆ G，则我们将其视为一个节点，就像我们之前处理的那样。特别是，我们希望用其子节点的装饰集合来装饰它。如果 e(g) = ⟨x,1⟩，那么我们希望在 g 上强制装饰的值为 x。

形式上，扩展图的装饰是定义在 G 上的函数 d，使得对于所有的 g ∈ G，

| *d*(*g*) | = | { | <p>{<em> d </em>(<em> h </em>) :<em> g </em>→<em> h </em>}<br> *xt: x* </p> | <p> 如果 e(g) = ⟨s,0⟩ <br> 如果 e(g) = ⟨x,1⟩ </p> |
| -------- | - | - | ------------------------------------------------------------------ | ----------------------------------------- |

这是一个例子：设 G 是具有节点集合 {w, x, y, z} 和由 e 给定的扩展图

| *e*(*w*) = | ⟨{*w*,*x*,*y*}, 0⟩ |   | *e*(*y*) = | ⟨2,1⟩ |
| ---------- | ------------------ | - | ---------- | ----- |
| *e*(*x*) = | ⟨{*z*}, 0⟩         |   | *e*(*z*) = | ⟨∅,0⟩ |

然后，对于这个扩展图的装饰 d，满足以下条件：

| *d*(*w*) = {*d*(*w*),1,2} |   | *d*(*y*) = 2     |
| ------------------------- | - | ---------------- |
| *d*(*x*) = {0} = 1        |   | *d*(*z*) = ∅ = 0 |

> 定理 假设 AFA。那么每个扩展图都有唯一的装饰。

我们试图表达的观点是，有相当多的理论可以促进在 ZFA 中进行工作，以便对各种形式的循环现象进行建模。

### 3.4 ZFA 中的集合循环性

AFA 允许我们解决各种集合方程系统的事实只是个开始。当我们在第 1.2 节讨论无限树时，我们注意到无限树的集合 Tr 应满足（7），如下所示：

> Tr = {x, y} ∪ ({•} × Tr) ∪ ({\*} × Tr × Tr)。

在第 1.1 节中，流应满足类似的方程：

> *N* ∞ = *N* × *N* ∞ .

对于这个问题，集合论的宇宙 V 应该满足

> *V* = ℘ *V*

假设幂集公理和将 ℘ 作为类的运算符的表述，宇宙 V 确实满足这个方程。

我们可以自由地退后一步，将这些看作我们希望解决的方程。例如，我们可以将集合 N 视为已知，将 N∞ 视为一个变量，然后考虑像 X = N×X 这样的方程。然而，这些方程都不是我们可以希望用 AFA 完全一般的方式解决的类型：右边的值不是以左边的对象集合的形式给出的。解决更复杂的系统需要额外的特殊工作。以下是关于这个问题已知的情况。

首先，在 FA 下，我们的三个方程中的前两个方程都有唯一解：空集。在 AFA 下，它们有许多解。例如，对于流方程，与最终为 0 的函数对应的流的集合是一个解。然而，最大的解是特别感兴趣的。对于这些解，可以证明最大的解与我们所称的展开形式一一对应。出于其他原因，我们将看到有充分的理由接受最大的解是直观概念的良好数学模型的主张。

在 AFA 下，情况有所不同。这是一个总体的图景：对于集合上的运算符 F，如果对于任何 a ⊆ b，那么 Fa ⊆ Fb，那么它是单调的。这是集合上运算符的一个非常常见的特征。集合上的多项式运算符是包含常数运算符的最小集合，并且在笛卡尔积、不相交并、以及来自固定集合的函数下是封闭的。例如，如果 A 和 B 是固定集合，那么 Fs = (A × s) + B(s + A)是一个多项式运算符。如果还允许出现幂集运算符，那么我们得到幂多项式运算符。每个幂多项式运算符都是单调的。现在，我们有了由 Aczel 得出的以下结果：

> 命题。那么对于集合上的每个单调运算符 F，都存在一个最小不动点 F_和一个最大不动点 F_。特别地，对于类上的每个多项式运算符，都存在最小和最大不动点。对于类，对于更大的幂多项式运算符集合，情况也是如此。

在假设 FA 的情况下，不动点是唯一的；通常它们是空集。在 AFA 下，最大不动点通常具有非良基成员。当我们转向余代数时，我们将更详细地研究这一点。现在，我们回到本节开头的最后一个示例方程，V = ℘V。由于康托尔的定理，这个方程在集合中没有解。然而，就类而言，这个方程是有解的，我们知道这一点。普遍类 V 是一个解，正如我们所见。而良基集合类 WF 也是一个解。这是最小解 ℘ *，而 V 是最大解。在 FA 下，℘* = V = ℘ *。在 AFA 下，℘* 和 ℘ *是不同的：℘* = WF，而 ℘\* = V，因此包含诸如 Ω= {Ω}的集合。

## 4. 比较基础和反基础

本节的目的是以技术的方式比较 FA 和 AFA，使用范畴论的思想。也就是说，使用范畴论的语言，特别是其内置的对偶特性，来对 FA 和 AFA 之间的关系进行深入的阐述。此外，关于公理的对偶陈述还暗示了许多其他概念之间的更系统和全面的对偶关系。这个更深层次的观点并不是严格的数学结果，而更像是一个研究计划，因此最后的小节将详细介绍一些已知的内容。

正如我们所说，我们在这里开始使用范畴论。我们意识到并非所有读者都对这个主题非常熟悉。因此，我们将尽可能使本节易于理解。特别是，我们只会介绍我们在本节工作中实际需要的范畴论概念。我们还将在一些感兴趣的范畴上说明所有定义。随着我们在未来的章节中继续进行，我们只会发展我们需要的背景知识。\[11]

我们使用范畴论主要是为了术语和直觉。我们知道使用范畴论作为数学基础存在一些哲学问题。本条目不会直接涉及这些问题。

初始对象和终结对象。

我们需要范畴论的一个定义。固定一个范畴 C。如果对于每个对象 y，存在唯一的态射 f：x → y，则对象 x 是初始对象。类似地，如果对于每个对象 y，存在唯一的态射 f：y → x，则对象 x 是终结对象。

在集合论中，空集是一个初等对象；对于每个集合 y，空函数是从 ∅ 到 y 的唯一函数。此外，空集是唯一的初等对象。

至于终结对象，每个单元素集合{x}都是一个终结对象。对于每个集合 y，取值为 x 的常函数是从 y 到 x 的唯一函数。而单元素集合是该范畴中唯一的终结对象。

> 命题：设 C 是一个范畴，a 和 b 是初等对象。那么 a 和 b 是同构对象：存在着从 a 到 b 的态射 f 和从 b 到 a 的态射 g，使得 g⋅f = id **a 和 f⋅g = id** b。

> 通过初始性证明，我们得到了（唯一的）态射 f 和 g，就像我们的陈述中一样。请注意，g⋅f 是从 a 到自身的态射。由于 a 是初始的，id **a 也是这样的态射，我们可以看到 g⋅f = id** a。b 的情况类似。

### 4.1 集合的范畴，类的范畴

我们将读者引用到关于范畴论的条目中，以了解范畴和函子的定义。

我们需要提及集合和类别中的对象和态射，并明确说明感兴趣的函子。

集合。对象是集合，态射是三元组 ⟨x, y, f⟩，其中 f : x → y。也就是说，每个三元组 ⟨x, y, f⟩ 都是从 x 到 y 的态射。对于集合 a，恒等态射 id\*\*a 是 ⟨a, a, f⟩，其中 f 是 a 上的恒等函数，态射的合成操作由以下方式给出：

> ⟨ *y*, *z*, *g* ⟩ ⋅ ⟨ *x*, *y*, *f* ⟩ = ⟨ *x*, *z*, *g* ⋅ *f* ⟩

集合上的函子。对集合的多项式运算符扩展到集合上的自函子。这些操作在态射上的定义是直接的，可以在任何范畴论的书中找到。以下是一个简要总结：对于任何集合 s，值为 s 的常量函子是一个集合上的函子。它将每个函数映射到 id **s。对于任何两个函子 F 和 G，我们有一个由(F× G)(a) = F** a × G\*\*a 定义的函子；这里我们使用集合上的笛卡尔积。如果 f：a → b，则

> (F× G)f(a, b) = (F **f(a), G** f(b))。

我们还有一个由(F + G)(a) = Fa+ Ga 定义的函子，其中使用集合上的余积，即不相交并集。在态射上的作用是按情况进行。

> (*F* + *G*)(*f*) (inl *x*) = *Ff*(*x*)
>
> (*F* + *G*)(*f*) (inr *x*) = *Gf*(*x*)

一个特殊情况是 Fx = x + 1。也就是说，Fx 是 x 与一个单点集的不相交并。如果 f：x→y，那么 Ff：Fx→Fy 的工作方式基本相同，将 x 中的新点映射到 y 中的新点，并且在其他方面的行为类似于 f。

幂多项式算子也可以扩展到集合上的自函子：对于态射 f: x → y，函数 ℘f: ℘x → ℘y 将每个子集 a ⊆ x 映射到其图像 f\[a] = {f(z) : z ∈ a}。

> 类。这里的对象是集合论语言中的公式 φ(x, y **1,…, y** n) 和 n 个集合 a\*\*1,…, an。我们将其视为

**Class**. Here the objects are formulas in the language of set theory φ(*x*, *y\*\*1*,…, *y\*\*n*) together with *n* sets *a\*\*1*,…, _a_n. We think of this as

> {b : φ\[b, a\*\*1,…, an]}。

然后，态射是由两个带有参数的公式和一个带有两个自由参数的公式组成的三元组，用于定义态射的作用域和余域。

在类上的函子。我们感兴趣的函子再次是幂多项式。它们在类上的定义方式与在集合上的定义方式类似。对于我们的目的来说，这两个范畴之间的主要区别在于，在集合中我们无法解决 ℘(x) = x，而在类中我们可以这样做。

### 4.2 函子的代数

设 F 是范畴 C 上的自函子。对于 F 的代数是一个二元组(c, f)，其中 c 是 C 的一个对象，f : Fc → c。

这里有一个基本的例子，说明为什么它们被称为代数。让我们取集合范畴 Set 和函子

> *Ha* = (*a* × *a*) + (*a* × *a*).

对于自然数 N 的对象，HN 因此是 N×N 的两个副本。我们将使用颜色来表示不同的副本，第一个副本用红色表示，第二个副本用蓝色表示。因此，我们可以将 HN 视为

|       |       |          |     |
| ----- | ----- | -------- | --- |
| (0,0) | (0,1) | (0,2)    | …   |
| (1,0) | (1,1) | (1,2)    | …   |
| (2,0) | (2,1) | (2,2)    | …   |
| …     | 集合论   | 替代性公理集合论 | 非良基 |

|       |       |       |   |
| ----- | ----- | ----- | - |
| (0,0) | (0,1) | (0,2) | … |
| (1,0) | (1,1) | (1,2) | … |
| (2,0) | (2,1) | (2,2) | … |
| …     | …     | …     | … |

这个函子的一个代数的一个例子是(N, α)，其中 α(a, b) = a + b，α(a, b) = a × b。换句话说，α 通过加法作用于红色的对，通过乘法作用于蓝色的对。

回到“代数”的术语，关键在于函数 α 完成了两个表格的工作。函数“是”这些表格。

这是另一个代数的例子。这次我们关注的是具有 Fx = x +1 的集合，如上所定义。我们考虑的代数是(N, s)。这里 s：N+1 → N 将自然数 n 映射到其后继 n+1，并将 N+1 中的新点映射到数字 0。

到目前为止，我们只是给出了不同函子的代数的例子。范畴化的优势在于通常的代数态射概念被证明是更一般定义的特例。

设(c, f)和(d, g)是范畴 C 上同一个函子 F 的代数。从(c, f)到(d, g)的代数态射是一个态射 α：c → d，使得下面的图表是可交换的：

|      | *Fc* | <p> <em> f </em> <br>→</p> | *c* |   |
| ---- | ---- | ---------------------- | --- | - |
| _F_α | ↓    |                        | ↓   | α |
|      | *Fd* | <p>→<br> <em> g </em> </p> | *d* |   |

（这意味着两个组合，α ⋅ f 和 g⋅Fα，是同一个函数。）

现在清楚地看到，我们有一个给定函子的代数范畴。因此，我们立即有了初始代数和终结代数的概念。不能保证它们的存在，但在许多有趣的情况下，它们确实存在。我们对初始代数感兴趣的原因是它们与递归的联系。

为了详细了解这一点，我们回到在集合上的函子 Fx = x + 1。我们在上面看到了代数(N, s)。我们声称这是一个初始代数。这意味着对于任何代数(A, a)，存在唯一的代数态射 h : (N, s) → (N, s)。也就是说，下面的图表是可交换的：

|       | *N*+1 | <p> *开始* <br>→</p> | *N* |     |
| ----- | ----- | ----------------- | --- | --- |
| *h*+1 | ↓     |                   | ↓   | *h* |
|       | *A*+1 | <p>→<br> *一个* </p> | *A* |     |

从 A+1 到 A 的 Thue 函数 a 可以分解为一个映射 i：A→A 和一个元素 b∈a。而说上面的图表是可交换的，等同于说 h(0) = b，并且对于所有 n∈N，h(s(n)) = a(h(n))。

退后一步，(N, s) 的所谓初始性与以下断言相同：

> 对于每个集合 A，每个 b ∈ A，每个 a : A → A，存在唯一的函数 h : N → A，使得 h(0) = b，并且对于所有 n ∈ N，h(s(n)) = a(h(n))。

这是 N 上递归原理的标准形式。其要点是，该原理等价于断言 (N, s) 是函子 Fx = x +1 的初始代数。

解释这个等价性的一种方式是，我们可以将 F(x) = x + 1 的初始代数的存在作为集合论的公理，取代通常的无穷公理。该公理表明，在包含 ∅ 作为元素且结构为包含关系的集合上，存在一个单例函子 S(x) = {x}的代数。这个原理比代数重构更容易陈述。使用更简单的标准陈述来推导递归原理需要一些工作，这是任何公理集合论课程中的基本主题之一。

两个一般事实：首先，Set 上的初始代数的结构映射总是一个双射。这是由 J. Lambek 在范畴论中的一个非常普遍的结果得出的。从这个结果我们可以看出，℘ 在 Set 上没有初始代数，这是由康托尔的定理得出的。

在 Set 上的多项式函子的初始代数。

让 F: 集合 → 集合 成为一个幂多项式函子。我们知道 F 是单调的（它保持集合之间的子集关系），并且很容易检查一个稍微强一点的性质：F 保持类之间的包含映射：一个包含映射是一个映射 i **a, b : a → b 在类之间“什么都不做”：a 必须是 b 的子集，并且对于所有 x ∈ a，i(x) = x。我们说 F 是标准的，如果它在包含意义上保持包含关系，即 Fia, b = i** Fa, Fb。再次强调，集合上的每个幂多项式自函子都是标准的。

集合上的多项式运算（不包括幂）也是连续的：它们保持可数个集合的并集。

让 F: 集合 → 集合 成为一个多项式自函子。我们概述了最小不动点 F\* 具有初始代数结构的证明，以及它上面的恒等映射。

一个形成递增序列

> 0 ⊆ F0 ⊆ F(F0) ⊆ F(F(F0)) ...

我们将 ∅ 写为 0。所示的每个映射都是一个包含关系，通过标准性。令 F_为集合递增序列 F\*\*n0 的并集。那么 F(F_) = F_由连续性得出。因此，(F_, id)是 F 的一个代数。要检查初始性，令(A, a)是 F 的一个代数，所以 a：Fa → a。通过递归定义映射 gn：F **n(0) → A，其中 g0：0 → A 是空函数（这就是 ∅ 的初始性），并且 g** n+1 = a ⋅ Fg\*\*n。检查我们有一个递增函数序列。

> g0 ⊆ g1 ⊆ g2 ⊆ …

然后取并集得到 φ: F\* → A。检查可知，这个 φ 是 F-代数的同态，并且确实是唯一的。

### 4.3 函数子的余代数

我们现在转向余代数。再次，设 F 是范畴 C 上的自函子。对于 F 的一个余代数，它是一个二元组(c, f)，其中 c 是 C 的一个对象，f：c→Fc。将这与代数的定义进行比较，我们可以看到余代数是同一种结构，只是箭头的方向相反。

例如，每个图都是 ℘ 在 F：Set→Set 上的一个余代数。也就是说，每个图(G,→)可以重新打包为(G, e)，其中 e：G→℘G 由 e(x)={y∈G：x→y}给出。换句话说，我们用将每个点的子集分配给它的函数来交换图的边关系。这种重新打包具有逆操作，因此“图作为带关系的集合”和“图作为 ℘ 的余代数”在这个意义上是符号变体。\[12]

设(c, f)和(e, g)是相同函子的余代数。从(c, f)到(d, g)的余代数同态是一个范畴 C 中的态射 α：c→d，使得下面的图表是可交换的：

|   | *c* | <p> <em> f </em> <br>→</p> | *Fc*  |
| - | --- | ---------------------- | ----- |
| α | ↓   |                        | ↓_F_α |
|   | *d* | <p>→<br> <em> g </em> </p> | *Fd*  |

一个余代数 (d, g) 是一个终极 (或终端) 余代数，如果对于每个余代数 (c, f)，存在一个唯一的余代数态射 α : (c,f) → (d,g)。

这是另一个例子，我们回到集合论。这些基于本条目开头的讨论，涉及数字流 (第 1.1 节)。我们处理的是函子 Fa = N×a。然后，一个流方程系统是 F 的一个余代数。为了看到这在具体情况下是如何工作的，我们回到下面重申的方程 (2)：

| (2) | *x* ≈ ⟨0,*y* ⟩ |
| --- | ------------ |
|     | *y* ≈ ⟨1,*z* ⟩ |
|     | *z* ≈ ⟨2,*x* ⟩ |

我们将这个系统视为一个余代数（X，e），其中 X = {x，y，z}，e（x）= ⟨0，y⟩，e（y）和 z（x）类似。所以现在我们有了一个关于这个 F 的具体例子的余代数。F 的另一个余代数使用流的集合 N∞ 作为其载体集合。余代数本身是

> （N∞，⟨head，tail⟩）。

这个余代数是最终的。我们不会在这里验证这一点，而是应用这一点。根据最终性，存在一个唯一的 e†：X → N∞，使得下面的图表是可交换的：

|      | *Fc* | <p> <em> f </em> <br>→</p> | *c*      |
| ---- | ---- | ---------------------- | -------- |
| _F_α | ↓    |                        | ↓ 集合论    |
|      | *N* ∞ | <p>→<br> ⟨ 头部, 尾部 ⟩ </p> | *N* × *N* ∞ |

我们现在沿着图表的两个方向跟随 X 的元素。对于 x，这告诉我们

> ⟨head, tail⟩ (*e*†(*x*)) = ⟨0, *e*†(*y*)⟩

也就是说，e†(x)是一个流，其第一个分量是 0，第二个分量是 e†(y)。当然，对于 e†(y)和 e†(z)也有类似的观察。总之，e†(x)，e†(y)和 e†(z)这三个流正是我们要找的。

对于第 1.2 节中的树的例子，同样适用。

### 4.4 公理再次

在这一点上，我们重新表述 FA 和 AFA 以进行比较。回想一下，V 是所有集合的类，且 V = ℘V。这意味着（显然地），宇宙上的恒等映射 V 到 ℘V，反之亦然。尽管如此，我们希望引入符号表示这两个映射的不同之处。我们将写成

> *i*: ℘ *V* → *V*

因此，i 将一个多重性（一组集合）视为一个统一体（一个集合）。我们还有一个在另一个方向上的映射

> *j* V →℘V

这将一个集合视为一组集合。

代数形式的基础公理。除了不是一个集合之外，(V, i) 是 ℘ 的一个初始代数：对于所有集合 a 和所有 f : ℘ a → a，存在唯一的 s : V → f，使得 m = f ⋅ ℘ m。

|      | ℘ *V* | <p> *我* <br>→</p>       | *V*  |
| ---- | ---- | ---------------------- | ---- |
| ℘ *m* | ↓    |                        | ↓ *m* |
|      | ℘ *a* | <p>→<br> <em> f </em> </p> | *a*  |

以余代数形式的反基础公理。除了不是一个集合之外，(V, )是 ℘ 的最终余代数：对于每个集合 b 和每个 e: b→ ℘b，存在一个唯一的 s : b → V，使得 s = ℘ s ⋅ e:

|     | *b* | <p> *集合论* <br>→</p> | ℘ *b*   |
| --- | --- | ------------------ | ------ |
| *s* | ↓   |                    | ↓ ℘ *s* |
|     | *V* | <p>→<br> *我* </p>   | ℘ *V*   |

映射 s 被称为系统 e 的解决方案。

类形式。我们只提到了与集合相关的公理形式。当它们作为类的公理陈述时，它们会更加美观：

FA 等价于(V, i)是类上 ℘ 的初始代数的断言。

AFA 等价于(V, )是类上 ℘ 的最终余代数的断言。

### 4.5 概念比较

下面的图表显示了迭代和共迭代思想的一种概念比较。图表顶部的条目在范畴意义上是对偶的。向下移动，图表中的行更像是研究方向而不是实际结果。因此，详细说明图表中的细节更像是一个正在进行的研究项目，而不是一个确定的问题。

对于许多在集合上的函子，特别是多项式函子和有限幂集函子，初始代数是最小不动点和恒等映射。对于多项式函子来说，这个最小不动点本身就是一个项的代数。

| 函子的代数       | 函子的余代数       |
| ----------- | ------------ |
| 初始代数        | 最终余代数        |
| 最小不动点       | 最大不动点        |
| 同余关系        | 双模拟等价关系      |
| 等式逻辑        | 模态逻辑         |
| 递归：从初始代数映射出 | 余递归：映射到最终余代数 |
| 基础公理        | 反基础公理        |
| 迭代概念        | 共迭概念         |
| 具有操作的集合     | 具有转换和观察的集合   |
| 在语法中有用      | 在语义中有用       |
| bottom-up   | top-down     |

最大不动点与最终余代数之间的联系是以下结果的内容。

> 定理\[Aczel] 对于每个在 Class 上的幂多项式 F，最大不动点与其上的恒等映射(F _，id)是 F 在 Class 上的最终余代数。此外，如果 F 是一个多项式函子，那么 F_是一个集合，(F\*，id)是 F 在 Set 上的最终余代数。

原始结果对 F 的假设要弱得多，使用了我们没有定义的概念，因此我们的陈述比 Aczel 的书中的陈述要弱。一些论文已经进一步弱化了这个最终余代数定理。

双模拟。我们之前在第 3.1 节中给出了双模拟的定义。我们在图的背景下讨论了它，但读者可能也知道来自模态逻辑的同名概念。实际上，余代数理论研究了一个更一般的概念，即给定函子的余代数上的双模拟，最早由 Aczel 和 Mendler（1989）定义。这个更一般的概念特化为几个在它们自己的领域中被提出的概念。此外，它（几乎）是代数上的同余的对偶概念；这解释了我们在概念比较图中的那条线。

等式逻辑和模态逻辑。大量的工作表明等式逻辑和模态逻辑是“对偶”的方式，但要详细说明这一点需要比我们在本条目的其余部分所需的范畴论更多的内容。

越来越多的研究领域将模态逻辑推广到了余代数。有关这个领域的调查，请参见 Kurz（2006）。

函子的最终余代数可以看作是完全观察的空间。（正如本节中的所有观点一样，这个陈述主要是针对集合上的函子，而“完全观察”的概念当然只是引人联想。）例如，让 AtProp 是一个集合，其元素被称为原子命题，并考虑函子 F(a) = ℘fin(a) × ℘(AtProp)。对于这个函子的一个余代数，是一个集合 a，连同一个将 a 映射到其有限子集的映射，以及另一个映射到原子命题集合的映射。将这两个映射结合起来，得到一个有限分支的 Kripke 模型：每个点都有有限多个子节点和一些原子命题集合。现在，模态逻辑给了我们一种“观察”余代数（Kripke 模型）中点的属性的方法。而从一个点可以观察到的所有东西的记录就是该点的模态理论。此外，可以将所有有限分支 Kripke 模型中所有点的所有理论的集合（它是一个集合）作为函子的最终余代数的载体。实际上，这将是构造最终余代数的一种方式。

核递归。现在回到图表，我们给出一个核递归定义的例子。上面给出的 zip 函数的方程显示了如何工作。它应满足

> zip(*s*, *t*)   =   ⟨head(*s*), zip(*t*, tail(*s*))⟩

这是通过核递归定义唯一定义 zip 的方式。在本讨论中，将 N∞× N∞ 写为 S。我们希望从 S 到 N∞ 的映射。我们将 S 视为函子 Fa = N × a 的最终余代数。我们将最终余代数的结构写为 ⟨head，tail⟩，就像在 1.1 节中所做的那样。思路是将 S 转化为，比如(S, f)的余代数的载体集合。然后 zip 将是从(S, f)到(S, ⟨head，tail⟩)的唯一余代数态射。剩下的是定义 f。让

> *f*(*s*, *t*) = ⟨head(*s*), ⟨ *t*, tail(*s*)⟩⟩ .

正如前面提到的，根据终结性，存在一个唯一的 zip : S → N∞，使得下面的图表是可交换的：

|     | *S*  | <p> <em> f </em> <br>→</p> | *FS*    |
| --- | ---- | ---------------------- | ------- |
| zip | ↓    |                        | ↓_F_zip |
|     | *N* ∞ | <p>→<br> ⟨ 头,尾 ⟩ </p>      | *FN* ∞   |

为了确保这个工作，我们沿着一个任意的流对，比如 ⟨s,t⟩，绕着正方形开始，从左上角开始。向下走，我们有流 zip(s, t)。从这个结构中，它将这个结构带到了 ⟨head(zip(s, t)), tail(zip(s, t))⟩ ∈ F\*\*N∞。但我们也可以通过 f 将我们的 ⟨s, t⟩ 沿着顶部带过去，得到 ⟨head(s), ⟨t, tail(s)⟩⟩。现在 Fzip 应用于这对，这就是 F 作为一个函子的作用。我们得到 ⟨head(s), zip(tail(t), s)⟩。所以总体上，我们有

> zip(*s*, *t*))   =   head(*s*)

> 尾部(zip(s, t)) = zip(tail(t), s)

正如所期望的那样。它说：要将两个流进行压缩，从第一个的头部开始，然后在第二个流上重复这个过程，最后跟随第一个的尾部。

这个演示的主要观点是最终性原则足以定义和研究核递归定义。在这个领域还有许多进一步的发展。

集合，再次讨论。我们已经详细讨论了关于基础和反基础公理以及它们所附带的概念背景的表中的行。本节的重点是将整个讨论置于更大的讨论之中。

最终余代数和核递归定义的示例。我们的概念比较表明，代数体现了具有运算的集合。这一点几乎太容易了：范畴论中“代数”一词的术语背后的原因是，具有运算的集合可以被建模为范畴意义上的代数。对于余代数来说，很难证明它们直接对应于具有“转换”或“观察”的集合。然而，我们提供了一些例子来支持这一观点。

| 函子 Fa                | coalgebra                       | 最终的余代数      | logic             |
| -------------------- | ------------------------------- | ----------- | ----------------- |
| *S* × *a*              | 流系统                             | S 上的无限流     | 对于 a ∈ S，a : φ    |
| (*S* × *a*) + 1        | 流系统，允许端点                        | 有限和无限流在 S 上 | 添加一个“流结束标记”       |
| ℘ *a*                 | 图 = 克里普克框架 = 集合方程系统             | 模双模的指向图     | 无限模态的片段，没有原子      |
| ℘fin_a_× ℘(*AtProp*) | 在原子命题集合 AtProp 上的有限分支 Kripke 模型 | 规范模型的某个子集   | 在 AtProp 上的模态逻辑片段 |

上表列出了一些在 Set 或 Class 上的函子，以及来自概念比较图的最终余代数或其他数据。

首先，对于任意集合 S，函子 Fa = S× a。对于这个 F 的一个余代数，它是一个流系统的方程，就像我们在 1.1 节中看到的那样，只是在那里我们使事物具体化，并将 S 取为自然数集合。最终的余代数是 S∞ = S × S∞，它是 S 上的流。这个函子的逻辑语言将是一个命题语言，其句子要么为真，要么具有形式 s : φ，其中 s∈S。语义将是显而易见的；例如

> (0, 1, 2, 3, … ) ⊨ 0 : 1 : 2 : 真。

应该注意，最终余代数的载体可以被取为这种语言中的某些理论。这些可以被外在地描述为所有余代数中所有点的理论。然而，更具信息性的做法是制定一个逻辑系统，然后考虑系统中的最大一致集合。通过正确的定义，最大一致集合确实成为该函子的最终余代数的载体。

其次，我们考虑 Fa = (S × a) + 1。这里 1 = {0}，+是不相交并操作。然而，人们更常用像\*\*_这样的符号来表示 1 的唯一元素。这些余代数就像是方程的流系统，只是现在方程可能要求流通过右侧的_来“停止”。所以一个余代数的例子可以是 x ≈ ⟨s,y⟩，y ≈ \*\*\*。然后解决方案将 x†取为单项序列 s。这个函子的逻辑与之前的逻辑（HML）相同，只是现在我们添加了一个原子句来检测有限序列的结束。

转向最后两行，我们已经知道 AFA 等价于(V, id)是 ℘ 的最终余代数；即使没有 AFA，我们也有一个最终余代数，其载体集是通过双模拟得到的指向图。在这种情况下，逻辑是无穷模态逻辑，实际上，它是这个逻辑的一个片段。事实证明，给定余代数中的两个点具有相同的无穷模态理论，当且仅当它们是双模拟的。

关于 ℘fin(a) × ℘(AtProp)的那一行最接近模态逻辑的克里普克语义。人们可能希望最终余代数会成为模态逻辑 K 的规范模型，但这并不完全正确。我们需要缩小范围，只考虑那些由某个有限分支模型中的某个点实现的最大一致集。

正如读者可能注意到的那样，我们在涉及逻辑方面的问题上非常模糊：是否有一个原则性的解释来说明它们的来源？在模态逻辑中，最终余代数和规范模型之间是否存在关系？这里的解释对于本条目来说太长而且太复杂。再次强调，了解这些问题的一个起点是阅读 Kurz（2006）。

在概念比较图的底部，这些线条是最具有规划性的。

在没有 AFA 的情况下：ZF 中的最终余代数。我们在注释\[2]中提到，可以通过改变配对操作的方式来证明我们的处理结果只需使用 ZFA 即可得到。这一点在 Forster（1994）中提到，并在 Paulson（1999）（以及 Paulson 的其他论文）中详细发展。将 Kuratowski 对偶 ⟨x，y⟩ 替换为变体（{0}× a）∪（{1}× b）。 （这是通常的不相交并操作，也称为集合的余积。）然后，可以定义其他概念的变体：笛卡尔积，函数等。通过这些概念，确实可以研究流和无限树，以及本条目中其他感兴趣的集合。更重要的是，可以证明最终余代数定理，即存在一个结构为恒等映射的最终余代数的充分条件。（这对于这一工作领域来说是一个重要的观点：在 ZF 中，我们可以展示与 ZFA 中相同的函子的最终余代数的存在，但在后者的理论中，我们可以得到结构映射为恒等映射的最终余代数。）

有人可能认为这一举措削弱了对 AFA 的兴趣。对于保尔森来说，这种简化很重要，因为他想使用自动定理证明器来处理集合论中的断言。详细地进行简化是有意义的，以避免改变集合论。

出于两个原因，其他人可能不会认为这是决定性的。首先，该方法不适用于像 x = {x}这样的方程，也不适用于像 x = ℘fin(x)这样的集合。后一种方程在应用中特别有用。但更重要的是，我们可能会对整个所谓的余代数概念集合感兴趣：余归纳、余递归和各种现象的自顶向下处理。对于那些同时使用这些概念并且还担心集合论建模的人来说，使用 AFA 可能会很方便，即使许多最终应用可以在标准集合论中完成。

换句话说，也可以问一个肯定属于本条目的问题，为什么应该使用 AFA 而不是 FA？这在很大程度上取决于首先将什么目的带入集合论建模中。对于大多数目的，包括大多数数学，几乎没有什么区别。为了模拟一些循环现象，事实证明使用各种函子的最终余代数很方便。尤其是当这些最终余代数上的结构映射可以被视为恒等函数时，情况尤其好。例如，这将使我们能够说一个数字流实际上是一个数字和一个流的有序对。在这种情况下，拥有 AFA 会很好，但上述结果表明，在许多有趣的情况下，实际上并不需要它。另一方面，如果一个人满足于使用同构，那么将结构映射设为恒等函数就是一种“可选附加项”。此外，选择采用哪个公理似乎是无关紧要的问题。

对于对我们之前讨论过的数学循环性质的讨论，感兴趣的读者可以参考以下补充文档，其中讨论了来自余代数和密切相关领域的更一般的思想如何帮助解决这些问题。

> [循环性质的附加相关建模](https://plato.stanford.edu/entries/nonwellfounded-set-theory/modeling-circularity.html)

## 结论

这个条目有两个主要的重点。首先，它介绍了非良基集合并描述了围绕它们的一些数学。在这方面它并不全面，读者应该参考彼得·阿兹尔（1988）的书籍，其中包括了我们甚至没有提到的除了 AFA 之外的公理的讨论。读者还可以参考巴尔维斯和莫斯（1996）对这里提到的一些观点的更多讨论。这个展示在这些书籍出版后不久开始的共代数工作中得到了很多启发。因此，熟悉其中任何一本书的读者在条目的前几节中仍然会发现一些新的内容。

另一个重点是在第 4.5 节中提出的概念性观点。这个想法是将集合论循环性的数学置于更大的主题共代数中，并通过“自下而上”和“自上而下”思想之间的更大分歧来理解这两个观点。这个更大的讨论比我们希望的要有计划性，还有很多工作要做。我们希望它能帮助读者理解集合论循环性，包括它是如何工作的，以及为什么它具有吸引力。


## Bibliography

* Aczel, P., 1988, *Non-Well-Founded Sets* (CSLI Lecture Notes: Number 14), Stanford: CSLI Publications.
* Aczel, P. and Mendler, N., 1989, ‘A final coalgebra theorem,’ in D. H. Pitt et al. (eds.), *Category Theory and Computer Science*, Heidelberg: Springer-Verlag, 357–365.
* Adámek, J., and Reitermann, J., 1994, ‘Banach’s Fixed-Point Theorem as a Base for Data-Type Equations,’ *Applied Categorical Structures*, 2: 77–90.
* Alexandru Baltag, 2000, ‘STS: A Structural Theory of Sets,’ in Michael Zakharyaschev, Krister Segerberg, Maarten de Rijke & Heinrich Wansing (eds.), *Advances in Modal Logic* (Volume 2), Stanford: CSLI Publications,. 1–34.
* Barwise, J., and Etchemendy, J., 1987, *The Liar*, Oxford: Oxford University Press.
* Barwise, J., and Moss, L., 1991, ‘Hypersets’, *The Mathematical Intelligencer*, 13(4): 31–41.
* Barwise, J., and Moss, L., 1996, *Vicious Circles* (CSLI Lecture Notes: Number 60), Stanford: CSLI Publications.
* Böge, W., and Eisele, T., 1979, ‘On solutions of Bayesian games,’ *International Journal of Game Theory*, 8(4): 193–215.
* Boolos, G., 1971, ‘The iterative conception of set,’ *The Journal of Philosophy*, 68: 215–231.
* Burgess, J., 1985, Reviews, *Journal of Symbolic Logic*, 50(2): 544–547.
* Corfield, D., 2011, ‘Understanding the Infinite II: Coalgebra, *Studies in History and Philosophy of Science* (A), 42: 571–579.
* Edalat, A., 1995, ‘Dynamical Systems, Measures and Fractals via Domain Theory,’ *Information and Computation*, 120(1): 32–48.
* Thomas Forster, 1994, ‘Why Set theory without the axiom of foundation?’ *Journal of Logic and Computation*, 4(4): 333–335.
* Forti, M. and Honsell, F., 1983, ‘Set theory with free construction principles‘, *Annali Scuola Normale Superiore di Pisa, Classe di Scienze*, 10: 493–522.
* Harsanyi, J. C., 1967, ‘Games with incomplete information played by ‘Bayesian’ players. I. The basic model,’ *Management Science*, 14: 159–182.
* Hayashi, S., 1985, ‘Self-similar sets as Tarski’s fixed points,’, *Publications of the Research Institute for Mathematical Sciences*, 21(5): 1059–1066.
* Heifetz, A., and Samet, D., 1998, ‘Topology-free typology of beliefs,’ *Journal of Economic Theory*, 82(2): 324–341.
* Incurvati, Luca, 2014, ‘The Graph Conception of Set,’ *Journal of Philosophical Logic*, 43(1): 181–208.
* Jacobs, B. and Rutten, J., 1997, ‘A Tutorial on (Co)Algebras and (Co)Induction’, in *Bulletin of the European Association for Theoretical Computer Science*, 62: 222–259.
* Kurz, A., 2006, ‘Coalgebras and Their Logics’, *ACM SIGACT News*, 37(2): 57–77.
* Levy, A., 1979, *Basic Set Theory*, Berlin: Springer-Verlag.
* Milius, S., 2005, ‘Completely iterative algebras and completely iterative monads,’ *Information and Computation*, 196: 1–41.
* Moss, L., and Viglizzo, I., 2006, ‘Final coalgebras for functors on measurable spaces,’ *Information and Computation*, 204(4): 610–636.
* Parsons, C., 1975, ‘What is the iterative conception of set?’, in Hintikka and Butts (eds.), *Logic, foundations of mathematics and computability theory* (University of Western Ontario Series in the Philosophy of Science, Volume 9: Proceedings of the Fifth International Congress on Logic, Methodology and the Philosophy of Science, University of Western Ontario, London, Ontario, 1975), Dordrecht: Reidel, 1977, Part I, pp. 335–367.
* Paulson, L., 1999, ‘Final coalgebras as greatest fixed points in ZF set theory,’ *Mathematical Structures in Computer Science*, 9: 545–567.
* Pavlovic, D., and M. H. Escardo, 1998, ‘Calculus in Coinductive Form,’ in *13th Annual IEEE Symposium in Logic in Computer Science* (*LICS 98*), Los Alamitos, CA: IEEE, 408–417. doi:10.1109/LICS.1998.705675
* Rieger, A., 2000, ‘An argument for Finsler-Aczel set theory,’ *Mind*, 109(434): 241–253. doi:10.1093/mind/109.434.241
* Rutten, J., 2000, ‘Universal coalgebra: a theory of systems,’ *Theoretical Computer Science*, 249(1): 3–80.
* Turi, D., and Rutten, J., 1998, ‘On the foundations of final semantics: non-standard sets, metric spaces, partial orders,’ *Mathematical Structures in Computer Science*, 8(5): 481–540.
* Viglizzo, I., 2005, *Coalgebras on measurable spaces*, Ph.D. Dissertation, Indiana University, Bloomington.

## Academic Tools

| ![sep man icon](https://plato.stanford.edu/symbols/sepman-icon.jpg) | [How to cite this entry](https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=nonwellfounded-set-theory).                                                                      |
| ------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![sep man icon](https://plato.stanford.edu/symbols/sepman-icon.jpg) | [Preview the PDF version of this entry](https://leibniz.stanford.edu/friends/preview/nonwellfounded-set-theory/) at the [Friends of the SEP Society](https://leibniz.stanford.edu/friends/). |
| ![inpho icon](https://plato.stanford.edu/symbols/inpho.png)         | [Look up topics and thinkers related to this entry](https://www.inphoproject.org/entity?sep=nonwellfounded-set-theory\&redirect=True) at the Internet Philosophy Ontology Project (InPhO).   |
| ![phil papers icon](https://plato.stanford.edu/symbols/pp.gif)      | [Enhanced bibliography for this entry](http://philpapers.org/sep/nonwellfounded-set-theory/) at [PhilPapers](http://philpapers.org/), with links to its database.                            |

## Other Internet Resources

* Bart Jacobs, [*Introduction to Coalgebra. Towards Mathematics of States and Observations* \[PDF\]](http://www.cs.ru.nl/B.Jacobs/CLG/JacobsCoalgebraIntro.pdf) (book draft)
* Freyd, P., 1999, ‘[Real coalgebra](https://www.mta.ca/\~cat-dist/catlist/1999/realcoalg)’, web posting on the Categories (mailing) List, 22 December 1999, [available via the mailing list archive](http://www.mta.ca/\~cat-dist/).

## Related Entries

[algebra](https://plato.stanford.edu/entries/algebra/) | [category theory](https://plato.stanford.edu/entries/category-theory/) | [set theory](https://plato.stanford.edu/entries/set-theory/) | [set theory: alternative axiomatic theories](https://plato.stanford.edu/entries/settheory-alternative/)

### Acknowledgments

I would like to thank Edward Zalta and Uri Nodelman for their advice, encouragement, and patience. I also thank Maricarmen Martinez for her comments on an earlier version of this entry.

[Copyright © 2018](https://plato.stanford.edu/info.html#c) by\
[Lawrence S. Moss](http://www.indiana.edu/\~iulg/moss/) <[*lmoss@indiana.edu*](mailto:lmoss%40indiana%2eedu)>

