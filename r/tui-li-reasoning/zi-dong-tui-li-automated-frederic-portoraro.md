# 自动推理 automated (Frederic Portoraro)

*首次发表于 2001 年 7 月 18 日；实质性修订于 2024 年 2 月 10 日*

推理是进行推断的能力，自动推理涉及构建自动化这一过程的计算系统。尽管总体目标是机械化不同形式的推理，但该术语在很大程度上与数学和形式逻辑中的有效演绎推理相对应。在这方面，自动推理类似于机械定理证明。构建自动推理程序意味着为形式演算提供算法描述，以便可以在计算机上高效地证明演算的定理。这个过程的重要方面包括定义程序将需要解决的问题类别，决定程序将用什么语言来表示程序所给出的信息以及程序推断出的新信息，指定程序将用于进行演绎推理的机制，以及找出如何高效地执行所有这些计算。虽然基础研究工作仍在继续以提供必要的理论框架，但该领域已经达到了一个程度，即研究人员正在使用自动推理程序来攻击数学和逻辑中的开放性问题，在计算科学中提供重要应用，解决工程问题，并找到精确哲学问题的新方法。

---

## 1. 引言

一个被提供给自动推理程序的问题由两个主要部分组成，即表达所提出问题的陈述，称为问题的结论，以及表达程序可用的所有相关信息的一组陈述，即问题的假设。解决问题意味着通过推理程序内嵌的演绎规则的系统应用，从给定的假设中证明结论。当找到这样的证明时，问题解决过程结束，当程序能够检测到证明不存在时，或者当程序资源耗尽时，问题解决过程也会结束。

### 1.1 问题领域

设计自动推理程序的首要考虑是界定程序需要解决的问题类别，即问题领域。领域可能非常广泛，例如适用于一阶逻辑的通用定理证明器，或者在特定领域中更为限制的定理证明器，例如塔斯基几何或模态逻辑 K。在设计自动推理程序时，一种典型的方法是首先为其提供足够的逻辑能力（例如一阶逻辑），然后进一步通过一组领域公理来界定其范围，以定义感兴趣的特定领域。举例来说，EQP 是一个用于等式逻辑的定理证明程序，它被用来解决罗宾斯代数中的一个开放问题（McCune 1997）：所有罗宾斯代数都是布尔代数吗？为此，该程序被提供了定义罗宾斯代数的公理：

(A1)(A2)(A3)x+y=y+x(commutativity)(x+y)+z=x+(y+z)(associativity)−(−(x+y)+−(x+−y))=x(Robbins equation)

然后使用该程序展示了使用亨廷顿方程−(−x+y)+−(−x+−y)=x 的布尔代数的表征是从公理中得出的。我们应该注意到，这个问题是非平凡的，因为决定有限方程集是否为布尔代数的基础是不可判定的，也就是说，它不允许算法表示；此外，这个问题被罗宾斯、亨廷顿、塔斯基和他的许多学生攻击，但没有成功。关键的一步是证明所有罗宾斯代数都满足∃x∃y(x+y=x)，因为已知这个公式是罗宾斯代数为布尔代数的充分条件。当 EQP 获得了这个信息后，该程序通过自动完成证明提供了宝贵的帮助。

一个专用的定理证明器的主要优势不在于限制其关注领域的公理，而在于该领域可能具有特定的定理证明技术，这些技术可以在推理程序中进行硬编码，从而实现更高效的逻辑实现。EQP 在解决罗宾斯问题方面的成功很大程度上归功于其内置的关联-交换推理机制。

### 1.2 语言表示

在构建自动推理程序时，第二个重要考虑因素是决定（1）如何将其领域中的问题呈现给推理程序；（2）如何在程序内部实际表示这些问题；以及（3）如何将找到的解决方案-完成的证明-显示给用户。有几种形式主义可供选择，选择取决于问题领域和推理程序使用的基本推理演算。最常用的形式主义包括标准一阶逻辑、类型化λ演算和子句逻辑。我们在这里介绍子句逻辑，并假设读者熟悉一阶逻辑的基本知识；对于类型化λ演算，读者可能需要查阅 Church 1940。子句逻辑是一阶逻辑的无量词变体，是自动推理社区中最常用的符号表示法。需要一些定义：术语是常量、变量或其参数本身也是术语的函数。例如，a、x、f(x)和 h(c,f(z),y)都是术语。文字是原子公式（例如 F(x)）或原子公式的否定（例如∼R(x,f(a))）。如果一个文字是另一个文字的否定，则它们互补。子句是（可能为空的）有限文字析取 l1∨…∨ln，其中子句中没有文字出现多次（也就是说，子句可以被看作文字集合）。基项、基文字和基子句没有变量。空子句[ ]是没有文字的子句，因此在任何解释下都是不可满足的-假的。一些例子：∼R(a,b)和 F(a)∨∼R(f(x),b)∨F(z)都是子句的例子，但只有前者是基的。总体思路是将问题的表述能够表示为一组子句，或等价地表示为合取范式（CNF）的公式，即一组子句的合取。

对于已经用标准逻辑符号表示的公式，有一个系统的两步过程将它们转化为合取范式。第一步是将公式重新表达为前束范式中的一个语义等价公式，(Θx1)…(Θxn)α(x1,…,xn)，由一串量词(Θx1)…(Θxn)和一个无量词表达式α(x1,…,xn)组成，称为矩阵。转化的第二步首先使用德摩根定律、分配律、双重否定等众所周知的逻辑等价关系将矩阵转化为合取范式；然后，根据一定的规则去掉现在已经是合取范式的矩阵前面的量词。在存在量词存在的情况下，后一步并不总是保持等价性，并且需要引入 Skolem 函数来“模拟”存在量化变量的行为。例如，将 Skolem 化过程应用于公式∀x∃y∀z∃u∀v[R(x,y,v)∨∼K(x,z,u,v)]需要引入一个一元和一个二元 Skolem 函数，分别为 f 和 g，得到公式∀x∀z∀v[R(x,f(x),v)∨∼K(x,z,g(x,z),v)]。然后可以去掉全称量词，得到我们例子中的最终子句 R(x,f(x),v)∨∼K(x,z,g(x,z),v)。Skolem 化过程可能不保持等价性，但保持可满足性，这对于基于子句的自动推理已经足够。

虽然从句形式提供了一种更统一和经济的符号表示法——没有量词，所有公式都是析取——但它也有一些缺点。其中一个缺点是当从标准逻辑符号转换为从句形式时，生成的公式的大小增加。大小的增加伴随着认知复杂性的增加，使得人类更难以阅读用从句写成的证明。另一个缺点是标准逻辑符号中的公式的句法结构可以用来指导证明的构建，但这些信息在转换为从句形式时完全丢失。

## 2. 推理演算

在构建自动推理程序时，第三个重要考虑因素是选择实际推理演算的选择，该程序将使用该演算来执行推理。如前所述，选择高度依赖于问题域的性质，并且有多种选择可用：通用定理证明和问题求解（一阶逻辑，简单类型理论），程序验证（一阶逻辑），分布式和并发系统（模态和时间逻辑），程序规范（直觉逻辑），硬件验证（高阶逻辑），逻辑编程（Horn 逻辑），约束满足（命题从句逻辑），数学（高阶逻辑），计算形而上学（高阶模态逻辑）等。

一个推理演算包括一组逻辑公理和一系列推理规则，用于从先前推导出的公式中推导出新的公式。然后，解决程序问题域中的问题实际上意味着从由逻辑公理、领域公理和问题假设组成的扩展集合Γ中建立一个特定的公式α-问题的结论。也就是说，程序需要确定Γ是否蕴含α，Γ⊨α。程序如何建立这个语义事实当然取决于它实现的演算法。有些程序可能采用非常直接的方法，试图通过从Γ实际构造α的逐步证明来建立Γ⊨α。如果成功，这当然表明Γ推导出-证明-α，我们用Γ⊢α来表示这个事实。其他推理程序可能会选择更间接的方法，试图通过显示Γ∪{∼α}不一致来建立Γ⊨α，而这又通过从集合Γ∪{∼α}推导出矛盾⊥来显示。实现前一种方法的自动化系统包括自然推理系统；基于消解、序列推导和矩阵连接方法的系统则采用后一种方法。

健全性和完备性是自动推理中特别重要的两个（元理论的）性质。健全性表明演算规则是保真的。对于直接演算，这意味着如果Γ⊢α，则Γ⊨α。对于间接演算，健全性意味着如果Γ∪{∼α}⊢⊥，则Γ⊨α。直接演算的完备性表明如果Γ⊨α，则Γ⊢α。对于间接演算，完备性属性是通过推翻来表达的，因为通过展示证明的存在，而不是从Γ到α，而是从Γ∪{∼α}到⊥。因此，如果Γ⊨α，则间接演算是推翻完备的。在这两个属性中，健全性是最理想的。不完备的演算表明在演算中无法建立某些蕴含关系。对于自动推理程序来说，这意味着非正式地说，程序无法证明某些真实陈述。不完备可能是一个不幸的事情，但缺乏健全性是一个真正的问题，因为不健全的推理程序将能够从完全真实的信息中得出错误的结论。

理解逻辑演算与其在推理程序中对应实现之间的差异是很重要的。对原始演算的实现不可避免地涉及对演算的一些修改，严格来说，这导致了一个新的演算。对原始演算最重要的修改是对其演绎规则的“机械化”，即规定规则应如何应用的系统化方式。在这个过程中，必须小心保留原始演算的元理论性质。

自动推理中另外两个元理论属性的重要性是可决定性和复杂性。如果一个演算具有算法表示，则它是可决定的，也就是说，如果存在一个算法，对于任何给定的Γ和α，它可以在有限的时间内确定问题“Γ⊨α？”的答案是“是”还是“否”。如果一个演算是不可决定的，那么就需要确定要实现哪个可决定的片段。一个演算的时间-空间复杂性指定了它的算法表示的效率如何。自动推理变得更具挑战性，因为许多有趣的演算是不可决定的，并且具有较差的复杂性度量，迫使研究人员在推理能力与算法效率之间寻求权衡。

### 2.1 解释

在推理程序的实现中使用的许多演算中，基于解释原理的演算是最受欢迎的。解释是模拟链式规则（其中 Modus Ponens 是一种特殊情况），并且基本上规定了从 p∨q 和∼q∨r 可以推断出 p∨r。更正式地说，设 C−l 表示从子句 C 中删除文字 l 的结果。假设 C1 和 C2 是包含正文字 l1 和负文字∼l2 的基本子句，使得 l1 和∼l2 互补。那么，基于基本解释的规则规定，通过解释 C1 和 C2，可以推断出(C1−l1)∨(C2−∼l2)：

(地面分辨率)C1C2(C1−l1)∨(C2−∼l2)

Herbrand 定理（Herbrand 1930）向我们保证，任何一组子句（无论是地面还是非地面的）的不可满足性都可以通过使用地面分辨率来确定。这对于自动推理来说是一个非常重要的结果，因为它告诉我们，如果一组Γ不能被无限多个解释中的任何一个满足，那么这个事实可以在有限的步骤中确定。不幸的是，直接使用 Herbrand 定理实现地面分辨率需要生成大量的地面术语，使得这种方法无望地低效。这个问题通过将地面分辨率规则推广为二元分辨率，并引入统一的概念（Robinson 1965a）得到了有效解决。统一允许解析证明被“提升”并在更一般的层次上进行；子句只需要在它们要被解析的时候进行实例化。此外，实例化过程产生的子句不必是地面实例，仍然可以包含变量。二元分辨率和统一的引入被认为是自动推理领域中最重要的发展之一。

#### 统一

两个表达式（术语或子句）的统一者是一个替换，当应用于这些表达式时使它们相等。例如，给定的替换σ

σ:={x←b,y←b,z←f(a,b)}

是一个统一者。

R(x,f(a,y))

 和

R(b,z)

自从应用于两个表达式时，它使它们相等：

R(x,f(a,y))σ=R(b,f(a,b))=R(b,z)σ

最一般的统一器（mgu）产生两个可统一表达式共享的最一般实例。在前面的例子中，替换{x←b,y←b,z←f(a,b)}是一个统一器但不是 mgu；然而，{x←b,z←f(a,y)}是一个 mgu。注意，统一化试图“匹配”两个表达式，这个基本过程已经成为大多数自动推理程序、基于解析的和其他的中心组成部分。理论统一是统一机制的扩展，包括内置的推理能力。例如，子句 R(g(a,b),x)和 R(g(b,a),d)不统一，但它们 AC-统一，其中 AC-统一是带有内置的结合和交换规则，如 g(a,b)=g(b,a)。将推理能力转移到统一机制中增加了能力，但代价是：两个可统一表达式的 mgu 的存在可能不是唯一的（实际上可能有无限多个），并且统一过程在一般情况下是不可判定的。

#### 二进制分辨率

让 C1 和 C2 分别是包含正文字 l1 和负文字∼l2 的两个子句，使得 l1 和 l2 与 mguθ统一。那么，

(二进制分辨率)C1C2(C1θ−l1θ)∨(C2θ−∼l2θ)

通过二进制分辨率；子句（C1θ−l1θ）∨（C2θ−∼l2θ）被称为 C1 和 C2 的二进制分辨式。

#### 因式分解

如果子句 C 中出现的两个或多个文字共享一个 mgu θ，则 Cθ是 C 的一个因子。例如，在 R(x,a)∨∼K(f(x),b)∨R(c,y)中，文字 R(x,a)和 R(c,y)与 mgu {x←c,y←a}统一，因此 R(c,a)∨∼K(f(c),b)是原始子句的一个因子。

#### 解释原理

设 C1 和 C2 为两个子句。那么，通过从 C1 和 C2 进行推理得到的一个合一子句被定义为：(a) C1 和 C2 的二元合一子句；(b) C1 和 C2 的一个因子的二元合一子句；(c) C1 的一个因子和 C2 的二元合一子句；或者，(d) C1 的一个因子和 C2 的一个因子的二元合一子句。

解释证明，更准确地说是推翻证明，是通过使用推理从Γ∪{∼α}推导出空子句[ ]来构造的；如果Γ∪{∼α}不可满足，那么这总是可能的，因为推理是推翻完备的（Robinson 1965a）。作为一个解释证明的例子，我们展示了集合{∀x(P(x)∨Q(x)),∀x(P(x)⊃R(x)),∀x(Q(x)⊃R(x))}，记作Γ，蕴含公式∃xR(x)。第一步是找到Γ∪{∼∃xR(x)}的子句形式；在下面的推翻中，步骤 1 到 4 展示了得到的子句集合 S0。推翻是通过使用一种级饱和方法构造的：计算初始集合 S0 的所有合一子句，将它们添加到集合中，并重复这个过程直到推导出空子句。（这产生了越来越大的集合序列：S0,S1,S2，...）我们唯一的约束是不会重复解释相同的两个子句。

> | S0 | 1  | P(x)∨Q(x) | Assumption |
> | ---- | ---- | ------------ | ------------ |
> |    | 2  |  *∼P*(x)∨R(x)  | Assumption |
> |    | 3  |  *∼Q*(x)∨R(x)  | Assumption |
> |    | 4  | ∼R(a)     | 否定结论   |
> | S1 | 5  | Q(x)∨R(x) | Res 1 2    |
> |    | 6  | P(x)∨R(x) | Res 1 3    |
> |    | 7  | ∼P(a)     | Res 2 4    |
> |    | 8  | ∼Q(a)     | Res 3 4    |
> | S2 | 9  | Q(a)       | Res 1 7    |
> |    | 10 | P(a)       | Res 1 8    |
> |    | 11 | R(x)       | Res 2 6    |
> |    | 12 | R(x)       | Res 3 5    |
> |    | 13 | Q(a)       | Res 4 5    |
> |    | 14 | P(a)       | Res 4 6    |
> |    | 15 | R(a)       | Res 5 8    |
> |    | 16 | R(a)       | Res 6 7    |
> | S3 | 17 | R(a)       | Res 2 10   |
> |    | 18 | R(a)       | Res 2 14   |
> |    | 19 | R(a)       | Res 3 9    |
> |    | 20 | R(a)       | Res 3 13   |
> |    | 21 | [ ]        | Res 4 11   |

尽管解析证明在推导[ ]方面取得了成功，但它也有一些显著的缺点。首先，反驳过程太长，需要 21 个步骤才能达到矛盾[ ]。这是由于实现的天真蛮力性质所致。这种方法不仅生成了太多的公式，而且有些明显是多余的。请注意，R(a)被推导了六次；此外，R(x)比 R(a)具有更多的“信息内容”，应该保留前者而忽略后者。解析，像其他自动推理方法一样，必须通过旨在提高推理过程效率的策略来补充。上述示例推导有 21 个步骤，但研究型问题需要数千个或数十万个步骤的推导。

#### 解析策略

在自动推理程序中成功实现推理演算法需要整合搜索策略，通过修剪不必要的推理路径来减少搜索空间。一些策略在推导过程中一旦出现冗余子句或重言式就会立即移除。另一种策略是通过称为包含的过程，在更一般的子句存在时移除更具体的子句（Robinson 1965a）。然而，无限制的包含并不能保持推理的反驳完备性，因此需要限制其适用性（Loveland 1978）。模型消除（Loveland 1969）可以通过展示在公理的某个模型中该句子为假来丢弃一个句子。模型生成作为定理证明的补充过程已经受到了广泛关注。自动推理程序已经成功地使用该方法来展示公理集的独立性，并确定满足某些给定条件的离散数学结构的存在。

与移除冗余子句不同，一些策略在第一时间阻止无用子句的生成。支持集策略（Wos, Carson & Robinson 1965）是这类策略中最强大的策略之一。对于初始为Γ∪{∼α}的集合 S，其中 T 是 S 的子集，当且仅当 S−T 是可满足的时，T 被称为 S 的支持集。支持集消解规定解析子句不能都来自于 S−T。支持集背后的动机是，由于集合Γ通常是可满足的，因此不应该将两个来自Γ的子句相互解析。超级消解（Robinson 1965b）通过将多个解析步骤合并为单个推理步骤来减少中间解析式的数量。

独立共同发现的线性推理（Loveland 1970，Luckham 1970）总是将一个子句解析为最近推导出的解析式。这使得推理具有简单的“线性”结构，可以进行直接的实现；然而，线性推理保持了推翻完备性。使用线性推理，我们可以在上述示例中仅经过八个步骤推导出空子句：

> | 1 | P(x)∨Q(x) | Assumption |
> | --- | ------------ | ------------ |
> | 2 |  *∼P*(x)∨R(x)  | Assumption |
> | 3 |  *∼Q*(x)∨R(x)  | Assumption |
> | 4 | ∼R(a)     | 否定的结论 |
> | 5 | ∼P(a)     | Res 2 4    |
> | 6 | Q(a)       | Res 1 5    |
> | 7 | R(a)       | Res 3 6    |
> | 8 | [ ]        | Res 4 7    |

除了无限制的包含关系，到目前为止提到的所有策略都保持了推翻完备性。效率是自动推理中的一个重要考虑因素，有时人们可能愿意为了速度而牺牲完备性。单元推理和输入推理是线性推理的两种改进。在前者中，解析的子句中总是有一个文字；在后者中，解析的子句总是从原始集合中选择要推翻的子句。尽管高效，但这两种策略都不完备。排序策略对谓词符号、项、文字或出现在推导中的子句施加了某种形式的偏序关系。有序推理将子句视为文字的序列-线性顺序。有序推理非常高效，但与单元和输入推理一样，不具备推翻完备性。最后，必须指出，一些策略在推导过程中改善了某些方面，但以牺牲其他方面为代价。例如，一种策略可能会减小证明搜索空间的大小，但会增加最短推翻的长度。关于定理证明策略的分类和详细介绍可以在 Bonacina 1999 中找到；关于推理复杂性（即效率度量）的讨论，请参见 Buresh-Oppenheim＆Pitassi 2003 和 Urquhart 1987。

有几个基于推理或推理改进的自动化推理程序。Otter（由 Prover4 接替）是自动化推理发展的推动力量（Wos，Overbeek，Lusk＆Boyle 1984），但已被更强大的程序如 Vampire（Voronkov 1995，Kovács＆Voronkov 2013）取代。解释还为流行的逻辑编程语言 Prolog（Clocksin＆Mellish 1981）提供了基础的逻辑计算机制。

### 2.2 序言演绎

希尔伯特风格的演算（Hilbert and Ackermann 1928）一直被用来描述逻辑系统。这些演算通常由几个公理模式和一小部分规则组成，通常包括演绎法和替换规则。尽管它们满足所需的理论要求（完备性，完整性等），但这些演算在证明构造方面的方法很困难，也不能反映标准实践。Gentzen 的目标是“建立一个尽可能准确反映数学证明中涉及的实际逻辑推理的形式化体系”（Gentzen 1935）。为了完成这个任务，Gentzen 分析了证明构造过程，然后为经典逻辑设计了两个演绎演算：自然演算 NK 和序言演算 LK（Gentzen 实际上首先设计了 NK，然后引入 LK 进行元理论研究）。这两个演算在很大程度上实现了他的目标，同时确保了完备性和完整性。这两个演算的特点是具有相对较多的演绎规则和简单的公理模式。在这两个演算中，LK 是在自动化推理程序的实现中最广泛使用的演算，我们将首先讨论 LK；NK 将在下一节中讨论。

虽然 LK 规则的应用会影响逻辑公式，但这些规则被视为操作的不是逻辑公式本身，而是序列。序列是形式为Γ→Δ的表达式，其中Γ和Δ都是（可能为空的）公式集合。Γ是序列的前提，Δ是序列的后件。序列可以这样解释：设 I 是一个解释。那么，

> 如果 I 满足序列Γ→Δ（写作：I⊨Γ→Δ），则
> 要么 I⊭α（对于某个α∈Γ），要么 I⊨β（对于某个β∈Δ）。

 换句话说，

> I⊨Γ→Δ当且仅当 I⊨(α1 &…& αn)⊃(β1∨…∨βn)，其中α1 &…& αn 是Γ中公式的迭代合取，β1∨…∨βn 是Δ中公式的迭代析取。

如果Γ或Δ为空，则它们分别是有效的或不可满足的。LK 的公理是一个序列Γ→Δ，其中Γ∩Δ≠∅。因此，要求→符号两侧出现相同的公式意味着 LK 的公理是有效的，因为没有解释可以使Γ中的所有公式为真，并同时使Δ中的所有公式为假。LK 每个逻辑连接词有两个规则，再加上一个额外的规则：割削规则。

 公理剪切规则

|              |
| -------------- |
| Γ,α→Δ,α |

| Γ→Δ,α    | α,λ→Σ |
| -------------- | ----------- |
| Γ,λ→Δ,Σ |           |

前提规则 (Θ→) 后继规则 (→Θ)&→

| Γ,α,β→Δ |
| -------------- |
| Γ,α&β→Δ |

→&

| Γ→Δ,α    | Γ→Δ,β |
| -------------- | ----------- |
| Γ→Δ,α&β |           |

∨→

| Γ,α→Δ     | Γ,β→Δ |
| --------------- | ----------- |
| Γ,α∨β→Δ |           |

→∨

| Γ→Δ,α,β  |
| --------------- |
| Γ→Δ,α∨β |

⊃→

| Γ→Δ,α     | Γ,β→Δ |
| --------------- | ----------- |
| Γ,α⊃β→Δ |           |

→⊃

| Γ,α→Δ,β  |
| --------------- |
| Γ→Δ,α⊃β |

⊃≡

| Γ,α,β→Δ  | Γ→Δ,α,β |
| --------------- | -------------- |
| Γ,α≡β→Δ |              |

≡⊃

| Γ,α→Δ,β  | Γ,β,→Δ,α |
| --------------- | --------------- |
| Γ→Δ,α≡β |               |

 自动

| Γ→Δ,α   |
| ------------- |
| Γ,∼α→Δ |

 推理

| Γ,α→Δ   |
| ------------- |
| Γ→Δ,∼α |

 随附

| Γ,α(a/x)→Δ  |
| ----------------- |
| Γ,∃xα(x)→Δ |

→∃

| Γ→Δ,α(t/x),∃xα(x) |
| ------------------------- |
| Γ→Δ,∃xα(x)         |

 ∀→全称

| Γ,α(t/x),∀xα(x)→Δ |
| ------------------------- |
| Γ,∀xα(x)→Δ         |

→∀

| Γ→Δ,α(a/x)  |
| ----------------- |
| Γ→Δ,∀xα(x) |

规则线上方的推理称为规则的前提，线下方的推理称为规则的结论。量化规则∃→和→∀具有特定的自变量条件，限制了它们的适用性，即 a 不能出现在Γ、Δ或量化的句子中。这个限制的目的是确保在替换过程中所选择的参数 a 是完全“任意”的。

在 LK 中，证明被表示为树，树中的每个节点都带有一个序列，并且原始序列位于树的根部。节点的子节点是应用于该节点的规则的前提。树的叶子上标有公理。下面是从集合{∀x(P(x)∨Q(x)),∀x(P(x)⊃R(x)),∀x(Q(x)⊃R(x))}中的∃xR(x)的 LK 证明。在下面的树中，Γ代表这个集合：

|                                  |                                |
| ---------------------------------- | -------------------------------- |
| Γ，P(a)→ P(a)，R(a)，∃xR(x)   | Γ，P(a)，R(a)→ R(a)，∃xR(x) |
| Γ,P(a),P(a)⊃R(a)→R(a),∃xR(x) |                                |
| Γ,P(a)→R(a),∃xR(x)            |                                |

|                                  |                             |
| ---------------------------------- | ----------------------------- |
| Γ,Q(a)→ Q(a),R(a),∃xR(x)      | Γ,Q(a),R(a)→ R(a),∃xR(x) |
| Γ,Q(a),Q(a)⊃R(a)→R(a),∃xR(x) |                             |
| Γ,Q(a)→R(a),∃xR(x)            |                             |

| Γ，P(a)∨Q(a)→R(a)，∃xR(x) |
| ------------------------------- |
| Γ→R(a)，∃xR(x)             |
| Γ→∃xR(x)                   |

在我们的例子中，证明树中的所有叶子都标有公理。这证实了Γ→∃xR(x)的有效性，因此也证明了Γ⊨∃xR(x)的事实。LK 在证明结论时采用了一种间接的方法，这是 LK 和 NK 之间的一个重要区别。虽然 NK 构建了一个实际的证明（从给定的假设中得出结论），但 LK 却构建了一个证明存在性的证明（从假设中得出结论的证明的存在）。例如，为了证明α是由Γ蕴含的，NK 从Γ中构建了一个逐步的证明（假设存在一个证明）；相反，LK 首先构建了序言Γ→α，然后试图通过显示它不能为假来证明其有效性。这是通过搜索使Γ（中的所有句子）为真且使α为假的反例来完成的：如果搜索失败，则不存在反例，因此序言是有效的。在这方面，LK 中的证明树实际上是反驳证明。与归结法一样，LK 是反驳完备的：如果Γ⊨α，则序言Γ→α有一个证明树。

就目前而言，LK 不适用于自动推理，并且在能够有效实施之前必须克服一些障碍。原因当然是，LK 的完备性陈述只需要断言对于每个蕴涵关系存在一个证明树，但是推理程序实际上必须构造一个更困难的任务。一些主要的障碍包括：首先，LK 没有指定在构造证明树时规则必须应用的顺序。其次，作为第一个问题的特例，规则∀→和→∃中的前提继承了应用规则的量化公式，这意味着规则可以重复应用于相同的公式，将证明搜索陷入无限循环。第三，LK 没有指示在应用规则时必须选择哪个公式。第四，量词规则没有指示在部署中必须使用哪些项或自由变量。第五，作为前一个问题的特例，量词规则的应用可能导致一个无限长的树枝，因为从未选择正确的实例化术语。幸运的是，正如我们将在下面提到的，这些问题都可以成功解决。

LK 中的公理推理是有效的，规则的结论是有效的当且仅当其前提是有效的。这个事实使我们能够在 LK 规则中应用正向推理，从公理到结论，或者反向推理，从结论到公理。此外，除了割除规则外，所有规则的前提都是其相应结论的子公式。对于自动推理来说，这是一个重要的事实，我们希望摒弃割除规则；幸运的是，LK 的无割除版本保留了其推翻完备性（Gentzen 1935）。这些结果为以反向方式构建证明树提供了有力的理由；实际上，通过这种方式工作，无割除 LK 中的反驳会随着进展而变得越来越简单，因为子公式比其父公式更简单。此外，就命题规则而言，进入树中的新子公式完全由无割除 LK 规则决定。此外，假设证明树可以完成，分支最终会以原子结束，公理的存在可以迅速确定。反向工作的另一个原因是，无割除 LK 的真值功能片段在非量词规则应用的顺序上是可合流的：如果有一个证明，无论你做什么，你都会遇到它！为了将量词规则纳入考虑，可以安排所有规则都有公平机会被使用：在应用任何量词规则之前，尽可能地应用所有非量词规则。这解决了第一个和第二个障碍，很容易看出第三个障碍现在将如何处理。第四个和第五个障碍可以通过要求替换中使用的术语从 Herbrand 宇宙（Herbrand 1930）中适当选择来解决。

在自动定理证明中，使用序列型演算法的初衷是为了机械化数学（Wang 1960）。当时，自动推理界主要关注的是归结法，但在 20 世纪 70 年代，一些研究人员开始进一步研究非归结方法（Bledsoe 1977），从而引发了对更加人性化的定理证明系统的持续而富有成果的努力（Bledsoe 1975，Nevins 1974）。最终，序列型演绎再次获得了动力，特别是作为分析表格的再现形式（Fitting 1990）。表格中使用的演绎方法本质上是无割的 LK 系统，其中集合代替了序列。

### 2.3 自然演绎

虽然 LK 和 NK 都被普遍标记为“自然演绎”系统，但后者更加值得这个称号，因为它在证明构造方面更加自然、类似人类的。NK 的规则通常被描述为在隐含理解的上下文中作用于标准逻辑公式，但在文献中也常常被给出作用于“判断”的更明确的形式，即形如Γ⊢α的表达式，其中Γ是一组公式，α是一个公式。这种形式通常被理解为表明从Γ到α存在一个证明（Kleene 1962）。在这里，我们采用 Gentzen 1935 和 Prawitz 1965 的前一种方法。NK 系统没有逻辑公理，并为每个逻辑联结词提供了两个引入-消除规则：

引入规则 (ΘI) 消除规则 (ΘE) 和 I

| α    | β |
| ------- | ---- |
| α&β |    |

&E

| α1&α2          |
| ------------------ |
| αi (对于 i=1,2) |

∨I

| αi（对于 i=1,2） |
| ------------------- |
| α1∨α2          |

∨E

| α∨β | [α — γ] | [β — γ] |
| -------- | ------------ | ------------ |
| γ     |            |            |

 ⊃我

| [α — β] |
| ------------ |
| α⊃β     |

⊃E

| α | α⊃β |
| ---- | -------- |
| β |        |

 ≡我

| [α — β] | [β — α] |
| ------------ | ------------ |
| α≡β     |            |

≡E

| αi(i=0,1) | α0≡α1 |
| ------------ | ---------- |
| α1−i     |          |

∼I

| [α — ⊥] |
| ------------ |
| ∼α       |

∼E

| [∼α — ⊥] |
| -------------- |
| α           |

∃I

| α(t/x)  |
| ---------- |
| ∃xα(x) |

∃E

| ∃xα(x) | [α(a/x) — β] |
| ---------- | ----------------- |
| β       |                 |

∀I

| α(a/x)  |
| ---------- |
| ∀xα(x) |

∀E

| ∀xα(x) |
| ---------- |
| α(t/x)  |

几点说明：首先，表达式[α—γ]表示α是证明γ的辅助假设，最终被解除，即被丢弃。例如，∃E 告诉我们，如果在构造证明的过程中已经推导出∃xα(x)，并且还有α(a/x)作为辅助假设的β，则允许推导出β。其次，在∃E 和∀I 中的特征参数 a 必须是前提、未解除的“活动”假设、规则的结论以及∃xα(x)之外的外部参数。第三，⊥是两个矛盾公式β和∼β的简写。最后，NK 是完备的：如果Γ⊨α，则存在一个使用 NK 规则从Γ推导出α的证明。

与 LK 类似，NK 中构造的证明以树的形式表示，证明的结论位于树的根部，问题的假设位于叶子节点。（证明通常也以从页面顶部到底部的推理序列Γ⊢α给出。）下面是从∀x(P(x)∨Q(x)),∀x(P(x)⊃R(x))和∀x(Q(x)⊃R(x))推导出∃xR(x)的自然推理证明树：

|                 |
| ----------------- |
| ∀x(P(x)∨Q(x)) |
| P(a)∨Q(a)      |

|                 |
| ----------------- |
| ∀x(P(x)⊃R(x)) |
| P(a)⊃R(a)      |

[P(a)—R(a)]R(a)

|                 |
| ----------------- |
| ∀x(Q(x)⊃R(x)) |
| Q(a)⊃R(a)      |

[Q(a)—R(a)]R(a)

| R(a)    |
| --------- |
| ∃xR(x) |

正如在 LK 中一样，证明构建的前向推理策略并不明确。因此，尽管证明是从前向后阅读的，也就是说，从叶子到根，或者从假设到结论，但它们通常不是以这种方式构建的。通过按照相反的顺序应用规则来实现的后向推理策略更加有效。在实现序列推导中讨论的许多障碍也适用于自然推导。这些问题可以以类似的方式处理，但自然推导引入了一些自己的问题。例如，如⊃-引入规则所示，要证明形式为α⊃β的目标，可以尝试在假设α的情况下证明β。但请注意，尽管目标α⊃β与任何其他引入规则的结论不匹配，但它与所有消除规则的结论匹配，推理程序也需要考虑这些路径。与前向推理类似，这里存在设置与证明无关的目标并使程序误入歧途的风险。例如：有什么阻止程序进入永无止境的构建过程，比如构建越来越大的合取式？或者，有什么可以防止无控制地连续应用⊃-消除规则？幸运的是，NK 在子公式属性方面具有优势，即进入自然推导证明的每个公式都可以限制为是Γ∪Δ∪{α}的子公式，其中Δ是∼-消除规则所做的辅助假设集合。通过利用子公式属性，自然推导自动定理证明器可以大大减少其搜索空间，并对消除规则的后向应用进行控制（Portoraro 1998，Sieg＆Byrnes 1996）。 如果愿意将 NK 的逻辑范围限制在直觉主义片段中，可以实现进一步的收益，其中每个证明都具有正常形式，即没有通过引入规则获得公式，然后通过消除规则消除公式（Prawitz 1965）。

使用 NK 推理的自动定理证明系统的实现受到了希望程序能够以与人类用户使用的相同的证明格式和方法进行推理的动机的驱使。这在教育领域尤为真实，学生在 NK 类似的演算下进行形式证明的交互式构建，并在需要时得到定理证明器的协助（Portoraro 1994，Suppes 1981）。还存在其他以 NK 精神为准则的研究导向的定理证明器（Pelletier 1998），但很少见。

### 2.4 矩阵连接方法

矩阵连接方法的名称（Bibel 1981）表明了它的操作方式。术语“矩阵”指的是表示问题的逻辑公式集合的形式；术语“连接”指的是该方法对这些公式的操作方式。为了说明该方法的工作原理，我们将使用命题逻辑中的一个例子，并展示出 R 由 P∨Q,P⊃R 和 Q⊃R 推导出来。这是通过证明公式

(P∨Q)&(P⊃R)&(Q⊃R)&∼R

是不可满足的来完成的。为了做到这一点，我们首先将其转化为合取范式：

(P∨Q)&(∼P∨R)&(∼Q∨R)&∼R

这个公式可以表示为一个矩阵，每一行表示一个合取式，每一列表示一个析取式：

| P   | Q |
| ----- | --- |
| ∼P | R |
| ∼Q | R |
| ∼R |   |

现在的想法是探索通过这个矩阵的所有可能的垂直路径。垂直路径是从矩阵的每一行中选择的文字集合，使得每个文字来自不同的行。垂直路径：

| *Path 1* | P,∼P,∼Q 和∼R |
| -- | ----------------- |
| *Path 2* | P,∼P,R 和∼R   |
| *Path 3* | P,R,∼Q 和∼R   |
| *Path 4* | P,R,R and ∼R   |
| *Path 5* | Q,∼P,∼Q 和∼R |
| *Path 6* | Q,∼P,R 和∼R   |
| *Path 7* | Q,R,∼Q 和∼R   |
| *Path 8* | Q,R,R and ∼R   |

如果一个路径包含两个互补的文字，则该路径是互补的。例如，路径 2 是互补的，因为它既包含 P 又包含∼P，但路径 6 也是互补的，因为它既包含 R 又包含∼R。请注意，一旦一个路径包含两个互补的文字，追求该路径就没有意义，因为它本身已经变得互补。这通常可以大大减少需要检查的路径数量。无论如何，上述矩阵中的所有路径都是互补的，这一事实证明了原始公式的不可满足性。这就是矩阵连接方法的本质。该方法可以扩展到谓词逻辑，但这需要额外的逻辑工具：斯科莱姆化、变量重命名、量词复制、通过统一实现路径的互补性，以及在所有矩阵路径上进行同时替换（Bibel 1981，Andrews 1981）。该方法的变体已经在高阶逻辑推理程序（Andrews 1981）和非经典逻辑（Wallen 1990）中实现。

### 2.5 术语重写

相等性是一种重要的逻辑关系，在自动推理中其行为值得单独处理。等式逻辑和更一般的项重写将类似等式的等式视为重写规则，也称为约简或消解规则。像 f(a)=a 这样的等式语句允许将类似 g(c,f(a)) 的项简化为 g(c,a)。然而，同样的等式也有可能生成一个无限大的项：g(c,f(a)),g(c,f(f(a))),g(c,f(f(f(a)))),…。项重写与等式逻辑的区别在于，在项重写中，等式被用作单向约简规则，而等式可以双向工作。重写规则的形式为 t1⇒t2，基本思想是寻找出现在表达式 e 中的项 t，使得 t 能够与 t1 统一化，统一化子为 θ，以便可以用 t2θ 替换 eθ 中的出现 t1θ。例如，重写规则 x+0⇒x 允许将 succ(succ(0) +0) 重写为 succ(succ(0))。

为了说明项重写的主要思想，让我们探讨一个涉及符号微分的例子（该例子和随后的讨论改编自 Baader & Nipkow 1998 的第 1 章）。让 der 表示对 x 的导数，y 是一个与 x 不同的变量，u 和 v 是范围在表达式上的变量。我们定义了重写系统：

(R1)(R2)(R3)(R4)der(x)⇒1der(y)⇒0der(u+v)⇒der(u)+der(v)der(u×v)⇒(u×der(v))+(der(u)×v)

再次，符号⇒表示应将与重写规则左侧匹配的术语替换为规则的右侧。为了看到差异化系统的工作原理，让我们计算关于 x 的导数 x×x 的导数，der(x×x)：

| der(x×x) | ⇒ | (x×der(x))+(der(x)×x) |  | by R4 |
| ----------- | ---- | ------------------------- | -- | ------- |
|           | ⇒ | (x×1)+(der(x)×x)      |  | by R1 |
|           | ⇒ | (x×1)+(1×x)           |  | by R1 |

在这一点上，由于规则（R1）-（R4）都不适用，因此无法进行进一步的简化，重写过程结束。所得到的最终表达式称为正常形式，其存在激发了以下问题：是否存在一个表达式，其简化过程在应用规则（R1）-（R4）时永远不会终止？或者更一般地说：在什么条件下，一组重写规则将始终在有限次应用规则后停止，得到一个正常形式？这个基本问题被称为重写系统的终止问题，并且我们在此不加证明地声明系统（R1）-（R4）满足终止条件。

在简化表达式时，重写系统的规则集可能有多种应用方式。这实际上是系统（R1）-（R4）中的情况，在简化 der(x×x)时，我们可以首先将规则 R1 应用于(x×der(x))+der(x)×x)的第二个子表达式，如下所示：

| der(x×x) | ⇒ | (x×der(x))+(der(x)×x) |  | by R4 |
| ----------- | ---- | ------------------------- | -- | ------- |
|           | ⇒ | (x×der(x))+(1×x)      |  | by R1 |
|           | ⇒ | (x×1)+(1×x)           |  | by R1 |

按照这种替代行动，缩减以与前一情况相同的正常形式终止。然而，这个事实不应该被视为理所当然：如果一个重写系统在其规则应用的顺序无关紧要的情况下，每个表达式最终都会被缩减为其唯一的正常形式，那么该系统被称为（全局）可合流。可以证明（R1）-（R4）是可合流的，因此我们有权说：“计算表达式的导数”（而不仅仅是“一个”导数）。为了使系统更实用，向系统添加更多规则可能会产生不希望的后果。例如，如果我们添加规则

(R5)u+0⇒u

对于(R1)–(R4)，我们将能够进一步简化某些表达式，但代价是失去了并发性。以下简化表明 der(x+0)现在有两个正常形式：计算

| der(x+0) | ⇒ | der(x)+der(0) |  | by R3 |
| ---------- | ---- | --------------- | -- | ------- |
|          | ⇒ | 1+der(0)      |  | by R1 |

给出一个正常形式，而

| der(x+0) | ⇒ | der(x) |  | by R5 |
| ---------- | ---- | -------- | -- | ------- |
|          | ⇒ | 1      |  | by R1 |

给出另一个。添加规则

(R6)der(0)⇒0

将允许进一步将 1+der(0)减少为 1+0，然后通过 R5 减少为 1。尽管这个新规则的存在实际上增加了可选路径的数量 - der(x+0)现在可以通过四种可能的方式减少 - 它们最终都会得到相同的正常形式，即 1。这不是巧合，因为可以证明(R6)实际上恢复了一致性。这引发了另一个基本问题：在什么条件下可以将非一致性系统转变为等效的一致性系统？Knuth-Bendix 完成算法（Knuth＆Bendix 1970）对这个问题给出了部分答案。

术语重写，就像任何其他自动推理方法一样，需要策略来指导其应用。Rippling（Bundy，Stevens＆Harmelen 1993，Basin＆Walsh 1996）是一种启发式方法，其起源于归纳定理证明，使用注释来有选择地限制重写过程。超级位置演算是一个等式一阶逻辑的演算，结合了一阶解析和 Knuth-Bendix 排序等概念。超级位置是可证伪完备的（Bachmair＆Ganzinger 1994），是许多定理证明器的核心，尤其是 E 等式定理证明器（Schulz 2004）和 Vampire（Voronkov 1995）。超级位置已经扩展到高阶逻辑（Bentkamp 等，2021）。

### 2.6 数学归纳法

数学归纳法是数学和计算机科学中非常重要的定理证明技术。涉及递归定义或某种形式的重复的对象或结构的问题，无一例外地需要数学归纳法来解决。特别是，关于计算机系统正确性的推理需要归纳法，有效实现归纳法的自动推理程序将具有重要的应用。

为了说明数学归纳法的必要性，假设一个属性ϕ对于数字零是真的，并且如果对一个数字是真的，那么对它的后继数字也是真的。然后，通过我们的演绎系统，我们可以推断出对于任何给定的数字 n，ϕ对它是真的，ϕ(n)。但我们不能推断出ϕ对所有数字都是真的，∀xϕ(x)；这个推理步骤需要数学归纳法的规则：

（数学归纳法）α(0)[α(n)−α(succ(n))]∀xα(x)

换句话说，为了证明∀xα(x)，我们证明α(0)是成立的，并且α(succ(n))是从α(n)的假设中得出的。在推理系统中实现归纳法会带来非常具有挑战性的搜索控制问题。其中最重要的问题是确定在证明过程中归纳法将如何应用，即找到适当的归纳模式。相关问题包括选择适当的归纳变量，以及识别基本步骤和归纳步骤的所有可能情况。

Nqthm（Boyer＆Moore 1979）一直是自动归纳定理证明最成功的实现之一。在 Gentzen 的精神下，Boyer 和 Moore 对人们如何通过归纳证明定理感兴趣。他们的定理证明器是用函数式编程语言 Lisp 编写的，这也是表示定理的语言。例如，要表示加法的交换律，用户将输入 Lisp 表达式（EQUAL（PLUS X Y）（PLUS Y X））。系统中定义的所有内容都是函数术语，包括其基本的“谓词”：T，F，EQUAL X Y，IF X Y Z，AND，NOT 等。该程序主要作为一个黑盒子运行，即内部工作细节对用户隐藏；证明是通过重写具有递归定义的术语来进行的，最终将结论的陈述减少到 T 谓词。Boyer-Moore 定理证明器已用于检查一些非常深入的定理的证明（Boyer，Kaufmann＆Moore 1995）。引理缓存，问题陈述概括和证明计划是归纳定理证明中特别有用的技术（Bundy，Harmelen＆Hesketh 1991）。

## 3. 其他逻辑

### 3.1 高阶逻辑

高阶逻辑与一阶逻辑的不同之处在于允许对函数和谓词进行量化。语句“任意两个人在某种方式上都有关联”可以在高阶逻辑中合法地表示为∀x∀y∃RR(x,y)，但在一阶逻辑中不行。高阶逻辑本质上比一阶逻辑更具表达能力，并且更接近实际数学推理的精神。例如，集合有限性的概念无法用一阶概念来表达。由于其更丰富的表达能力，实现高阶逻辑的自动定理证明器比一阶逻辑更具挑战性。这主要是因为高阶逻辑中的一致性比一阶情况更复杂：可一致的术语并不总是具有最一般的一致器，并且高阶一致性本身是不可判定的。最后，鉴于高阶逻辑是不完备的，任何自动推理程序都无法完全证明某些证明。

用于自动化一阶推理的方法可以适应高阶逻辑。TPS（Andrews 等人，1996 年，Andrews 等人，2006 年）是一种用于高阶逻辑的定理证明系统，它使用 Church 的类型化λ演算作为其逻辑表示语言，并基于一种包含 Huet 的统一算法（Huet，1975 年）的连接类型推理机制。作为 TPS 功能的示例，该程序已自动证明了有限集合的子集是有限的，选择公理的几种表述之间的等价性以及康托尔定理，即集合的子集比成员更多。后者通过断言从个体到个体集合的映射不存在来证明，证明通过对角线论证进行。HOL（Gordon＆Melham，1993 年）是另一个高阶证明开发系统，主要用于开发硬件和软件安全关键系统的辅助工具。HOL 基于交互式定理证明的 LCF 方法（Gordon，Milner＆Wadsworth，1979 年），并且构建在强类型的函数式编程语言 ML 上。HOL 和 TPS 一样，可以在自动和交互模式下运行。后者模式的可用性受到欢迎，因为最有用的自动推理系统可能是那些强调交互式定理证明（Farmer，Guttman＆Thayer，1993 年）并可用作在人类指导下操作的助手。Harrison（2000 年）讨论了在用户指导下，HOL Light 通过验证浮点算法和证明非平凡数学属性。Isabelle（Paulson，1994 年）是一种用于快速原型设计推理系统的通用高阶框架。可以使用 Isabelle 的元逻辑通过使用其许多语法和推理工具来制定对象逻辑。 Isabelle 还提供了一些现成的定理证明环境，包括 Isabelle/HOL、Isabelle/ZF 和 Isabelle/FOL，可以作为用户应用和进一步开发的起点（Paulson 1990，Nipkow＆Paulson 2002）。 Isabelle/ZF 已被用于证明选择公理的等价表述、良序原理的表述，以及关于基数算术的关键结果，即对于任何无限基数κ，κ⋅κ=κ（Paulson＆Grabczewski 1996）。

为了帮助证明高阶定理和解决交互证明中出现的目标，用户可以要求 Isabelle/HOL 通过 Sledgehammer（Paulson 2010）调用外部一阶证明器，Sledgehammer 是一个旨在结合不同类型的自动推理系统的互补能力的子系统，包括 SMT 求解器（请参阅关于 SAT 求解器的部分；Blanchette 等人 2013）。 LEO-II（Benzmüller 等人 2015）也是一个基于分辨率的高阶逻辑自动定理证明器，已经在各种问题中得到了广泛应用，尤其是在自动化哥德尔存在论证（见第 4.6 节逻辑和哲学）中。 Leo-II 已被 Leo-III 取代，Leo-III 实现了一个高阶有序参数消解演算，该演算在多代理黑板架构中进行并行证明搜索；该架构允许独立运行使用 Leo-III 的本地证明演算的代理，以及以合作方式运行外部专门的一阶和高阶定理证明器和模型发现器的代理（Benzmüller，Steen＆Wisniewski 2017，Steen 和 Benzmüller 2021）。

### 3.2 非经典逻辑

非经典逻辑（Haack 1978）如模态逻辑、直觉逻辑、多值逻辑、自知逻辑、非单调推理、常识和默认推理、相关逻辑、矛盾逻辑等，越来越受到自动推理社区的关注。其中一个原因是自然地希望将自动推理技术扩展到新的逻辑领域。另一个原因是机械化非经典逻辑，以试图为人工智能提供合适的基础。第三个原因是希望解决一些组合过大无法用纸和笔处理的问题。事实上，自动非经典逻辑的一些工作提供了自动推理程序的典型示例。举例来说，阿克曼常数问题要求计算相关逻辑 R 中非等价公式的数量。实际上有 3,088 个这样的公式（Slaney 1984），这个数量是通过将其夹在一个下限和一个上限之间来找到的，这个任务涉及对一个庞大的 2040020 元素模型的约束，以寻找那些在 R 中拒绝非定理的模型。可以说，如果没有自动推理程序的帮助，这个结果是不可能得到的。

在非经典逻辑中，解决问题的自动化方法有三种基本方法（McRobie 1991）。一种方法是尝试将非经典演绎演算机械化。另一种方法是在一阶逻辑中提供一个等价的问题表述，并让经典定理证明器处理它。第三种方法是在一阶框架中制定非经典逻辑的语义，以便应用解析或连接矩阵方法（Pelletier 等，2017）。描述了一个自动推理系统，用于一个具有自洽逻辑的证明，该系统采用了“间接”方法和“真值”方法来证明其定理。

#### 模态逻辑

模态逻辑在计算科学中被广泛应用于知识和信念逻辑、程序逻辑以及分布式和并发系统的规范。因此，自动化推理模态逻辑（如 K、K4、T、S4 或 S5）的程序具有重要的应用。除了 S5 之外，这些逻辑与经典逻辑具有一些重要的元理论结果，如削减消除，因此可以为它们提供无削减（模态）序列演算，并提供其自动化技术。连接方法（Andrews 1981，Bibel 1981）在帮助理解由这些模态序列演算引起的搜索空间中的冗余源头方面发挥了重要作用，并为模态逻辑、直觉主义逻辑和经典逻辑提供了统一的框架（Wallen 1990）。目前自动化模态逻辑推理的努力围绕上述的转化方法展开，即将模态逻辑嵌入到经典逻辑中，然后使用现有的自动推理系统来证明前者的定理。（Benzmüller＆Paulson 2013）展示了如何将量化模态逻辑嵌入简单类型理论中，证明了嵌入的完备性和一致性，并通过简单的实验演示了如何使用现有的高阶定理证明器来自动化模态逻辑的证明。这种方法也可以扩展到高阶模态逻辑（Benzmüller＆Paleo 2015）。事实上，嵌入到经典高阶逻辑中可以用作通用推理的手段（Benzmüller 2019）；也就是说，嵌入提供了一个通用的逻辑推理框架，其中使用经典高阶逻辑作为元逻辑，可以表示各种其他经典和非经典逻辑。通过对自由逻辑和范畴论的语义嵌入方法（Benzmüller＆Scott 2020），进一步证明了其普适性的主张。 嵌入式对自动推理有许多实际好处：普适性、统一性、符号表达和推理的表达能力，以及现有强大的已知为可靠的自动定理证明工具的便捷可用性。

#### 直觉逻辑

有不同的方法可以自动化直觉逻辑。其中一种方法是直接实现 Gentzen 的序列和自然演绎演算法的直觉版本，分别是 LJ 和 NJ。这种方法继承了这些演算法所享有的更强的规范化结果，使得机械化比它们的经典对应物更紧凑。另一种机械化直觉逻辑的方法是利用它与模态逻辑 S4 的语义相似性，并依赖于 S4 的自动化实现。自动化直觉逻辑在软件开发中具有应用，因为编写满足规范的程序对应于在直觉逻辑中证明规范的问题（Martin-Löf 1982）。自动化证明构造过程的系统在算法设计以及构造性数学中都具有重要应用。Nuprl（Constable 等，1986）是支持特定数学理论的计算机系统，即构造类型理论，并旨在提供在证明开发过程中的辅助。重点是基于逻辑的工具来支持编程，并实现形式化计算数学。多年来，Nuprl 项目的范围已从“证明即程序”扩展到“系统即理论”。与 Nuprl 类似，基于 Curry-Howard 同构，Coq 系统在归纳构造演算法中形式化其证明，这是一个具有丰富类型系统的λ演算，包括依赖类型（Coquand＆Huet 1988，Coquand＆Paulin-Mohring 1988）。与 Nuprl 一样，Coq 旨在辅助开发数学证明以及根据其形式化规范编写计算机程序。

## 4. 应用

### 4.1 逻辑编程

逻辑编程，特别是由 Prolog 语言（Colmerauer 等人，1973 年）代表的语言，可能是自动定理证明的最重要和最广泛的应用。在 20 世纪 70 年代初，人们发现逻辑可以用作编程语言（Kowalski，1974 年）。逻辑编程与其他传统形式的编程的区别在于，为了解决问题，逻辑程序不会明确说明如何执行特定的计算；相反，逻辑程序说明问题是什么，然后将实际解决问题的任务委托给底层的定理证明器。在 Prolog 中，定理证明器基于一种称为 SLD-resolution 的解析方法的改进。SLD-resolution 是线性输入解析的一种变体，它包含一条特殊规则，用于选择要解析的下一个文字；SLD-resolution 还考虑到计算机内存中，子句中的文字实际上是有序的，即它们形成一个序列而不是一个集合。Prolog 程序由陈述已知事实和规则的子句组成。例如，以下子句对航班连接做出了一些断言：

> flight(toronto, london).
> flight(london, rome).
> 航班(芝加哥，伦敦)。
> 航班(X,Y) :- 航班(X,Z) , 航班(Z,Y)。

事实上，航班(多伦多，伦敦)是一个事实，而航班(X,Y) :- 航班(X,Z) , 航班(Z,Y)是一个规则，按照惯例以逆条件写成（符号“:-”表示“如果”；逗号表示“和”；以大写字母开头的术语是变量）。前者说明多伦多和伦敦之间有航班连接；后者说明如果存在某个城市 Z，那么城市 X 和 Y 之间有航班，X 和 Z 之间有航班，Z 和 Y 之间也有航班。Prolog 程序中的子句是一种特殊类型的 Horn 子句，只有一个正文字：事实是没有否定文字的程序子句，而规则至少有一个否定文字。（请注意，在标准子句表示法中，前面示例中的程序规则将被写为航班(X,Y)∨∼航班(X,Z)∨∼航班(Z,Y)。）程序规则的特定形式是为了有效地表达以下形式的陈述：“如果这些条件同时满足，那么这个其他事实将会发生”。最后，目标是一个没有正文字的 Horn 子句。思路是，一旦编写了一个 Prolog 程序Π，我们就可以尝试确定一个新的子句γ，即目标，是否由Π蕴含，Π⊨γ；Prolog 证明器通过尝试从Π∪{∼γ}中推导出矛盾来完成这个过程。我们应该注意，仅凭程序的事实和规则无法产生矛盾；目标必须参与到这个过程中。与输入消解一样，SLD 消解对于一阶逻辑来说并不是反驳完备的，但对于 Prolog 程序的 Horn 逻辑来说是完备的。基本定理：如果Π是一个 Prolog 程序，γ是目标子句，那么Π⊨γ当且仅当Π∪{∼γ}⊢[]通过 SLD 消解（Lloyd 1984）。

例如，要找出从多伦多到罗马是否有航班，可以询问 Prolog 证明器是否从给定的程序中推导出子句 flight(toronto, rome)。为了做到这一点，证明器将∼flight(toronto,rome)添加到程序子句中，并尝试通过 SLD-推理推导出空子句[]：

| 1 | flight(toronto, london)                   | 程序子句   |
| --- | ------------------------------------------- | ------------ |
| 2 | 航班(伦敦，罗马)                          | 程序条款   |
| 3 | 航班(芝加哥，伦敦)                        | 程序条款   |
| 4 | flight(X,Y)∨∼flight(X,Z)∨∼flight(Z,Y) | 程序条款   |
| 5 | ∼飞行(多伦多, 罗马)                      | 否定的结论 |
| 6 | ∼飞行(多伦多, Z)∨∼飞行(Z, 罗马)        | Res 5 4    |
| 7 | ∼飞行(伦敦, 罗马)                        | Res 6 1    |
| 8 | []                                        | Res 7 2    |

Prolog 程序中规则的条件形式增加了其可读性，并且还允许以更友好的方式推理底层的推翻：要证明多伦多和罗马之间有一次航班，即飞行(多伦多,罗马)，将此子句与程序中第四个子句的结论飞行(X,Y)统一，如果可以证明飞行(多伦多,Z)和飞行(Z,罗马)。如果可以证明，这可以通过替换{Z←伦敦}来实现，因为飞行(多伦多,伦敦)和飞行(伦敦,罗马)本身是可以证明的。请注意，定理证明器不仅证明了多伦多和罗马之间有一次航班，而且还可以通过从证明中使用的统一中提取出实际行程，即多伦多-伦敦-罗马。

为了实现逻辑编程语言的理想，Prolog 必须解决至少两个广泛的问题。逻辑程序由描述真实情况的事实和规则组成；任何无法从程序中推导出的内容都被视为假。就我们之前的例子而言，flight(toronto, boston)不是真实的，因为这个文字无法从程序中推导出来。在大多数 Prolog 实现中，将非真实性与不可推导性等同起来，通过引入一个操作符 not，允许程序员在程序中明确表达文字（甚至子句）的否定。根据定义，如果文字 l 本身无法被推导出来，not l 就会成功。这种被称为失败否定的机制受到了批评。失败否定并不能完全捕捉到标准否定的概念，两者之间存在重要的逻辑差异。标准逻辑，包括 Horn 逻辑，是单调的，这意味着通过添加新的公理来扩大公理集合只会扩大可从中推导出的定理集合；然而，失败否定是非单调的，向现有的 Prolog 程序添加新的程序子句可能导致某些目标不再是定理。第二个问题是控制问题。目前，如果一个程序要达到可接受的效率水平，程序员需要提供相当数量的控制信息。例如，程序员必须小心地安排程序中子句的顺序，或者文字在子句中的顺序。如果做得不好，可能会导致程序效率低下，甚至无法终止。程序员还必须在程序子句中嵌入提示，以防止证明器重新访问搜索空间中的某些路径（使用剪切操作符）或完全剪枝它们（使用 fail）。 最后但并非最不重要的是，为了提高效率，许多 Prolog 的实现并没有完全实现一致化，并绕过了一个耗时但关键的测试——所谓的出现检查（occurs-check），该测试负责检查正在计算的一致化器的适用性。这导致了一个不可靠的计算和可能导致一个目标被 Prolog 程序（从计算的角度来看）包含，而实际上它不应该被包含（从逻辑的角度来看）。

有一些旨在扩展其范围的 Prolog 变体。通过实现模型消除过程，Prolog 技术定理证明器（PTTP）（Stickel 1992）将 Prolog 扩展到完全的一阶逻辑。该实现实现了完备性和一致性。超越一阶逻辑，λProlog（Miller＆Nadathur 1988）将语言基于高阶构造逻辑。

### 4.2 SAT 求解器

逻辑公式的可满足性问题受到自动推理界的广泛关注，因为它在工业中具有重要的适用性。如果命题公式存在一组真值赋值使其为真，则该公式是可满足的。例如，赋值(P← true, Q← true, R← false)不能使(P∨R)&∼Q 为真，但赋值(P← true, Q← false, R← false)可以使其为真，因此该公式是可满足的。确定一个公式是否可满足被称为布尔可满足性问题（SAT），对于一个具有 n 个变量的公式，SAT 可以这样解决：检查每一种可能的 2n 个赋值，看是否存在至少一种赋值使公式成立，即为真。这种方法显然是完备的：如果原始公式是可满足的，我们最终会找到一个满足的赋值；但如果公式是矛盾的（即不可满足），我们也能确定这一点。显然，特别是在后一种情况下，这种搜索需要指数级的时间，因此希望构思更高效的算法是完全合理的，特别是因为许多具有重要实际意义的计算问题，如图论问题、网络设计、存储和检索、调度、程序优化等（Garey & Johnson 1979），都可以表示为 SAT 实例，即某个表示问题的命题公式的 SAT 问题。鉴于 SAT 是 NP 完全问题（Cook 1971），很不可能存在一个多项式算法；然而，这并不排除对于 SAT 问题的特定情况存在足够高效的算法的可能性。

Davis-Putnam-Logemann-Loveland（DPLL）算法是最早的 SAT 搜索算法之一（Davis＆Putnam 1960; Davis，Logemman＆Loveland 1962），至今仍被认为是最好的完整 SAT 求解器之一；今天存在的许多完整 SAT 程序可以被视为 DPLL 的优化和泛化。实质上，DPLL 搜索过程通过考虑选择赋值的方式来使原始公式为真。例如，考虑 CNFP&∼Q&(∼P∨Q∨R)&(P∨∼S)中的公式。由于 P 是一个合取范式，但也是一个单元子句，如果整个公式为真，则 P 必须为真。此外，∼P 的值对∼P∨Q∨R 的真值没有贡献，而 P∨∼S 无论 S 的真值如何都为真。因此，整个公式简化为∼Q&(Q∨R)。同样，∼Q 必须为真，公式进一步简化为 R，这强制 R 为真。通过这个过程，我们可以恢复出赋值（P←真，Q←假，R←真，S←假），证明了原始公式是可满足的。一个公式可能导致算法分支；通过分支的搜索在一个子句被判定为假（冲突子句）时到达死胡同，并且可以丢弃到此为止部分构建的所有赋值的变体。为了说明：

| 1 | R&(P∨Q)&(∼P∨Q)&(∼P∨∼Q) | Given                                  |
| --- | ------------------------------ | ---------------------------------------- |
| 2 | (P∨Q)&(∼P∨Q)&(∼P∨∼Q)   | 通过让 R← true                        |
| 3 | Q&∼Q                        | 通过让 P← true                        |
| 4 | ?                            | 冲突：Q 和 ∼Q 不能同时为 true         |
| 5 | (P∨Q)&(∼P∨Q)&(∼P∨∼Q)   | Backtrack to (2): R← true still holds |
| 6 | ∼P                          | 通过让 Q← true                        |
| 7 | true                         | 通过让∼P 为真，即 P← false           |

因此，通过存在(P← false, Q← true, R← true)来满足公式。DPLL 算法通过策略（如术语索引，有利地对公式变量进行排序）、时间顺序回溯（如果过程导致冲突子句，则撤销到先前的分支点）和冲突驱动学习（确定要保留的信息和回溯的位置）使得算法更加高效。这些策略的组合导致了搜索空间的大量剪枝；对于更详细的讨论，建议感兴趣的读者参考 Zhang & Malik 2002。

一个快速的背信封计算揭示了令人震惊的计算时间，即使是只有 60 个变量的 SAT 类型问题的算法。换句话说：一个用 10 个变量表示的问题，如果采用线性解决方案，完成所需的时间只需要百分之一秒，而如果公式有 40 个和 60 个变量，完成所需的时间分别只需要百分之四和百分之六秒。相比之下，如果问题的解决方案是指数级的（比如 2 的 n 次方），那么对于 10、40 和 60 个变量来说，完成任务所需的时间分别是千分之一秒、13 天和 365 个世纪。这真正证明了自动推理社区的智慧和当前基于 SAT 的搜索算法的强大能力，使得可以以合理的效率处理具有数千个变量的现实世界问题。Küchlin＆Sinz 2000 年讨论了在工业汽车产品数据管理领域的 SAT 应用，其中使用了 18,000 个（基本）布尔公式和 17,000 个变量来表达客户订单的约束条件。另一个例子是 Massacci＆Marraro 2000 年讨论的逻辑密码分析应用，即验证以 SAT 问题形式表达的加密算法的属性。他们演示了如何通过密码攻击找到一个密钥类似于找到一个布尔公式的模型-赋值；他们的应用中的公式编码了美国数据加密标准（DES）的商业版本，编码需要 60,000 个子句和 10,000 个变量。

尽管 SAT 在概念上非常简单，但其内在本质并不被很好地理解——没有普遍适用的标准可以回答为什么一个 SAT 问题比另一个更难的问题。因此，不足为奇的是，在某些 SAT 实例上表现良好的算法在其他实例上表现不佳，并且正在努力设计混合算法解决方案，结合互补方法的优势——请参阅 Prasad、Biere 和 Gupta 2005 年的硬件设计验证中对这种混合方法的应用。

最近，SAT 混合策略与超级计算能力的进步使得三位计算科学家团队能够解决布尔勾股数问题，这是拉姆齐理论中一个长期存在的开放问题：能否将自然数集{1,2,...}分成两个部分，使得没有任何一个部分包含一个三元组(a,b,c)，满足 a2+b2=c2？Heule、Kullmann 和 Marek 在 2016 年证明了对于 n=7824，集合{1,2,…,n}可以被这样划分，但对于 n≥7825，这是不可能的。将这个看似简单的问题表达为 SAT 问题需要近 38000 个子句和 13000 个变量，其中大约一半用于表示当 n=7824 时问题是可满足的，另一半用于表示当 n=7825 时问题是不可满足的；其中，证明后者更具挑战性，因为它要求证明不存在这样的划分。考虑到所有 27825 种可能的两部分划分的朴素蛮力方法显然行不通，该问题通过在组合数学中使用“聪明”的算法来攻克，这些算法在一个多阶段的基于 SAT 的框架中使用，用于解决困难的问题，包括五个阶段：编码（将问题编码为 SAT 公式）、转换（使用子句消除和对称性破坏技术优化编码）、分割（使用分割启发式有效地将问题划分为子问题）、求解（使用快速处理搜索满足分配或其缺失）和验证（验证前几个阶段的结果）。其中，应用了立方体与征服（cube-and-conquer）的方法，这是一种特别适用于困难组合问题的混合 SAT 策略。该策略将前瞻与冲突驱动子句学习（CDCL）相结合，前者旨在使用全局启发式构建小型二叉搜索树，后者旨在使用局部启发式找到短的反驳。

将问题分解为 106 个困难的子问题（称为“立方体”），然后交给 800 个核心在 Stampede 超级计算机上并行工作。经过进一步分解和 CDCL 子句处理的 2 天后，问题得到解决，并提供了一个 200TB 的证明，验证了这项工作。在应当庆祝自动推理的重大成就之后，并在考虑到增强的 SAT 方法将提供的所有新应用（特别是在硬件和软件验证领域）之后，我们应该提出一些对数学家特别重要的问题：是否有一种更有洞察力的方式来建立这个结果，涉及更传统和智力满足的数学证明方法？或者，就增加我们对给定领域（本例中是组合数学）的理解而言，当没有人能够检查证明并从中获得洞察力时，解决问题的价值是什么？即使负责这个结果的团队也承认，“来自 SAT 求解器的不可满足性证明从人类的角度来看，是一堆随机信息（没有直接的理解涉及）”。这个猜想已经解决了，但我们基本上不知道 7825 有什么特别之处。也许从这些考虑中可以得出的真正价值是，它们引导我们思考更深层次的问题：是什么使得特定问题的结构适合于标准的数学处理，而不需要无脑的蛮力方法？在思考这个问题的同时，SAT 可能是解决某些数学问题的最佳途径。

DPLL 搜索过程已扩展到量化逻辑。MACE 是一个基于 DPLL 算法的流行程序，用于搜索带有相等性的一阶公式的有限模型。例如（McCune 2001），为了证明不是所有的群都是可交换的，可以指示 MACE 寻找一个同时违反交换律的群公理的模型，或者等价地寻找一个模型：

(G1)(G2)(G3)(DC)e⋅x=x（左单位元）i(x)⋅x=e（左逆元）x（⋅y）⋅z=x⋅（y⋅z）（结合律）a⋅b≠b⋅a（非交换性的否定）

MACE 找到了这些公理的一个六元模型，其中⋅被定义为：

| ⋅ | 0 | 1 | 2 | 3 | 4 | 5 |
| ---- | --- | --- | --- | --- | --- | --- |
| 0  | 0 | 1 | 2 | 3 | 4 | 5 |
| 1  | 1 | 0 | 4 | 5 | 2 | 3 |
| 2  | 2 | 3 | 0 | 1 | 5 | 4 |
| 3  | 3 | 2 | 5 | 4 | 0 | 1 |
| 4  | 4 | 5 | 1 | 0 | 3 | 2 |
| 5  | 5 | 4 | 3 | 2 | 1 | 0 |

并且我被定义为：

| x    | 0 | 1 | 2 | 3 | 4 | 5 |
| ------ | --- | --- | --- | --- | --- | --- |
| i(x) | 0 | 1 | 2 | 3 | 4 | 5 |

这个例子再次说明了使用自动推理系统的好处：人类研究人员要花多长时间才能提出上述或类似的模型？对于更具挑战性的问题，该程序被用作解析定理证明器 Prover9（以前是 Otter）的实际补充，Prover9 搜索证明，而 MACE 则同时寻找（反）模型。为了找到这样的模型，MACE 将一阶问题转化为一组“扁平化”的子句，对于不断增加的模型大小，这些子句被实例化为命题子句，并作为 SAT 问题求解。该方法也已在其他自动推理系统中实现，尤其是在 Paradox 模型发现器中，MACE 风格的方法已经通过四种附加技术进行了增强，从而实现了一些显着的效率改进（Claessen＆Sörensson 2003）：术语定义（减少扁平化子句中的变量数量），静态对称约简（减少同构模型的数量），排序推理（在更细的层次上应用对称约简）和增量 SAT（在连续模型大小之间重用搜索信息）。将分离的自动推理系统的互补能力配对的策略也已应用于高阶逻辑，例如 Isabelle/HOL 的反例生成器 Nitpick（Blanchette＆Nipkow 2010）。Brown 2013 描述了一种用于高阶逻辑的定理证明过程，该过程使用 SAT 求解来完成大部分工作；该过程是一个完整的，无剪切，基于地面的反驳演算，它结合了对实例化的限制，并已在 Satallax 定理证明器（Brown 2012）中实现。

在解决一阶逻辑中的 SAT 问题时，一种非常有趣的方法是满足性模理论（SMT），其中问题的符号解释受到背景理论的限制。例如，在线性算术中，函数符号被限制为+和-。另一个例子是数组的外延理论（McCarthy 1962），数组函数 read(a,i)返回数组 a 在索引 i 处的值，write(a,i,x)返回与 a 相同的数组，但在 i 处的值为 x。更正式地说，

 （读写公理 1）

∀a:Array.∀i,j:Index.∀x:Value.i=j → read(write(a,i,x),j)=x

 (可读写公理 2)

∀a:Array.∀i,j:Index.∀x:Value.i≠j → 自动(write(a,i,x),j)=自动(a,j)

 (外延性)

∀a,b:Array.∀i:Index.a=b → read(a,i)=read(b,i)

在这些公理的背景下，SMT 求解器将尝试确定给定的一阶公式的可满足性（或者，对偶地，有效性），或者成千上万个公式的可满足性，例如

i−j=1&f(read(write(a,i,2),j+1)=read(write(a,i,f(i−j+1)),i)

(Ganzinger et al. 2004)讨论了一种称为 DPLL(T)的 SMT 方法，它由一个通用的 DPLL(X)引擎和一个用于背景理论 T 的求解器 SolverT 组成。Bofill 等人(2008)在数组理论的背景下介绍了这种方法，其中 DPLL 引擎负责枚举给定公式的命题模型，而 SolverT 检查这些模型是否与数组理论一致。他们的方法是完备且正确的，并且可以顺利扩展到多维数组。

SMT 在验证应用中特别成功，尤其是软件验证。通过 SMT 改进了 SAT 求解器的效率，现在的努力是设计更高效的 SMT 求解器(de Moura 2007)。还需要对不同基于 SMT 的验证方法提供的技术进行全面比较和潜在整合，包括有界模型检查、k 归纳、谓词抽象和带插值的惰性抽象(Beyer, Dangl & Wendler 2018 和 2021)。

### 4.3 推理计算代数

为了自动证明甚至最简单的数学事实，需要大量的领域知识。通常，自动定理证明器缺乏这样丰富的知识，并试图通过应用基本推理规则来构建证明。这种方法导致非常冗长的证明（假设找到了证明），每一步都在最基本的逻辑层面上得到了证明。然而，通过让定理证明器与计算机代数系统（也称为符号计算系统）进行交互，可以获得更大的推理步骤和显著提高的数学推理能力。计算机代数系统是一种辅助用户进行符号操作和数值计算的计算机程序。例如，当被要求计算不定积分

∫∞0e−a2t2cos(2bt)dt

一个称职的计算机代数系统将迅速回答答案

√π2ae−b2/a2

本质上，计算机代数系统通过接受用户输入的表达式，并连续应用一系列的转换规则，直到结果不再改变（有关术语重写的详细信息，请参见术语重写部分）。这些转换规则编码了大量的领域（数学）知识，使得符号系统成为应用数学家、科学家和工程师手中强大的工具，用于解决从微积分和方程求解到组合学和数论等各种领域的问题。

数学问题的解决涉及推理和计算的相互作用，决策过程是两者之间模糊划分的一个提醒；因此，将推理和符号系统集成在一起，我们在这里称之为推理计算机代数（DCA），必然是一个富有成果的组合。Analytica（Bauer，Clarke＆Zhao 1998）是建立在 Mathematica 之上的定理证明器，Mathematica 是一个强大而流行的计算机代数系统。除了提供推理引擎外，Analytica 还通过定义一些重写规则（更准确地说，关于求和和不等式的等式）来扩展 Mathematica 的功能，这些规则在系统中缺失，并提供了 Gosper 算法的实现，用于找到无限超几何求和的闭合形式。凭借这些扩展的知识，Analytica 可以半自动地证明一些来自实分析的非平凡定理，包括一系列引导到 Bernstein 逼近定理证明的引理。以下是该定理的陈述，仅为了让读者对我们所处理的数学丰富程度有所了解：

> 伯恩斯坦逼近定理。
> 令 I=[0,1]为闭区间，f 为 I 上的实连续函数，Bn(x,f)为 f 的第 n 个伯恩斯坦多项式，定义为 Bn(x,f)=n∑k=0(nk)f(k/n)xk(1−x)n−k。那么，在区间 I 上，f 的伯恩斯坦多项式序列一致收敛于 f。

坦率地说，该程序提供了建立引导到该定理的引理所需的关键信息，但程序所做的推理工作的数量和类型肯定是非平凡的。（Clarke & Zhao 1994）提供了使用 Ramanujan 的笔记本第 2 章中的问题进行完全自动化证明的示例（Berndt 1985），包括以下读者被邀请尝试的示例。证明：

Ar∑k=n+11k=r+2⎛⎝r∑k=1(r−k)(ak∑j=Ak−1+11(3j)3−3j)⎞⎠+2rϕ(3,A0)

其中 A0=1，An+1=3An+1，ϕ(x,n)是拉马努金的缩写，表示

ϕ(x,n)=dfn∑K11−(kx)+k3x3

Analytica 的证明通过简化等式的左右两边，并显示出两边都简化为相同的表达式−Hn+ HAr。简化过程使用了之前提到的添加求和恒等式以及调和数的一些基本性质，

Hn=n∑k=11k

结果证明共有 28 个步骤（其中一些是非平凡的），花费大约 2 分钟找到。

Kerber, Kohlhase & Sorge 1998 使用Ωmega 规划系统作为整体集成定理证明和符号计算的方式。在 Harrison＆Théry 1998 中，我们找到了一个将高阶逻辑定理证明系统（HOL）与计算机代数系统（Maple）集成的示例。

尽管符号代数系统具有很大的能力，但它们并不强制执行与自动推理系统的严格和形式化水平相同的水平。实际上，大多数代数系统中某些知识规则的数学语义并不完全清楚，并且在某些情况下是逻辑上不完备的（Harrison＆Théry 1998）。造成这个问题的主要原因是过于积极地以尽可能快的速度为用户提供答案，不顾一切地绕过所需假设的检查，即使这意味着牺牲计算的完备性。（这与大多数 Prolog 实现非常相似，它们绕过所谓的“出现检查”也为了效率而放弃了逻辑完备性。）这个严重的问题为推理系统提供了为计算机代数系统提供服务的机会：使用其推理能力验证计算机代数的计算步骤是否满足所需假设。然而，这里有一个问题：对于足够大的计算步骤，验证等同于证明，并且为了检查这些步骤，推理系统可能需要与需要验证的系统相同的系统的帮助！解决完备性问题的解决方案可能需要对所选择的符号代数系统进行广泛修改以使其完备；另一种方法是在开发自动定理证明器的同时从头开始开发一个新系统。无论哪种情况，最终的组合推理计算机代数系统应该显示出更强大的自动数学推理能力。

### 4.4 硬件的形式验证

自动推理已经达到了成熟的水平，定理证明系统和技术正在被用于工业级应用。其中一个应用领域是对硬件和软件系统进行形式验证。硬件缺陷的成本很容易达到数百万美元。1994 年，Pentium 处理器在其浮点单元中存在缺陷，Intel 随后提供更换有缺陷芯片的选择（但只有少部分 Pentium 用户选择了更换），这给公司造成了近 5 亿美元的损失。为了防止这样的情况发生，现在认为仅仅测试芯片设计是不够的，更多形式验证的方法不仅在微处理器行业引起了广泛关注，而且已经成为必需品。形式验证的理念是通过数学证明系统按照规定的方式正常运行。硬件设计的常见应用包括在所有输入上正式确立系统的正确功能，或者两个不同的电路在功能上是等效的。

根据手头的任务，可以利用多种自动形式验证技术，包括命题逻辑中的 SAT 求解器、使用二进制决策图（BDD）进行符号模拟、时态逻辑中的模型检查，或者在高阶逻辑中进行证明。在后一种情况下，使用像 HOL 这样的自动定理证明器（见第 3.1 节）在实践中被证明是非常宝贵的。在 HOL 这样的系统中，证明构造是半自动进行的，用户提供了相当多的指导，以指导证明的进行：用户试图找到一个证明，同时得到定理证明器的帮助，该定理证明器可以在请求时自动填充一个证明段或验证给定的证明步骤。尽管上述一些技术提供了高阶逻辑所缺乏的决策过程，但高阶逻辑具有非常表达能力的优势。这种权衡是合理的，因为证明浮点算术事实需要形式化大量的实分析，包括许多基本陈述，例如：

||-|(!x. a <= x /\ x <= b ==> (f diffl (f' x)) x) /\|
| ----| ------------------------------------------------------------------------|
||f(a) <= K /\|
||f(b) <= K /\|
||(!x. a <= x /\ x <= b /\ (f'(x) = 0) ==> f(x) <= K) ==>|
||(!x. a <= x /\ x <= b ==> f(x) <= K)|

这个来自 Harrison 2000 的陈述在 HOL 中说，如果函数 f 在区间[a,b]上可微分，导数为 f'，那么在整个区间上 f(x)≤K 的充分条件是在端点 a、b 和所有导数为零的点上 f(x)≤K。这个结果用于通过截断幂级数逼近超越函数时确定误差界限。在这样一个“极其基础的系统”（Harrison 2006）中进行证明有一些重要的好处。首先，通过由小的无误差的演绎步骤组成的（尽管冗长）证明，可以获得高度的保证证明是有效的。其次，这些基本陈述和中间结果的形式化可以在其他任务或项目中重复使用。例如，浮点除法的形式化陈述和证明结果库可以在证明平方根或超越函数的浮点算法的其他结果时重复使用。进一步说明，Intel Itanium 的平方根算法的不同版本有很多相似之处，一个版本的正确性证明可以在对证明进行微调后应用到另一个版本上。使用 HOL 这样的证明器的第三个好处当然是，这样冗长的证明是机械地进行的，并且是演绎确定的；如果它们是手动进行的，引入人为错误的可能性将是确定的。

### 4.5 软件的形式验证

社会对软件系统的关键服务（如安全和保障）越来越依赖。软件故障可能导致严重的不良后果，包括人员伤亡、安全威胁、对敏感信息的未经授权访问、巨额财务损失、关键服务的拒绝以及安全风险。提高关键软件质量的一种方法是在传统的测试和验证方法之外，采用形式验证技术进行补充。形式验证的基本方法是生成软件必须满足的一系列条件，并通过数学证明来验证这些条件。与硬件一样，自动形式验证（以下简称形式验证）关注的是使用自动定理证明器来履行这些证明义务。

安全协议的形式验证几乎是自动定理证明在工业中的理想应用。安全协议是旨在确保在公共网络上安全进行交易的小型分布式程序。安全协议的规范相对较小且定义明确，但其验证确实是非平凡的。我们在前一节中已经提到了基于 SAT 的定理证明器在验证美国数据加密标准（DES）中的使用。作为另一个例子，Mondex“电子钱包”是一种智能卡电子现金系统，最初由 National Westminster Bank 开发，后来被出售给 MasterCard International。Schmitt＆Tonin 2007 年描述了 Mondex 协议的 Java Card 实现，该实现使用 Java 建模语言（JML）重新定义了安全属性，紧密遵循原始的 Z 规范。使用 KeY 工具（Beckert，Hanle＆Schmitt 2007 年），这是一种交互式定理证明环境，用于一阶动态逻辑，允许用户证明命令式和面向对象的顺序程序的属性。这种自动推理的应用证明了作者的话：“可以弥合规范和实现之间的差距，确保完全验证的结果”。

Denney, Fischer & Schumann 2004 描述了一种自动化 NASA 数据分析航空航天软件安全属性认证的系统。使用 Hoare 风格的程序验证技术，他们的系统生成证明义务，然后由自动定理证明器处理。然而，该过程并非完全自动化，因为许多义务必须首先简化，以提高定理证明器解决证明任务的能力。例如，其中一类义务对一个矩阵 r 进行了陈述，该矩阵在对其对角线进行更新后需要保持对称，并具有以下形式：

 原始形式：
symm(r)→symm(diag-updates(r))

简化形式（当 r 为 2x2 时）：

| (∀i)(∀j)(0≤i,j≤1→sel(r,i,j)=sel(r,j,i))→                              |
| ----------------------------------------------------------------------------- |
| (∀k)(∀l)(0≤k,l≤1→                                                      |
| sel(upd(upd(r,1,1,r11),0,0,r00),k,l)=sel(upd(upd(r,1,1,r11),0,0,r00),l,k))) |

即使在简化之后，当前的定理证明器仍然发现证明任务具有挑战性。对于更大的矩阵和更新数量（例如，一个 6×6 的矩阵有 36 个更新），任务变得难以处理，并且在任务最终落入最先进的定理证明器的范围之前，需要对义务进行进一步的预处理和简化。但值得注意的是，证明是在不使用定理证明器的任何特定功能或配置参数的情况下找到的，这些功能或配置参数将提高它们完成证明的机会。这一点很重要，因为在工业中每天应用定理证明器时，不能预设用户对证明器具有如此深入的了解。软件的形式验证仍然是一项艰巨的任务，但很难想象在面对建立成千上万个这样的义务的人类不可能的任务时，如何在没有自动推理的帮助下进行属性的认证。

在核工程领域，自动推理技术被认为已经足够成熟，可以辅助对控制核电站反应堆防护系统（RPS）的安全关键软件进行形式验证。APR-1400 核反应堆的数字控制系统的 RPS 组件使用 NuSCR 进行规定，这是一种专为核应用定制的形式规范语言（Yoo, Jee & Cha 2009）。计算树逻辑中的模型检查用于检查规范的完整性和一致性。在此之后，核工程师通过自动合成的过程生成功能块设计，并使用线性时态逻辑的模型检查技术对设计进行形式验证；这些技术还用于验证设计的多个修订和发布版本的等价性。这些模型检查工具的实施旨在使其使用尽可能简单直观，不需要对技术有深入的了解，并使用核工程师熟悉的符号。自动推理工具的使用不仅帮助设计工程师建立所需的结果，还提高了政府监管人员的信心，这些人员需要在反应堆获得运行认证之前批准 RPS 软件。

量子计算是物理学和计算机科学交叉领域中的新兴领域。预计该领域将带来非常重要的实际应用，并且考虑到量子世界的性质，我们可以放心地说，将不会缺乏哲学上的影响。这些应用需要一个坚实的基础，包括量子算法的形式化和验证以及量子信息理论中的结果。为了实现这个有价值的目标，已经在 Isabelle/HOL 中形式化了一些结果，并将其添加到其库中，以便可以供进一步的工作使用。在形式化了量子计算中的一些概念（如量子比特、量子态、量子门、纠缠、测量、量子电路的矩阵表示等）之后，工作继续进行定理和算法的形式化（Bordg、Lachnitt 和 He 2021），包括：

* 无克隆定理，该定理指出无法制作未知量子态的精确副本（Wooters 和 Zurek 1982，Dieks 1982）；
* 量子传送协议，该协议的形式化之前已经在 Coq 系统中完成（Boender、Kammüller 和 Nagarajan 2015），现在也是 Isabelle 库的一部分；该协议允许在没有量子信道的情况下，仅使用一个纠缠对和一个经典信道传输未知量子态；
* Deutsch 算法及其广义版本 Deutsch-Jozsa 算法（Deutsch 1985）的验证。Deutsch 首次证明了量子计算机可以比任何冯·诺依曼-经典-计算机更快地执行任务；
* 量子博弈论中的一些结果，例如量子囚徒困境，即经典困境的量子版本，以及不公平的量子囚徒困境，其中一个囚徒遵守经典物理定律，而另一个囚徒具有量子优势（Eisert，Wilkens 和 Lewenstein 1999）；

值得一提的是，将不公平的量子囚徒困境形式化为 Isabelle/HOL 揭示了原始的“纸笔”出版物中的一个缺陷，这个缺陷多年来一直未被发现。在 Isabelle/HOL 要求的更正式和严格的框架下，所谓的量子“奇迹移动”（如 Eisert，Wilkens 和 Lewenstein 1999 中定义的）被发现对经典策略没有优势。这个错误现在已经被纠正（Eisert，Wilkens 和 Lewenstein 2020），从而重新确立了量子策略的优势。在量子计算中进一步使用 Isabelle/HOL 包括验证量子密码协议和将量子傅里叶变换形式化添加到 Isabelle 的库中，这将为更高级的量子算法铺平道路。

### 4.6 逻辑和哲学

在 Wos、Overbeek、Lusk 和 Boyle 1992 的精神中，我们提出了一个问题：关于不同形式逻辑和精确哲学系统，以下陈述有什么共同之处？

* 多年来，模态逻辑 S4 和 S5 的蕴涵片段得到了广泛研究。作为一个开放性问题，最终证明了蕴涵 S4 有一个单一公理，以及蕴涵 S5 有几个新的最短公理（Ernst、Fitelson、Harris 和 Wos 2002）。
* L 组合子被定义为(Lx)y=x(yy)。虽然已知基于 L 的组合子 E12=((L(LL))(L(LL)))((L(LL))(L(LL)))满足 E12E12=E12，但问题仍然存在：是否存在一个更短的基于 L 的组合子满足这个性质。Glickfeld 和 Overbeek 在 1986 年证明了存在这样的组合子，即 E8=((LL)(L(LL)))(L(LL))。
* 已经发现了长度为 11 的经典等价性的 13 个最短单公理，而 XCB=e(x,e(e(e(x,y),e(z,y)),z))是唯一一个其状态尚未确定的长度为 11 的公式——它是否是一个公理？尽管经过各种研究人员的密集研究，这个问题在一个世纪之久仍然没有得到解决。最终确定了 XCB 确实是这样一个单一公理，从而结束了对等价演算的最短单公理的搜索（Wos，Ulrich 和 Fitelson 2002）。
* 坎特伯雷的圣安瑟姆在他的《思辨篇》中提出了一个关于上帝存在的著名论证。但是，最近发现了一个更简单的证明，因为它更短且使用的假设更少（Oppenheimer 和 Zalta 2011）。在同一传统中，哥德尔提出了一个上帝存在的证明，但是（Benzmüller 和 Paleo 2014）最近使用一个较弱的逻辑系统证明了相同的结果，同时解决了哥德尔证明的一个重要批评。
* 在定义罗宾斯代数的公理中，亨廷顿方程−(−(x+y)+−(x+−y))=x 可以被一个更简单的方程替代，即罗宾斯方程−(−x+y)+−(−x+−y)=x。这个猜想在 50 多年来一直未能得到证明，抵挡住了包括塔斯基在内的许多逻辑学家的攻击，直到最终在（McCune 1997）中得到证明。

我们再次问，这些结果有什么共同之处？答案是每个结果都是在自动推理程序的帮助下得到证明的。透露了这个问题的答案引发了一个新问题：如果没有使用这样的自动推理工具，解决这些未解决的问题需要多长时间？

#### 模态逻辑

模态逻辑的逻辑系统 S4 和 S5 的严格蕴涵片段分别被称为 C4 和 C5，它们的希尔伯特样式公理化假设浓缩推理作为唯一的推理规则。在 Kripke 的工作的启发下，Anderson＆Belnap（1962）使用以下 3 个公理基础发表了 C4 的第一个公理化，其中波兰符号'Cpq'代表'p→q'。

(1)

CppCCpqCrCpqCCpCqrCCpqCpr

之后提出了一个问题：是否存在一个更短的 C4 公理化，使用 2 个公理基础甚至一个单一公理？使用自动推理程序 Otter，作者 Ernst，Fitelson，Harris＆Wos（2001）肯定地回答了这两个问题。实际上，发现了几个 2 个公理基础，其中以下公理基础被证明是最短的：

(2)

CpCqqCCPCqrCCpqCsCpr

进一步的自动推理工作得到了对 C4 的单一公理的发现；该公理由 21 个符号组成，并且还证明了它是最短的公理：

(3)

CCpCCqCrrCpsCCstCuCpt

为了证明(1)的必要性和充分性，使用自动推理工具生成了一个证明循环：(1) ⇒ (3) ⇒ (2) ⇒ (1)。至于 C5，它的公理化最初在 Lemmon、A. Meredith、D. Meredith、Prior 和 Thomas（1957）的论文中发表，给出了几个 C5 的 4、3、2 和 1 公理基础，包括以下 3 公理基础：

(4)

CqCppCCpqCCqrCprCCCCpqrCpqCpq

该论文还包括 C5 已知的最短的 2 公理基础（实际上有两个，每个包含 20 个符号），但后来由 Meredith 和 Prior（1964）发现了 C5 的最短单一公理，包含 21 个符号：

(5)

CCCCCppqrCstCCtqCsCsq

再次应用自动推理策略，Ernst、Fitelson、Harris 和 Wos（2001 年）发现了几个新的基础，包括以下长度为 18 的 2 公理基础和与 Meredith 的长度为 21 匹配的六个 1 公理基础（仅下面给出其中一个）：

(6)

CppCCpqCCCCqrsrCpr

(7)

CCCCpqrCCuuqCCqtCsCpt

为了证明(4)的必要性和充分性，还使用定理证明器生成了一个证明圈：(6) ⇒ (4) ⇒ (7) ⇒ (6)。

#### 组合逻辑

在 Smullyan 1985 和 Glickfeld＆Overbeek 1986 中，我们介绍了一种迷人的组合逻辑，其中我们了解到一个由会说话的鸟类居住的魔法森林。给定任何鸟类 A 和 B，如果将鸟类 B 的名字告诉鸟类 A，那么 A 将以森林中某只鸟的名字 AB 作出回应，并且 A 对 B 的这种回应始终相同。以下是关于魔法鸟类的一些定义：

B1

一个模仿鸟 M 模仿任何鸟类，即 M 对鸟类 x 的回应与 x 对自身的回应相同，Mx=xx。

B2

如果对于任何鸟 x，A(Bx)=Cx，那么鸟 C 由鸟 A 和鸟 B 组成。换句话说，C 对 x 的响应与 A 对 B 对 x 的响应相同。

B3

一只鸟 A 喜欢另一只鸟 B，如果 A 对 B 的反应是 B；也就是说，AB=B。

这个魔法森林有两个事实：

F1

对于森林中的任何两只鸟 A 和 B，都存在一只鸟 C 将它们组合在一起。

F2

森林中有一只模仿鸟。

据传闻，森林中的每只鸟都喜欢至少一只鸟，而且至少有一只鸟不喜欢任何鸟。现在读者面临的挑战当然是仅使用 F1 和 F2 以及给定的定义（B1）-（B3）来解决这些传闻。Glickfeld＆Overbeek 1986 使用自动推理系统，仅用几秒钟就完成了这个任务，使用了参数模拟、去模拟和包含关系。对于一个更具挑战性的问题，请考虑额外的定义：

B4

如果一只鸟喜欢自己，则它是自我中心的：EE=E。

B5

如果对于任何鸟 x 和 y，以下条件成立，则鸟 L 是云雀：(Lx)y=x(yy)。

Smullyan 向我们提出了一个关于云雀的最令人惊讶的事情的证明挑战：假设除了森林中有一只云雀之外，我们没有任何其他信息。然后，证明森林中至少有一只鸟是自我中心的！下面是自动推理系统找到的证明中的重要步骤，其中'S(x,y)'代表'xy'，而(2)和(3)分别是云雀的定义和定理的否定；右侧的数字是参数模拟的应用：

> | 1  | (x1 = x1)                                                    |             |
> | ---- | -------------------------------------------------------------- | ------------- |
> | 2  | (S(S(L, x1), x2) = S(x1, S(x2, x2)))                         |             |
> | 3  | -(S(x1, x1) = x1)                                            |             |
> | 6  | (S(x1, S(S(L, S(x2, x2)), x2)) = S(S(L, x1), S(x2, x2)))     | 2 2         |
> | 8  | (S(x1, S(S(x2, x2), S(x2, x2))) = S(S(L, S(L, x1)), x2))     | 2 2         |
> | 9  | (S(S(S(L, L), x1), x2) = S(S(x1, x1), S(x2, x2)))            | 2 2         |
> | 18 | -(S(S(L, S(S(L, S(L, L)), x1)), x1) = S(S(L, S(x1,x1)), x1)) | 6 3 6 9 8 8 |
> | 19 | []                                                           | 18 1        |

经过统一应用对（18）的左右两侧进行仔细检查，发现了一个 10−L 鸟，即一个仅用云雀术语表示的 10 符号鸟，这是一个强有力的自我中心候选者。这个发现令人兴奋，因为 Smullyan 所知道的最短自我中心 L 鸟的长度为 12。随后，自动推理系统的一次运行产生了这个事实的证明，以及另一个新的重要鸟类：一个可能的自我中心 8−L 鸟！系统的几次运行最终产生了一个 22 行的证明（其中包括多达 50 个符号的术语，不包括逗号和括号），证明了((LL)(L(LL)))(L(LL))确实是自我中心的。下一个自然的问题当然是是否还有其他 8−L 自我中心鸟类，以及是否有更短的鸟类。读者可以尝试用纸和铅笔来解决这个问题，但考虑到有 429 种这样的鸟类，使用自动推理程序来尝试（或与之结合）可能更明智；这两种方法都在 Glickfeld＆Overbeek 1986 年的论文中进行了探讨。对于组合逻辑和λ-转换的更正式但无可否认较少色彩的介绍，读者可以参考 Hindley＆Seldin 1986 年的论文。

#### 等价演算

在经典等价演算中，使用命题变量和一个二元函数符号 e 来书写公式。演算有两个推理规则，分离（假言推理）和替换；这些规则可以合并为压缩分离的单一规则：从 e（s，t）和 r 中获得 tθ，其中 sθ=rθ，θ是 mgu。演算可以用以下公式公理化：

(E1)(E2)(E3)e(x,x)(reflexivity)e(e(x,y),e(y,x))(symmetry)e(e(x,y),e(e(y,z),e(x,z)))(transitivity)

我们可以放弃自反性，因为它可以从其他两个公式推导出来。这将把公理的数量减少到两个，一个自然的问题是是否存在一个等价演算的单一公理。1933 年，Łukasiewicz 找到了三个长度为 11 的公式，每个公式都可以作为演算的单一公理之一 - 这是其中之一：e(e(x,y),e(e(z,y),e(x,z))) - 他还证明了没有更短的单一公理存在。随着时间的推移，其他长度为 11 的单一公理也被发现，并且随着 Meredith、Kalman 和 Peterson 的添加，列表不断增长，总共有 14 个公式，其中 13 个已知为单一公理，还有一个公式的状态尚未确定：公式 XCB=e(x,e(e(e(x,y),e(z,y)),z))。（实际上，列表增长到了 18 个公式，但 Wos、Winker、Veroff、Smith 和 Henschen 1983 年将其减少到了 14 个。）尽管经过各种研究人员的深入研究，这个问题多年来一直是一个悬而未决的问题，即第 14 个公式 XCB 是否是等价演算的单一公理（Peterson 1977）。肯定地回答这个问题的一种方法是显示至少有一个已知的 13 个单一公理可以仅从 XCB 推导出来；另一种方法是从 XCB 推导出 3 个公理集（E1）-（E3）。Wos、Ulrich 和 Fitelson 2002 年对前者进行了尝试，他们的攻击重点集中在后者上，其中最具挑战性的任务是证明对称性。在强大的自动推理程序 Otter 的帮助下，他们对这个悬而未决的问题进行了协同、持久而非常积极的攻击。（他们的文章有时读起来像是前线的军事简报！）对于更简单的问题，推理程序可以自动找到证明；而像这样更深入和具有挑战性的问题则需要用户的指导。 推理工具的不懈应用需要在引理的设定和一系列策略的运用中提供大量的指导，包括支持集合、前向和后向包含、引理附加、公式复杂度、提示策略、比率策略、术语避免、层级饱和等等。经过大量的努力和 CPU 时间，这个悬而未决的问题最终在人和机器的共同努力下被解决，找到了一个 61 步的对称证明，之后再经过 10 次压缩分离的应用，找到了一个传递性的证明。使用去模块化阻塞和所谓的压缩策略进行的定理证明器的后续运行提供了更短的证明。这是他们 25 步证明的最后几行，这个证明首先证明了传递性，然后是对称性：

| 123 | [超链接，51，106，122] | P(e(e(e(e(x,y),e(z,y)),z),x)).                                                           |
| ----- | ------------------------ | ------------------------------------------------------------------------------------------ |
| 124 | [hyper,51,53,123]      | P(e(e(e(e(e(e(e(x,y),e(z,y)),z),x),y),z),x)).<br />z),x),u),e(v,u)),v)).                     |
| 125 | [超,51,124,123]        | P(e(e(e(x,y),x),y)).                                                                     |
| 127 | [超,51,124,108]        | P(e(e(e(e(x,e(e(e(x,y),e(z,y))<br />,z)),e(e(e(e(e(u,v),e(w,v)),w),u),<br />v6)),v7),e(v6,v7))). |
| 128 | [hyper,51,127,123]     | P(e(e(x,y),e(e(y,z),e(x,z)))).                                                           |
| 130 | [超,51,128,125]        | P(e(e(x,y),e(e(e(z,x),z),y))).                                                           |
| 131 | [超,51,128,130]        | P(e(e(e(e(e(x,y),x),z),u),e(e(y,z),u))).<br /> [超,51,131,123]                               |
| 132 | [hyper,51,131,123]     | P(e(e(x,y),e(y,x))).                                                                     |

通过一种有效的方法论和一种包括自动推理程序在关键方面提供帮助的策略，对等演算的最短单公理的搜索终于结束了。

#### 计算形而上学

Fitelson & Zalta 2007，Oppenheimer & Zalta 2011，以及 Alama，Oppenheimer，& Zalta 2015 描述了计算形而上学中自动推理的几个应用。通过将形式形而上学主张表示为公理和前提，在像 Prover9，Mace4，E-prover 系统和 Paradox 这样的自动推理环境中使用程序，研究形而上学论证的逻辑状态。在适当形式化公理和前提之后，使用模型发现程序 Mace4 来帮助验证它们的一致性。然后，使用 Prover9 自动生成了柏拉图形式理论的一些定理，二十五个可能世界理论的基本定理，莱布尼兹 1690 年未发表论文和他的模态形而上学中描述的定理，以及圣安瑟姆本体论证的完全自动化构建。在后一种应用中，Oppenheimer & Zalta 2011 将圣安瑟姆理解为从他的存在推断上帝的存在，而不是从他的可能性推断上帝的实际性。这允许一个不涉及模态运算符的形式化，涉及到一个描述的基本逻辑，三个非逻辑前提和上帝的定义。以下是形式化中的两个关键定义，作为输入到 Prover9 中，有助于表达上帝的概念：

> | none_greater 的定义：                            |
> | -------------------------------------------------- |
> | 所有 x（Object（x）->（Ex1（none_greater，x）<-> |
> | (Ex1(可想象的,x) &                               |
> | -(存在 y (Object(y) & Ex2(大于,y,x) &            |
> | Ex1(可想象的,y)))))).                            |
> |                                                  |
> | 上帝的定义：                                     |
> | 是(g,none_greater)。                             |

在代表公理形而上学中的这些和其他陈述时，Prover9 的一些语言限制需要被规避。例如，Prover9 没有明确的描述，因此这类陈述以及二阶概念必须用 Prover9 现有的一阶逻辑来表达。但是，投资是值得的，因为 Prover9 不仅提供了 Ex1(e,g)——存在一个且仅存在一个上帝的证明，而且还有一个额外的好处。仔细检查输出结果还提供了另一个例子，即自动定理证明器“推理”超过了其用户，揭示了一些逻辑机制实际上是多余的：证明只能使用描述理论的两个逻辑定理（在他们的文章中称为“定理 2”和“定理 3”）、一个非逻辑前提（称为“前提 2”）和上帝的定义来构建。我们不禁要在这里包括 Prover9 的更简洁的证明，用标准逻辑的更优雅符号表示（来自 Oppenheimer＆Zalta 2011）：

| 1. | ∼E!ιxϕ1                 | 假设，用于反证法                  |
| ---- | ---------------------------- | ----------------------------------- |
| 2. | ∃y(Gyιxϕ1&Cy)           | 从（1）推出，通过前提 2 和 MP     |
| 3. | Ghιxϕ1&Ch                | 来自（2），通过∃E，‘h’是任意的 |
| 4. | Ghιxϕ1                   | 来自（3），通过&E                 |
| 5. | ∃y(y=ιxϕ1)              | 来自（4），通过描述理论，定理 3   |
| 6. | Cιxϕ1&∼∃y(Gyιxϕ1&Cy) | 从（5）推理，根据描述理论，定理 2 |
| 7. | ∼∃y(Gyιxϕ1&Cy)         | 从（6）中，通过&E                 |
| 8. | E!ιxϕ1                   | 从（1），（2），（7）中，通过推导 |
| 9. | E!g                        | 从（8）中，通过‘g’的定义        |

在与圣安瑟姆相同的传统中，哥德尔也提供了上帝存在的本体论证明（哥德尔 1970 年，斯科特 1972 年）。两者之间的一个重要区别是哥德尔使用模态运算符来表示形而上学的可能性和必然性，当然，他还使用符号逻辑来增加推理精确度。在他的证明中，哥德尔通过使用两个公理来构建“正面属性”的概念，并引入一个定义，即“类似上帝的存在拥有所有正面属性”。这足够构建逻辑机制来证明上帝存在的可能性，◊∃xG(x)；另外三个公理和两个附加定义使得哥德尔能够进一步证明上帝不仅存在，而且这是必然的，□∃xG(x)。哥德尔的证明是使用高阶模态逻辑（HOML）的形式化，其中使用模态运算符和属性量化。哥德尔从未发表过他的证明，但他与达纳·斯科特分享了它，后者制作了下面呈现的版本，该版本摘自（Benzmüller＆Paleo 2014），并附有英文注释，以帮助读者理解其预期的解释：

**公理 A1**

∀φ[P(∼φ)≡∼P(φ)]
要么一个属性或其否定是正的，但不能同时是两者)

**公理 A2**

∀φ∀ψ[(P(φ)∧□∀x[φ(x)→ψ(x)])⊃P(ψ)]
*正属性必然随附着正属性*

**定理 T1**

∀φ[P(φ)⊃◊∃xφ(x)]
*可能存在正面属性的实例*

**定义 D1**

G(x)≡∀φ[P(φ)⊃φ(x)]
*一个类似神一样的存在拥有所有正面属性*

**公理 A3**

P(G)
*具有神一般属性是积极的*

**推论 C**

◊∃xG(x)

* 可能，上帝存在*

**公理 A4**

∀φ[P(φ)⊃□P(φ)]
*正面属性必然是正面的*

**定义 D2**

φessx≡φ(x)∧∀ψ(ψ(x)⊃□∀y(φ(y)⊃ψ(y)))
*个体的本质是它所拥有的属性，并且必然暗示着它的任何属性*

**定理 T2**

∀x[G(x)⊃Gessx]
*成为类似神一样的存在是任何类似神的存在的本质*

**定义 D3**

NE(x)≡∀φ[φessx⊃□∃yφ(y)]
*个体的必要存在是其所有本质的必要实例*

**公理 A5**

P(NE)
*必要存在是一个积极的属性*

**定理 T3**

□∃xG(x)

* 必然地，上帝存在*

最近，Benzmüller 和 Paleo（2014）利用自动定理证明器对这个证明进行了前所未有的详细和精确的分析。这些作者面临的一个重大挑战是缺乏一个能够完成这项工作的基于 HOML 的定理证明器，但是通过将逻辑嵌入到已有的定理证明器（如 LEO-II、Satallax 和反模型发现器 Nitpick）中的经典高阶逻辑（HOL）中，这个问题得以解决。他们的论文中给出了语法和语义嵌入的详细信息，其中包括通过映射、扩展和βη转换将 HOML 公式编码为 HOL 谓词。映射将 HOML 类型α、项 sα和逻辑运算符θ与相应的 HOL“提升”类型⌈α⌉、类型提升项⌈sα⌉和类型提升逻辑运算符θ∙相关联。如果μ和ο分别是个体和布尔类型，则⌈μ⌉=μ，⌈ο⌉=σ，其中σ是⌈ι→ο⌉的简写，其中ι是可能世界的类型；至于函数类型，⌈β→γ⌉=⌈β⌉→⌈γ⌉。对于类型提升项，⌈sα⌉根据 sα的结构归纳地定义，如下面的例子所示：

⌈∃(μ→ο)→οXμ.gμ→οX⌉=⌈∃(μ→ο)→ο⌉⌈Xμ.gμ→οX⌉=⌈∃(μ→ο)→ο⌉⌈Xμ⌉.⌈gμ→ο⌉⌈X⌉=∃∙⌈(μ→ο)→ο⌉X⌈μ⌉.g⌈μ→ο⌉X=∃∙(μ→σ)→σXμ.gμ→σX

类型提升的逻辑连接词，θ∙，在下面的定义中，r 是与 HOML 的可达性关系相关联的 HOL 中的新常量符号：

∼∙σ→σ=λsσλwι∼(sw)∨∙σ→σ→σ=λsσλtσλwι(sw∨tv)∀∙(α→σ)→σ=λsα→σλwι∀xαsxw□∙σ→σ=λsσλwι∀uι.∼(rι→ι→οwu)∨su)

其他连接词可以按照通常的方式定义。有效性被表示为一个λ-项，λsι→ο∀wιsw，当应用于一个项 sσ时，我们将其写作[sσ]。例如，在嵌入中，证明在 HOML 中上帝存在的可能性，◊ο→ο∃(μ→ο)→οXμ.gμ→οX，等同于在 HOL 中证明其有效性：[◊∙σ→σ∃∙(μ→σ)→σXμ.gμ→σX]μ→ο。为了证明这一点，类型提升的 HOL 表达式[◊∙∃∙Xμ.gμ→σX]然后被编码为所谓的 THF0 语法（Sutcliffe＆Benzmüller 2010），然后与上述一组等式规则一起提供给用于完成证明的证明器。

| thf(corC, 推理, |
| ----------------- |
| (v              |
| @(mdia          |
| @(mexists_ind   |
| @^[X: mu] :     |
| (g @ X)))))).   |

Benzmüller 和 Paleo 2014 年的证明在这里呈现，包括公理和定义以及其四个主要结果（T1，C，T2，T3）的推导，所有这些都是用嵌入的类型装饰的高阶逻辑符号表示的。证明步骤没有完全展开-请注意类型提升连接词的存在-并且推理步骤没有被细分到更低的细节级别。借用 Bertrand Russell（Urquhart 1994）的一句话，这样做是为了避免完全详细的自动证明给读者带来的“一种恶心感”。

| A1 | [∀∙φμ→σ.p(μ→σ)→σ(λXμ.∼∙φX))≡∙∼∙pφ]                                    | Axiom                             |
| ---- | -------------------------------------------------------------------------------------------- | ----------------------------------- |
| A2 | [∀∙φμ→σ.∀∙ψμ→σ.(p(μ→σ)→σφ ∧∙ □∙∀∙Xμ.(φX⊃∙ψX))⊃∙ψ]          | Axiom                             |
| T1 | [∀∙φμ→σ.p(μ→σ)→σφ⊃∙◊∙∃∙Xμ.φX]                                          | A1，A2（以 K 为单位）             |
| D1 | gμ→σ=λXμ.∀∙φμ→σ.p(μ→σ)→σφ⊃∙φX                                          | Definition                        |
| A3 | [p(μ→σ)→σgμ→σ]                                                                     | Axiom                             |
| C  | [◊∙∃∙Xμ.gμ→σX]                                                                     | T1, D1, A3（以 K 为单位）         |
| A4 | [∀∙φμ→σ.p(μ→σ)→σφ⊃∙□∙pφ]                                                  | Axiom                             |
| D2 | ess(μ→σ)→μ→σ=λφμ→σ.λXμ.φX ∧ ∀∙ψμ→σ.(ψX⊃∙□∙∀∙Yμ.(φY⊃∙ψY)) | Definition                        |
| T2 | [∀∙Xμ.gμ→σX⊃∙ess(μ→σ)→μ→σgX]                                                | A1, D1, A4, D2 (在 K 中)          |
| D3 | NEμ→σ=λXμ.∀∙φμ→σ.(essφX⊃∙□∙∃∙Yμ.φY)                                    | Definition                        |
| A5 | [p(μ→σ)→σNEμ→σ]                                                                    | Axiom                             |
| T3 | [□∙∃Xμ.gμ→σX]                                                                       | D1，C，T2，D3，A5（以 KB 为单位） |

除了帮助完成证明之外，自动定理证明器在发现一些新颖结果方面也起到了非常重要的作用。首先，LEO-II 证明了哥德尔的原始假设集是不一致的，证明了自己的差异成为每个实体的基本属性；由于 Dana Scott 对本质定义的重新表述，这涉及到在定义中添加了一个缺失的连词φX，Nitpick 证明了它是一致的。其次，LEO-II 和 Satallax 仅使用逻辑系统 K 证明了 C，T1 和 T2，而且 Nitpick 在 K 中找到了 T3 的反模型，从而表明完成证明的其余部分需要更多的逻辑能力。第三，使用 LEO-II 和 Satallax，证明了逻辑系统 KB（带有 Brouwer 公理的系统 K）足以建立上帝存在的必要性，即□∙∃∙Xμ.gμ→σX，这对于自动推理来说是双赢：在逻辑经济性方面获得了收益，并且在哲学上更深层次地解决了对哥德尔证明的一个重要批评，即他使用了更强的逻辑系统 S5。第四，作者还在 KB 中证明了：

(∀∙φμ→σ.∀∙Xμ.(gμ→σX⊃∙(∼∙(p(μ→σ)→σφ)⊃∙∼∙(φX)))

 以及：

∀∙Xμ.∀∙Yμ.(gμ→σX⊃∙(gμ→σY⊃∙X=∙Y)),

也就是说，上帝是完美无缺的，一神论是成立的。在这一点上，可以公正地说，任何这些结果都足以证明在确切哲学中应用自动推理的合理性。现在，先说坏消息，然后是好消息：第五，公式 sσ⊃∙□∙sσ也可以被正式推导出来，这是不幸的，因为它意味着没有偶然的真理，一切都是决定的，即没有自由意志。然而，这个问题已经通过基于菲廷和安德森的本体论论证的后续工作得到了解决（Fuenmayor & Benzmüller 2017，Fitting 2002，Anderson 1990）。

抽象对象理论（AOT）是关于抽象对象的形而上学理论（Zalta 1983）。抽象对象是科学理论所假设的对象：数字、自然法则、属性、事实状态、可能性等等。AOT 在普通对象和抽象对象之间划分了一个基本区别，普通对象被定义为 O!x=df◊E!x，抽象对象被定义为 A!x=df¬◊E!x。AOT 还提供了两种独特的谓词方式：实例化（Fx，更一般地为 Fx1...xn）和编码（xF，'x 编码 F'，更一般地为 x1...xnF）。AOT 在二阶 S5 量化模态逻辑中添加了编码，该逻辑没有身份概念，并扩展了确定描述符ιxϕ，λ表达式λx1...xnϕ∗（其中ϕ∗表示子公式不编码），以及用于复杂术语的自由逻辑（Zalta 1983，Zalta 1988）。AOT 的关键公理包括抽象对象的包容性，∃x(A!x&∀F(xF≡ϕ))，其中ϕ中没有自由的 x，并且经典λ转换，[λy1...ynϕ∗]x1...xn≡ϕ∗(x1/y1,...,xn/yn)，其中ϕ∗中没有描述符。这些公理意味着关系的包容性，∃Fn□∀x1...xn(Fnx1...xn≡ϕ∗)，其中ϕ∗中没有描述符。其他原则包括 O!x→□¬∃FxF◊xF→□xFO!x&O!y→(x=y→□∀F(Fx≡Fy))A!x&A!y→(x=y→□∀F(xF≡yF))以及ιx(A!x&∀F(xF≡ϕ))始终是明确定义的。为了让人们了解 AOT 的表达能力和应用，以下是一些 AOT 定义形而上学实体作为抽象对象并推导出有趣结果的例子（Zalta 2018）：

> **柏拉图的形式（例如三角形）**
> ΦT=dfιx(A!x&∀F(xF≡□∀x(Tx→Fx)))
>
> **莱布尼兹的概念（例如亚历山大）**
> ca=dfιx(A!x&∀F(xF≡Fa))
>
> **弗雷格数**
> 0=dfιx(A!x&∀F(xF≡¬∃yFy))
> 1=dfιx(A!x&∀F(xF≡∃y(Fy&∀z(Fz→z=y))))
> 等等。
>
> **真值**
> ⊤=dfιx(A!x&∀F(xF≡∃p(p&F=[λyp])))
> ⊥=dfιx(A!x&∀F(xF≡∃p(¬p&F=[λyp])))
>
> **情境和可能世界**
> 情境(x)=df∀F(xF→∃p(F=[λyp]))
> s⊨p=dfs[λyp]
> 可能世界(x)=df◊∀p((s⊨p)≡p)，从中可以推导出莱布尼兹原理，即如果在所有世界中为真，则 p 是必然的， ⊢□p≡∀w(w⊨p)，以及刘易斯原理，即对于世界可能的方式，存在一个以该方式存在的世界，⊢◊p≡∃w(w⊨p)
>
> **理论数学对象（例如 ZF 中的空集）**
> ∅ZF=dfιx(A!x&∀F(xF≡ZF⊨F∅))

AOT 正在不断发展中，有关该理论的进一步细节，请参阅其最新的表述之一（Zalta 2022）。AOT 的计算分析是由 Fitelson 和 Zalta（Fitelson＆Zalta 2007）首创的，他们使用了一阶系统 Prover9。使用一阶证明器对 AOT 等高阶理论进行计算调查具有固有的局限性，最好是在一个更高阶的证明器的计算框架内进行工作。然而，AOT 基于一个与经典高阶逻辑显著不同的逻辑基础，理想情况下，人们希望使用 AOT 本身的定理证明器进行工作。当然，这样做的缺点是，人们需要构建这样一个证明器，这并不是一项简单的任务。但是，人们可以通过构建 AOT 的浅层语义嵌入（SSE）来在很大程度上“近似”这样一个系统，将其嵌入到现有的高阶证明器（例如 Isabelle/HOL）中，研究人员可以忠实地表示 AOT 的公理和演绎系统（Benzmüller 2019，Kirchner 2021）。在这种设置中，Isabelle/HOL 充当 SSE 的元逻辑框架，为 AOT 提供“定制”的定理证明器。但是总会有一个权衡，构建嵌入也带来了一系列挑战。其中最重要的是，AOT 的某些方面在关系类型理论中可以很容易地进行表述，但在 Isabelle/HOL 的底层函数类型理论中重新表述时会带来挑战。例如，除非愿意面对矛盾，否则不能将 AOT 中的每个公式转换为λ项！通过一些巧妙的方法，可以使用 Isabelle/HOL 的函数演算来定义一些复杂类型，以帮助构建 AOT 的 Aczel 模型，然后在自由逻辑的背景下解释那些有问题的λ表达式，都是在复杂类型的上下文中进行的。 底线：AOT 的每个公式都可以表示为λ项，但并非所有这些项都表示；因此，保持一致性。

Isabelle/HOL 中 AOT 的 SSE 的关键方面包括使用 Aczel 模型构建嵌入模型，重现 AOT 的语法，扩展 Isabelle 的“外部”语法（以应对 AOT 推理中的某些挑战），表示 AOT 的抽象语义，指定 Hilbert ε运算符的逻辑，表示实际性运算符的逻辑，表示超内涵性，推导公理系统和演绎系统，以及其他考虑因素-详见 Kirchner 2021。其中一个显著的方面是使用抽象层（Kirchner 2017），它在确定从目标理论（此处为 AOT）的演绎系统中推导出一个陈述的可推导性方面起着重要作用。通过证明 AOT 的公理和演绎规则在 SSE 中是语义上有效的，构建了一个抽象层；在此之后，所有后续的推理（例如由 sledgehammer 进行的自动推理的 Isabelle/HOL 的主要工具）都限制在依赖于派生的公理和演绎规则本身，并且不能引用底层语义。这项工作大约需要 25,000 行 Isabelle/HOL 代码：其中约 5,000 行用于构建所需的模型结构和语义以及 AOT 的语法表示，剩下的 20,000 行用于 AOT 的逻辑推理。在嵌入中，可以以更“本地”的方式进行 AOT 的计算探索，如下面在 Isabelle/HOL 符号中所示的 9 行证明，证明没有对象既是普通的又是抽象的（Kirchner 2021）：

| 7571 | AOT 定理 partition: ❬ ¬∃x (O!x & A!x) ❭                  |
| ------ | -------------------------------------------------------------- |
| 7572 | 证明（规则 "raa-cor:2"）                                     |
| 7573 | 自动假设 ❬ ∃x (O!x & A!x) ❭                               |
| 7574 | 然后推理得到一个 a，其中 ❬ O!a & A!a ❭                     |
| 7575 | 使用"∃E" [旋转]通过爆破                                     |
| 7576 | AOT_thus ❬ p & ¬p ❭ 对于 p                                |
| 7577 | 通过 (metis "&E"(1) "Conjunction Simplification"(2) "≡E"(1) |
| 7578 | "modus-tollens:1" "oa-contingent:2" "raa-cor:3")             |
| 7579 | **qed**                                                             |

另外 1,000 行这样的计算推导得出的结果是存在着无法通过示例来区分的不同的抽象对象：∃x∃y(A!x&A!y&x≠y&∀F(Fx≡Fy))。更多的推导得出了一个重要的新发现，它提供了分析手段来确定一个λ表达式在 AOT 中是否表示：[λxϕ]↓≡□∀x∀y(∀F(Fx≡Fy)→(ϕ≡ϕ(y/x))，其中 y 在ϕ中不是自由的。而且，作为一个推论，[λxϕ]↓→∀x∀y(∀F(Fx≡Fy)→□(ϕ≡ϕ(y/x))，其中 y 在ϕ中不是自由的。在 SSE 的背景下，下面给出了 Isabelle/HOL 中的 20 行证明：

| 8761 | **AOT_theorem**"kirchner-thm-cor:1":                                                   |
| ------ | ------------------------------------------------------------------------- |
| 8762 | ❬ [λx φ{x}]↓ → ∀x∀y(∀F([F]x ≡ [F]y) → □(φ{x} ≡ φ{y})) ❭  |
| 8763 | **proof**(rule "→I"; rule GEN; rule GEN; rule "→I")                            |
| 8764 | **fix**x y                                                                     |
| 8765 | **AOT_assume**❬ [λx φ{x}]↓ ❭                                                     |
| 8766 | **AOT_hence**❬ □∀x∀y (∀F ([F]x ≡ [F]y) → (φ{x} ≡ φ{y})) ❭                 |
| 8767 | 通过 (rule "kirchner-thm:1"[THEN "≡E"(1)])                             |
| 8768 | **AOT_hence**❬ ∀x□∀y (∀F ([F]x ≡ [F]y) → (φ{x} ≡ φ{y})) ❭                 |
| 8769 | 使用 CBF[然后 "→E"]通过爆破                                            |
| 8770 | **AOT_hence**❬ □∀y (∀F ([F]x ≡ [F]y) → (φ{x} = φ{y})) ❭                     |
| 8771 | 使用"∀E"通过爆破                                                       |
| 8772 | **AOT_hence**❬ ∀y □(∀F ([F]x ≡ [F]y) → (φ{x} ≡ φ{y})) ❭                    |
| 8773 | 使用 CBF[然后 "→E"]通过爆炸                                            |
| 8774 | **AOT_hence**❬ ᷑(∀F ([F]x ≡ [F]y) → (φ{x} ≡ φ{y})) ❭                        |
| 8775 | 使用 "∀E" 通过推理                                                     |
| 8776 | **AOT_hence**❬ □∀F([F]x ≡ [F]y) → □(φ{x} ≡ φ{y}) ❭                         |
| 8777 | 使用 "qml:1"[axiom_inst] "vdash-properties:6" 通过推理                  |
| 8778 | 此外，AOT_assume ❬ ∀F([F]x ≡ [F]y) ❭                                |
| 8779 | 最终，AOT_show ❬ □(φ{x} ≡ φ{y}) ❭ 使用 "→E" "ind-nec" 通过 blast |
| 8780 | **qed**                                                                        |

在进一步建立关于基本逻辑对象、受限变量、扩展关系理解和可能世界的结果之后，计算探索可以转向戴德金德-皮亚诺算术，其中自然数的公设在一个不涉及数学原始概念和数学公理的系统中被形式化地推导出来——弗雷格定理——从而支持 AOT 可以为数学对象提供哲学基础的主张。Kirchner 2021 中的计算方法是根据之前在 Zalta 1999 中给出的证明大纲进行的，但现在在 Isabelle/HOL 中重建，以详细和形式化的方式产生公设的推导。

> * 假设 1*
>   **AOT_theorem** "0-n": ❬ [ℕ]0 ❭
>
> * 假设 2*
>   AOT 定理 "0-pred": ❬ ¬∃n [ℙ]n 0 ❭
>
> * 公设 3*
>   AOT 定理 "no-same-succ": ❬ ∀n∀m∀k([ℙ]nk & [ℙ]mk → n = m) ❭
>
> * 假设 4*
>   **AOT_theorem** "th-succ": ❬ ∀n∃!m [ℙ]nm ❭
>
> * 假设 5*
>   AOT 定理归纳：❬ ∀F([F]0 & ∀n∀m([ℙ]nm → ([F]n → [F]m)) → ∀n[F]n) ❭

上述的计算探索是使用 AOT 的二阶片段完成的，但是 SSE 可以扩展到完整的高阶逻辑 AOT（Kirchner 2021），在那里可以应用于理论数学的分析。值得强调的是，在现有证明器的高阶逻辑中嵌入目标理论不仅仅是对该理论的形式化：SSE 允许在目标理论内发现新的结果，如上所示，以及对目标理论本身的研究和进一步发展，例如将该理论放在更坚实的基础上，避免已知的悖论（Zalta 2018，Kirchner 2021）。这里描述的 AOT 的计算分析也可以被理解为在更高阶证明器框架中嵌入理论的又一个测试。它展示了这种方法的强大和便利性，自动推理的研究人员可能要认真考虑在他们的定理证明工作中使用 SSE（Benzmüller 2019）。

莱布尼兹的梦想是拥有一个普遍的特征和推理演算法，使我们能够在形而上学和道德方面像在几何学和分析学中那样进行推理；也就是说，像会计师一样解决哲学家之间的争议：“拿起笔，在算盘前坐下，如果他们愿意，可以叫来一个朋友，彼此说：让我们计算！”从自动推理的上述应用中，人们会同意研究人员的暗示，这些结果在某种程度上实现了莱布尼兹对计算形而上学的目标（Fitelson＆Zalta 2007，Benzmüller＆Paleo 2014）。

#### 过程认识论

在计算形而上学的工作中，对哲学的其他领域，如认识论，有着重要的影响。一个明显的例子是，当我们的推理中出现错误时（通过计算）被检测和纠正，我们的认识论地位得到了改善。此外，由自动推理系统产生的证明可以帮助我们更好地理解复杂的论证，并更快地看到通过引入或删除公理来修订我们的理论的后果，这是一种“假设分析”。举例来说，在简化 AOT 的基础的愿望中，可以尝试去除对理解原则的限制，但可以证明这一举动以非平凡的方式导致了悖论（Kirchner 2021）。为给定理论找到替代的公理集合可以帮助减少证明元理论结果（如完备性）所需的认识论负担。简而言之，“使用计算技术的一个巨大好处是使我们能够准确地看到我们理论的承诺是什么”（Zalta 2018）。

作为在认识论中的直接应用，非单调定理证明器可以为“计算实验室”提供基础，用于探索和实验不同的人工理性模型；定理证明器可以用来为人工理性代理装备一个推理引擎，以推理和获取关于世界的信息。在这种过程性认识论中，一个理性代理是可推翻的（即非单调的），因为新的推理导致接受新的信念，但也导致在有新信息的情况下撤回先前持有的信念。在任何给定的时间点，代理持有一组被证明的信念，但这个集合是可以修订的，并且在进一步的推理进行时处于不断变化的状态。这个模型更好地反映了我们对理性的接受概念，而不是一个所有信念都是合理的模型，即一旦获得的信念就永远不会被撤回。实际上，一组合理的信念可以被看作是合理信念的“极限”，也就是说，作为代理在寻找关于其世界的真知灼见的最终认识目标。（Pollock 1995）提供了以下定义：

如果存在一个有效的可计算函数 f，使得对于每个 n，f(n)是一个递归集合，并且满足以下两个条件，则集合是可推翻可枚举的

(∀x)(x∈A→(∃n)(∀m>n)x∈f(m))

(∀x)(x∉A→(∃n)(∀m>n)x∉f(m))

要比较概念，如果 A 是可递归枚举的，则存在一系列递归集合 Ai，使得每个 Ai 都是 A 的子集，每个 Ai 都以单调增长的方式逼近 A 的极限。但是如果 A 只是可推翻地可枚举的，则 Ai 在极限中仍然逼近 A，但可能不是 A 的子集，并且从上方和下方交替逼近 A。OSCAR 项目（Pollock 1989）的目标是构建一个关于合理性的通用理论，并在人工计算机化的合理代理中实现它。因此，该系统使用一个可推翻的自动化推理器，其操作原则是被证明的信念集应该是可推翻地可枚举的。OSCAR 已经在制作中有一段时间了，并且自动非单调推理的应用也被用来扩展其对感知和时间、因果关系和决策理论规划的推翻性推理能力（Pollock 2006）。

### 4.7 数学

自动推理的主要目标之一是数学的自动化。早期的尝试是 Automath（de Bruijn 1968），它是第一个用于检查证明和整本数学书的正确性的计算机系统，包括 Landau 的《分析基础》（van Benthem Jutting 1977）。Automath 已被更现代和功能更强大的系统所取代，其中最著名的是 Mizar。Mizar 系统（Trybulec 1979，Muzalewski 1993）基于 Tarski-Grothendieck 集合论，与 Automath 一样，由一个形式语言组成，用于编写数学定理及其证明。一旦证明用该语言编写完成，可以由 Mizar 自动检查其正确性。Mizar 的证明形式正式但易读，可以引用定义和先前证明的定理，并且在经过正式检查后，可以添加到不断增长的 Mizar 数学库（MML）（Bancerek＆Rudnicki 2003，Bancerek 等人 2018）。截至 2018 年 6 月，MML 包含约 12,000 个定义和 59,000 个定理。Mizar 语言是标准英语的子集，用于数学文本，并且具有高度结构化，以确保生成严谨且语义明确的文本。以下是 Mizar 中存在有理数 xy 的一个示例证明，其中 x 和 y 是无理数：

| theorem T2:                                                   |
| --------------------------------------------------------------- |
| 存在 x，y，使得 x 是无理数且 y 是无理数且 x 的 y 次方是有理数 |
| proof                                                         |
| set w = √2;                                                  |
| 假设：w 是无理数，根据 INT_2:44，T1；                         |
| w>0 通过 AXIOMS:22，SQUARE_1:84;                              |
| 那么 (w.^.w).^.w = w.^.(w•w) 通过 POWER:38                         |
| .= w.^.(w2) 通过 SQUARE_1:58                                  |
| .= w.^.2 通过 SQUARE_1:88                                     |
| .= w2 通过 POWER:53                                           |
| .= 2 通过 SQUARE_1:88;                                        |
| 然后根据 RAT_1:8，假设 H2: (w.^.w).^.w 是有理数；                   |
| per cases;                                                    |
| 假设 H3: w.^.w 是有理数；                                     |
| take w, w;                                                    |
| 因此根据 H1 和 H3 得出结论。                                  |
| 假设 H4: w.^.w 是无理数;                                      |
| 取 w.^.w, w;                                                  |
| 因此根据 H1、H2、H4 的论点;                                   |
| end;                                                          |

Mizar 已经验证过的证明示例包括 Hahn-Banach 定理、Brouwer 不动点定理、Kőnig 引理、Jordan 曲线定理和 Gödel 的完备性定理。Rudnicki（2004）讨论了形式化 Witt 对 Wedderburn 定理的证明的挑战：每个有限除环都是可交换的。该定理在现有的 MML 形式化中很容易得到，但证明需要进一步输入到库中，以形式化代数、复数、整数、单位根、旋群多项式和一般多项式的概念和事实。花费了几个月的努力来补充 MML 库中缺失的材料，但一旦完成，证明就可以在几天内形式化并检查正确。显然，形式化的数学事实和定义的存储库是更高级应用的先决条件。QED 宣言（Boyer 等，1994 年，Wiedijk，2007 年）有这样的目标，并且还有很多工作要做：Mizar 拥有最大的这样的存储库，但即使经过 30 年的工作，“相对于已建立的数学体系，它仍然微不足道”（Rudnicki，2004 年）。这最后一句话应被理解为对在数学自动化中增加努力的呼吁。

Mizar 的目标是帮助从业者形式化证明并检查其正确性；其他系统的目标是找到证明本身。几何学一直是早期自动化寻找证明的努力的目标。Chou（1987）使用 Wu 方法提供的代数方法和 Gröbner 基础方法证明了 500 多个几何定理，通过将假设和结论表示为多项式方程。Quaife（1992）在一阶数学中提供了另一种早期寻找证明的努力：在 Neumann-Bernays-Gödel 集合论中有 400 多个定理，在算术中有 1000 多个定理，在欧几里得几何中有一些定理以及哥德尔的不完全性定理。这种方法最好描述为半自动或“交互式”，用户需要提供大量输入来指导证明的努力。这并不奇怪，因为当将自动推理系统应用于更丰富的数学领域时，系统更多地扮演证明助手而不是定理证明器的角色。这是因为在更丰富的数学领域中，系统需要推理关于理论和高阶对象的问题，这通常使它们更深入到不可判定的领域。交互式定理证明可以说是数学中自动推理的“杀手”应用，并且正在努力构建越来越强大的推理系统，以充当专业数学家的助手。证明助手 Isabelle/HOL 为用户提供了一个环境，可以用结构化但可读性强的高阶逻辑语言进行证明，并且集成了许多功能，可以提高用户的生产力，自动化证明验证和证明查找任务，并为用户构建和管理理论层次结构提供了一种模块化的方式（Ballarin 2014）。 最近，使用自动和交互式定理证明技术，Quafie 在 Tarskian 几何中的工作已经通过证明额外的定理（其中一些需要博士级别的证明）得到了扩展，包括 Quaife 未解决的四个挑战问题，并从 Tarski 的公理中推导出 Hilbert 的 1899 年几何公理（Beeson 和 Wos 2017）。

不同的证明助手在自动推理任务的能力、支持的逻辑、对象类型、数学库的大小以及输入和输出的可读性方面提供不同的功能。可以使用一个“规范”的证明作为系统比较的基准，如（Wiedijk 2006）中所做的那样，其中十七个推理系统的作者被要求证明√2 的无理性。讨论的系统肯定比这个更强大，有些系统已经被用于辅助更高级证明的形式化，例如 Erdös-Selberg 对素数定理的证明（在 Isabelle 中约 30,000 行），四色定理的形式化（在 Coq 中 60,000 行）以及 Jordan 曲线定理（在 HOL Light 中 75,000 行）。交互式定理证明的一个里程碑是在 2012 年达到的，当时 George Gonthier 和他的团队在经过六年的努力并使用 Coq 证明助手后，完成了 Feit-Thompson 定理的 255 页证明的形式验证，该定理也被称为奇异阶定理，这是有限简单群分类中的一个重要步骤。其他更近期的成功包括解决了 Keller 的猜想（Brakensiek 等人 2022 年），度量空间的形式化（Maggesi 2018）以及有限域的形式化和分类（Chan 和 Norrish 2019）。

尽管如上所述，自动推理对数学实践的影响较小，有很多原因可以解释这一点。其中一个原因是自动定理证明器的能力不足以处理数学家通常处理的那种问题；它们目前的能力充其量只能达到大一本科数学的水平，离前沿数学研究还有很大差距。虽然目前的系统无法完全独立地证明这个难度水平的问题，但我们应该记住，目标是构建推理系统，使得“最终机器能够成为数学研究的辅助工具，而不是替代品”（王 1960 年）。在这个前提下，尽管自动推理社区继续努力满足构建越来越强大的定理证明器的宏伟挑战，数学家们现在可以从当前系统提供的一些好处中获益，包括帮助填补证明中的空白或者形式化和检查提出的证明的正确性。事实上，后者可能是一个可以帮助解决数学界当前面临的一些实际问题的应用。想想丹尼尔·戈尔斯顿和塞姆·伊尔德里姆宣布证明孪生素数猜想的情况，尽管专家们最初认为证明是正确的，但不久后发现了一个无法克服的错误。或者，想想海尔斯对开普勒猜想的证明，该猜想断言在欧几里得三维空间中，没有一种等密度大于面心立方密排的球堆放方式。海尔斯的证明包括大约 300 页的文本和大量的计算机计算。经过四年的努力，被《数学年刊》指派负责验证该证明的 12 人小组仍然对其正确性存在真正的疑虑。 托马斯·哈尔斯（Thomas Hales）是其中之一，他自愿将自己的证明形式化，并通过自动证明助手进行检查，以使他人相信其正确性（Hales 2005b，在其他互联网资源中）。他的任务确实很重，但结果对数学和自动推理社区来说都具有潜在的重要意义。当哈尔斯宣布完成 Flyspeck 项目（Hales 2014，在其他互联网资源中；Hales 2015）并构建了一个关于该猜想的形式化证明时，所有人的目光都聚集在他和他的形式化证明上：“事实上，我进行这个项目的动机远比仅仅希望消除少数评审人心中的疑虑更加复杂。事实上，我认为形式化方法对数学的长期发展至关重要。”（Hales 2006）。

根据 Church 1936a、1936b 和 Turing 1936 的推论，存在一些最短证明非常长的定理，而(Appel＆Haken 1977)中的四色定理的证明、(Gorenstein 1982)中的简单群分类的证明以及(Hales 2005a)中的开普勒猜想的证明可能只是即将出现的一些样本。正如(Bundy 2011)所说：“随着需要越来越大的证明的重要定理出现，数学面临一个困境：要么忽视这些定理，要么使用计算机来辅助证明。”

上述言论还反驳了不使用自动定理证明器的另一个论点：数学家喜欢证明定理，那为什么要让机器夺走乐趣呢？当然，答案是数学家可以通过让机器完成更繁琐和琐碎的任务来获得更多乐趣：“卓越的人们在计算的劳动中像奴隶一样浪费时间是不值得的，如果使用机器，这些计算工作完全可以交给其他人”（莱布尼兹，《论人类理解的新论文》）。如果还不相信，只需考虑手动检查哈尔斯证明中使用的 23,000 个不等式的令人警醒前景！

数学界对自动推理的接受度较低的另一个原因是，这些程序不可信，因为它们可能包含错误——软件缺陷——从而可能产生错误的结果。正式验证自动推理程序将有助于改善这一问题，特别是在证明检查器的情况下。证明程序的正确性并非易事，但对于高级数学定理的证明也是如此：冈蒂耶证明了他在四色定理形式化证明中使用的程序的正确性，但他花费了更多的精力来形式化证明中的所有图论。因此，具有讽刺意味的是，至少在这种情况下，而且肯定还有其他情况，“验证程序的正确性实际上比验证纸笔数学的正确性更容易”（Wiedijk 2006）。对于定理证明器和模型发现器，一个补充的策略是验证程序的结果，而不是程序本身。用斯拉尼（Slaney 1994）的话来说：对于数学家来说，程序可能有多少缺陷并不重要，只要它输出的证明（或模型）是正确的。因此，验证结果的责任无论是由机器还是人产生的，并通过独立的第三方进行检查（当然，这个过程可能会使用自动检查器）应该增加对证明有效性的信心。

经常有人争论自动证明过程过长且过于详细。原则上，证明可以用更基本的步骤来表达，这对数学家来说非常有益，因为这样可以要求证明助手用更简单的步骤来证明其步骤。但是证明助手也应该允许相反的情况，即通过使用数学家习惯的更高级概念、语言和符号来抽象细节并呈现结果及其证明。像（Denney 2006）中所做的利用证明的层次结构是朝着这个方向迈出的一步，但还需要更多类似的工作。让证明助手在所需的粒度级别上工作可以在证明发现过程中提供更多的洞察机会。这是一个重要的考虑因素，因为数学家对于从他们的证明中获得理解和建立事实同样感兴趣——关于这一点将在下文中详细讨论。

（Bundy 2011）提到了一个僵局，阻碍了数学界对定理证明器的广泛采用：一方面，数学家需要使用证明助手来建立一个大型的数学结果形式化库；但另一方面，他们不想使用证明器，因为没有这样的先前证明结果库可以依赖。为了打破僵局，提出了一些应用方案，其中帮助数学家搜索先前证明的定理尤为有希望。事实上，对库中结果的深思熟虑的重复使用可以导致非平凡数学问题的简洁证明，如线性代数的一些基本定理（Aransay 和 Divansón 2017）和概率论（Avigad，Hölzl 和 Serafin 2017）的证明所示。在其历史过程中，数学积累了大量的定理，数学结果的数量仍在急剧增长。2010 年，Zentralblatt MATH 涵盖了约 12 万篇新出版物（Wegner 2011）。显然，没有个别研究人员能够熟悉所有这些数学知识，除非借助自动定理证明工具以智能的方式搜索感兴趣的先前证明结果，否则应对自己不断增长的专业领域将越来越困难。解决这个问题的另一种方法是数学家利用计算社交系统（如 polymath 和 mathoverflow）中的彼此知识。将自动推理工具整合到这样的社交系统中，将通过支持“精确形式推导和数学实践中更不正式的松散交互的结合”（Martin＆Pease 2013，其他互联网资源）来增加其集体智慧的效果。

由于工业界的真实紧迫需求，自动推理在纯数学和应用数学中的一些应用更多是出于必要而非选择。在对一些基本实分析进行形式化以验证基于硬件的浮点三角函数时，哈里森（Harrison 2006，Harrison 2000）提到了进一步需要对更多纯数学进行形式化的需求-斜体是他的观点-以将他的形式化扩展到三角函数的幂级数和关于丢番图逼近的基本定理。哈里森发现“如此广泛的数学发展仅用于验证浮点切线函数是否满足某个误差界限”令人惊讶，并且从这个评论中可以预期还会有其他工业应用需要更广泛的形式化。

尽管没有最初预期的速度，自动推理正在在数学中找到应用。其中，证明的形式验证具有特殊意义，因为它不仅提供了一个可行的机制来检查人类无法完成的证明，而且还具有重新定义什么样的证明可以被接受的潜力。随着自动推理助手的使用越来越广泛，人们可以设想它们的使用遵循一定的有条不紊的顺序：首先，使用自动推理工具进行理论探索和发现。然后，通过与自动助手进行互动，从而找到证明和建立事实。最后，在提交给出版物之前，使用自动证明检查器检查所有最终证明的正确性，并通过在形式化数学存储库中创建新条目的方式使其可供数学界其他人使用。毫无疑问，自动证明助手的应用将成为数学家日常生活中的常事；使其尽早实现是自动推理社区面临的重大挑战。

除了正式验证或认证之外，证明的另一个重要方面是它所提供的解释；也就是说，它给出了为什么给定的陈述实际上是真实的原因。不用说，这是洞察力的重要来源，对于许多数学家来说，这可能是证明中最有价值的方面，因为它使他们能够更好地理解所建立的陈述的性质以及所涉及的数学理论和对象；此外，证明中使用的方法有可能适用于证明其他数学结果。因此，当涉及到构建供数学界使用的定理证明器时，也许应该更少地强调证明器作为认证者，即作为证明检查器，而更多地强调证明器作为证明求解器，即作为帮助数学家完成证明并解释步骤的助手。假设证明器足够强大，能够成功攻击数学家研究领域的证明，如果证明器也能使用数学家自己使用的相同符号、方法和证明求解技术，那将是非常理想的，尽管承认这是极具挑战性的。可以肯定的是，数学家们对这种以人为本的定理证明器会更加接受，因为证明器的工作方式与数学家相同。更多的数学家可能最初接触这样的证明器只是出于纯粹的好奇心；也就是说，只是想看看证明器是如何证明先前建立的结果的。这对数学学生来说肯定是非常有趣的，因为他们可能需要看看一个给定问题（比如来自他们的教科书）是如何解决的，并通过检查证明来学习如何自己解决它。

几乎所有现代自动定理证明器在构建证明时更像机器而不是人类（例如，基于分辨率的连接方法）。有一些系统在建立事实后，可以将证明的高级步骤以更适合人类的形式呈现，并通过将面向机器的步骤转化为人类可读格式来实现。这种方法有其优点，但也有一个重要限制：在翻译崩溃之前，我们可以继续要求多深入的解释呢？另一种替代方法可以直接解决这个问题：为什么不构建一个直接证明定理的系统，就像数学家实际上做的那样？这确实是一个非常艰巨的任务，但这个问题并不新鲜，自从自动定理证明的早期阶段以来，一小部分研究人员就一直在以各种形式进行研究，包括 Bledsoe 1977（非分辨率方法的研究），Boyer 和 Moore 1979（通过递归术语重写进行归纳），Bundy 等人 1991（自动归纳定理证明），Clarke 和 Zhao 1994（将定理证明器与符号代数系统集成），Portoraro 1994（为构建符号逻辑证明的学生提供自动建议），Portoraro 1998（以符号逻辑教师的方式进行战略性证明构建和教学），Pelletier 1998（以人类方式构建谓词演算证明），Beeson 2001（使用数学方法进行证明生成），Buchberger 等人 2016（计算机辅助自然风格数学）等等。最近，Ganesalingam 和 Gowers 2017 描述了一个定理证明器，它解决并呈现度量空间理论中的基本问题的证明，其方法很难与数学家可能证明和写的方式区分开来。为了说明，下面是该程序证明了度量空间中两个开子集的交集仍然是开集的证明，它是由程序解决和编写的：

> 证明。设 x 是 A∩B 的元素。那么 x∈A 且 x∈B。因此，由于 A 是开集，存在η>0，使得当 d(x,u)<η时，u∈A；由于 B 是开集，存在θ>0，使得当 d(x,v)<θ时，v∈B。我们希望找到δ>0，使得当 d(x,y)<δ时，y∈A∩B。但是当且仅当 y∈A 且 y∈B 时，y∈A∩B。我们知道当 d(x,y)<η时，y∈A，并且当 d(x,y)<θ时，y∈B。现在假设 d(x,y)<δ。那么如果δ≤η，则 d(x,y)<η；如果δ≤θ，则 d(x,y)<θ。因此，我们可以取δ=min{η,θ}，证毕。

尽管如此令人印象深刻，作者们承认在构建和展示这样的证明时存在许多不足和许多尚未解决的挑战，即使是对于数学中的基本问题，读者可以参考他们的文章了解详情。正如我们已经提到的，构建越来越强大的证明器，能够解决数学研究的高级领域的问题，并以人为导向的方式进行，无疑是极具挑战性的，但也是非常值得的、有前途的、有回报的研究方向。数学家们接受这种证明器将在研究和教育中都有明显的实际应用。这也将产生哲学上的影响，特别是当证明器具备了在证明过程中遇到困难时寻求帮助的能力时，我们将不得不问：是人与机器互动还是机器与人互动？与定理证明器互动的经验将扩展到一个新的领域，变得真正双向、更加亲密和丰富，更像是一种合作而不仅仅是互动：合作定理证明的黎明。

### 4.8 人工智能

自动定理证明领域自成立以来，在人工智能（AI）的更大领域中有着重要的应用。自动推理是人工智能应用的核心，例如逻辑编程（见第 4.1 节逻辑编程），其中计算与推理等同；机器人技术和问题解决（Green 1969），其中实现目标的步骤是从证明中提取的步骤；演绎数据库（Minker et al. 2014），其中事实知识被表示为原子子句和推理规则，并通过推理推断出新的事实；专家系统（Giarratano＆Riley 2004），其中人类在给定领域（例如血液感染）的专业知识被捕捉为一组 IF-THEN 推理规则，并通过应用推理规则获得结论（例如诊断）；以及其他许多应用。自动推理在人工智能中的一个应用，必然会产生深刻的哲学影响，即越来越多地使用 BDI 计算逻辑来描述智能代理和多智能体系统的信念、欲望和意图（Meyer 2014），特别是赋予未来智能系统（如决策支持系统或机器人）具备法律和道德行为。德意志逻辑可以自动化完成这个任务（Furbach et al. 2014），但鉴于目前还没有就一个普遍的德意志逻辑系统达成一致，伦理“代码设计者”需要一种方法来尝试不同的德意志系统（即，列出公理并查看从中得出的结论），以帮助他们确定特定应用所需的伦理代码；（Benzmüller et al. 2018）讨论了这方面的环境。如果在这些实验中使用实际的物理机器人，术语“德意志实验室”将是相当描述性的，尽管有些令人不安。

限制证明搜索空间一直是自动推理实现中的一个关键考虑因素，传统的人工智能搜索方法一直是定理证明器的重要组成部分。主要思想是防止证明器追求无果的推理路径。搜索的另一个方面是尝试寻找以前证明过的结果，这些结果可能对完成当前证明有用。自动识别这些结果并不容易，随着问题领域的规模和已经建立的结果数量的增长，这变得更加困难。考虑到建立大型定理库的趋势，如 Mizar 定理证明问题（MPTP）（Urban 等，2010 年，Bancerek＆Rudnicki，2003 年）或 Isabelle/HOL 数学库（Meng＆Paulson，2008 年），因此，开发在大型形式数学库中发现、评估和选择现有适当定义、前提和引理的技术是一条重要的研究线路（如 Kühlwein 等，2012 年所讨论）。

在许多其他方法中，与自动证明器形成鲜明对比的是，数学家在解决问题时将归纳启发法与演绎技巧相结合。前者帮助他们引导证明的努力，而后者使他们能够填补证明的空白。当然，所有这些都发生在人类拥有的非常庞大的知识体系存在的情况下。对于自动证明器来说，类似于数学家知识体系的对应部分是像 MPTP 这样的大型图书馆。类似于使用归纳启发法的方法是赋予定理证明器归纳、数据驱动的机器学习能力。Urban＆Vyskocil 2012 进行了一系列实验，以确定这种方法可能带来的任何收益。为此，他们使用了 MPTP 和像 E 和 SPASS 这样的定理证明器，这些证明器通过基于符号的机器学习机制进行了增强。详细的介绍和统计结果可以在上述参考文献中找到，但总结起来，引用作者的话，“这个实验展示了大型形式化数学库用于进行人工智能方法的新颖集成的非常真实且独特的好处。由于机器学习器是在以前的证明上进行训练的，它会从大型库中推荐相关的前提（根据过去的经验），这些前提对于证明新的猜想应该是有用的。”Urban 2007 讨论了 MaLARea（用于自动推理的机器学习器），这是一个同时结合归纳和演绎推理方法的元系统。MaLARea 旨在用于大型理论，即具有大量符号、定义、前提、引理和定理的问题。该系统按照循环工作，其中在给定迭代中演绎证明的结果然后由归纳机器学习组件用于限制下一个定理证明周期的搜索空间。 尽管设计简单，MaLARea 的第一个版本在 MPTP 挑战中解决了 252 个问题中的 142 个问题，表现优于经验丰富的证明者 E（解决了 89 个问题）和 SPASS（解决了 81 个问题）。机器学习的前提选择方法是在 Flyspeck 的证明库中编码的大量数学知识上进行训练的，当与定理证明器结合使用时，可以提供一种能够证明各种数学猜想的人工智能系统：在 14 个 CPU 工作站上，在 30 秒内可以自动证明 14,185 个定理中的近 40％，而无需用户的任何指导（Kaliszyk＆Urban 2014）。机器学习技术还可以成功应用于选择一阶证明构建中的良好启发式问题（Bridge，Holden＆Paulson 2014）。

自动推理和机器学习之间的关系是相互的，前者也对后者有所贡献。举一个例子，深度学习已成为应用于图像识别、语言处理等领域的首选技术，并且有理论证据证明其优于浅层学习。这样的数学证明可以使用定理证明系统（例如 Isabelle/HOL）进行形式化，同时可以为其库的增长做出贡献，形式化的结果可用于进一步的工作，旨在确保机器学习的基础（Bentkamp，Blanchette＆Klakow 2019）。

除了使用大型数学库之外，利用基于网络的语义本体是另一个可能的知识来源。Pease＆Sutcliffe 2007 年讨论了使 SUMO 本体适用于一阶定理证明的方法，并描述了将 SUMO 翻译为 TPTP 的工作。成功地对大型语义本体进行推理的一个附加好处是，这促进了自动推理方法在其他科学领域的应用。然而，充分发挥其潜力将需要更密切地对齐自动推理和人工智能的方法。

## 5. 结论

自动推理是一个成熟但仍在不断发展的领域，它在基础研究和应用之间提供了良好的互动。自动推理使用多种定理证明方法进行推导，包括分辨率、序列演算、自然演绎、矩阵连接方法、术语重写、数学归纳等。这些方法使用各种逻辑形式主义实现，如一阶逻辑、类型理论和高阶逻辑、子句和 Horn 逻辑、非经典逻辑等。自动推理程序被应用于解决形式逻辑、数学和计算机科学、逻辑编程、软件和硬件验证、电路设计、精确哲学等越来越多的问题。这种形式主义和自动推理方法的多样性导致了大量的定理证明程序的出现。为了测试这些不同程序的能力，提出了一系列问题，以便衡量它们的性能（McCharen、Overbeek 和 Wos 1976 年，Pelletier 1986 年）。TPTP（Sutcliffe 和 Suttner 1998 年，Sutcliffe 2017 年）是一个定期更新的问题库。在 CADE 会议上定期举行自动定理证明器的竞赛（Pelletier、Sutcliffe 和 Suttner 2002 年；Sutcliffe 2016 年，其他互联网资源）；竞赛的问题选自 TPTP 库，包括子句范式（CNF）、一阶范式（FOF）、类型化一阶范式（TFF）、单态化类型化高阶范式（TH0）等问题。SMT 求解器也有类似的问题库和竞赛（Barret 等人 2013 年）。

最初，计算机被用来辅助科学家进行复杂而常常乏味的数值计算。随后，机器的能力从数字领域扩展到了符号领域，通过计算机代数程序进行无限精度计算已经成为日常事务。自动推理的目标是进一步扩展机器在推理领域的能力，使它们能够作为推理助手帮助用户通过证明来建立真理。

<!--md-padding-ignore-begin-->
## Bibliography

* Alama, J., P. Oppenheimer, and E. Zalta, “Automating Leibniz’s Theory of Concepts”, *CADE 25: Proceedings of the 25th International Conference on Automated Deduction*, (Lecture Notes in Artificial Intelligence: Volume 9195), A. Felty and A. Middeldorp (eds.), Berlin: Springer, pp. 73–97.
* Anderson, C. A., 1990, “Some Emendations of Gödel’s Ontological Proof”, *Faith and Philosophy*, 7(3): 291–303.
* Anderson, A. R. and N. D. Belnap, 1962, “The Pure Calculus of Entailment”, *Journal of Symbolic Logic*, 27: 19–52.
* Andrews, P. B., 1981, “Theorem-Proving via General Matings”, *Journal of the Association for Computing Machinery*, 28 (2): 193–214.
* Andrews, P. B., M. Bishop and C. E. Brown, 2006, “TPS: A Hybrid Automatic-Interactive System for Developing Proofs”, *Journal of Applied Logic*, 4: 367–395.
* Andrews, P. B., M. Bishop, S. Issar, D. Nesmith, F. Pfenning and H. Xi, 1996, “TPS: A Theorem-Proving System for Classical Type Theory”, *Journal of Automated Reasoning*, 16 (3): 321–353.
* Appel, K., and W. Haken, 1977, “Every Planar Map is Four Colorable Part I. Discharging”, *Illinois Journal of Mathematics*, 21: 429–490.
* Aransay, J., J. Divansón, 2017, “A Formalization in HOL of the Fundamental Theorem of Linear Algebra and Its Application to the Solution of the Least Squares Problem”, *Journal of Automated Reasoning*, 58 (4): 509–535.
* Avigad, J. and J. Harrison, 2014, “Formally Verified Mathematics”, *Communications of the ACM*, 57 (4): 66–75.
* Avigad, J., J. Hölzl and L. Serafin, 2017, “A Formally Verified Proof of the Central Limit Theorem”, *Journal of Automated Reasoning*, 59 (4): 389–423.
* Baader, F. and T. Nipkow, 1998, *Term Rewriting and All That*, Cambridge: Cambridge University Press.
* Bachmair, L. and H. Ganzinger, 1994, “Rewrite-Based Equational Theorem Proving with Selection and Simplification”, *Journal of Logic and Computation*, 4 (3): 217–247.
* Ballarin, C., 2014, “Locales: A Module System for Mathematical Theories”, *Journal of Automated Reasoning*, 52 (2): 123–153.
* Bancerek, G. and P. Rudnicki, 2003, “Information Retrieval in MML”, *Proceedings of the Second International Conference on Mathematical Knowledge Management*, LNCS 2594, Heidelberg: Springer-Verlag, pp. 119-132
* Bancerek, G., C. Byliński, A. Grabowski, A. Korniłowicz, R. Matuszewski, A. Naumowicz and K. Pąk, 2018, “The Role of the Mizar Mathematical Library for Interactive Proof Development in Mizar”, *Journal of Automated Reasoning (Special Issue: Milestones in Interactive Theorem Proving)*, 61 (9): 9–31.
* Barret C., M. Deters, L. de Moura, A. Oliveras and A. Stump, 2013, “6 Years of SMT-COMP”, *Journal of Automated Reasoning*, 50 (3): 243–277.
* Basin, D. A. and T. Walsh, 1996, “A Calculus for and Termination of Rippling”, *Journal of Automated Reasoning*, 16 (1–2): 147–180.
* Bauer, A., E. Clarke and X. Zhao, 1998, “Analytica: An Experiment in Combining Theorem Proving and Symbolic Computation”, *Journal of Automated Reasoning*, 21: 295–325.
* Beckert, B., R. Hanle and P.H. Schmitt (eds.), 2007, “Verification of Object-Oriented Software: The KeY Approach”, *Lecture Notes in Artificial Intelligence* (Volume 4334), Berlin: Springer-Verlag.
* Beeson M., 2001, “Automatic Derivation of the Irrationality of e”, *Journal of Symbolic Computation*, 32 (4): 333–349.
* Beeson,M. and L. Wos, 2017, “Finding Proofs in Tarskian Geometry”, *Journal of Automated Reasoning*, 58 (1), 181–207.
* Bentkamp, A., J.C. Blanchette and D. Klakow, 2019, “A Formal Proof of the Expressiveness of Deep Learning”, *Journal of Automated Reasoning*, 63 (2), 347–368.
* Bentkamp, A., J. Blanchette, S. Tourret, P. Vukmirović and U. Waldmann, 2021, “Superposition with Lambdas”, *Journal of Automated Reasoning*, 65 (7), 893–940.
* Benzmüller, C., 2019, “Universal (Meta-) Logical Reasoning: Recent Successes”, *Science of Computer Programming*, Vol. 172, 48–62.
* Benzmüller, C. and B. W. Paleo, 2014, “Automating Gödel’s Ontological Proof of God’s Existence with Higher-Order Automated Theorem Provers”, *ECAI 2014: Proceedings of the 21st European Conference on Artificial Intelligence*, T. Schaub *et al*. (eds.), IOS Press, pp. 93–98.
* –––, 2015, “Higher-Order Modal Logics: Automation and Applications”, *Reasoning Web 2015*, LNCS 9203, W. Faber and A. Paschke (eds.), pp. 32–74.
* Benzmüller C., X. Parent and L. van der Torre, 2018, “A Deontic Logic Reasoning Infrastructure”, *CiE2018: Proceedings of the 14th Conference on Computability in Europe*, LNCS 10936, F. Manea *et al*. (eds.), pp. 60–69.
* Benzmüller C. and L. C. Paulson, 2013, “Quantified Multimodal Logics in Simple Type Theory”, *Logica Universalis*, 7 (1): 7–20.
* Benzmüller, C. and D. S. Scott, 2020, “Automating Free Logic in HOL, with an Experimental Application in Category Theory”, *Journal of Automated Reasoning*, 64 (1), 53–72.
* Benzmüller, C., A. Steen and M. Wisniewski, 2017, “Leo-III version 1.1 (system description)”, *Logic for Programming, Artificial Intelligence, and Reasoning (LPAR)—Short Papers*, T. Eiter, D. Sands, G. Sutcliffe and A. Voronkov (eds.), Kalpa Publications in Computing, Volume 1: 11–26.
* Benzmüller, C., N. Sultana, L. C. Paulson and F. Theiß, 2015, “The Higher-Order Prover LEO-II”, *Journal of Automated Reasoning*, 55 (4): 389–404.
* Berndt, B., 1985, *Ramanujan’s Notebooks* (Part I), Berlin: Springer-Verlag, pp. 25-43.
* Beyer, D., M. Dangl and P. Wendler, 2018, “A Unifying View on SMT-Based Software Verification”, *Journal of Automated Reasoning*, 60 (3): 299–335.
* Beyer, D., M. Dangl and P. Wendler, 2021, “Correction to: A Unifying View on SMT-Based Software Verification”, *Journal of Automated Reasoning*, 65 (3): 461.
* Bibel, W., 1981, “On Matrices with Connections”, *Journal of the Association of Computing Machinery*, 28 (4): 633–645.
* Blanchette, J. C., S. Böhme and L. C. Paulson, 2013, “Extending Sledgehammer with SMT Solvers”, *Journal of Automated Reasoning*, 51 (1): 109–128.
* Blanchette, J. C. and T. Nipkow, 2010, “Nitpick: A Counterexample Generator for Higher-Order Logic Based on a Relational Model Finder”, *ITP2010: First International Conference on Interactive Theorem Proving*, LNCS 6172, M. Kaufmann and L. C. Paulson (eds.), pp. 131–146.
* Bledsoe, W. W., 1977, “Non-resolution Theorem Proving”, *Artificial Intelligence*, 9: 1–35.
* Bledsoe, W. W. and M. Tyson, 1975, “The UT Interactive Prover”, *Memo ATP-17A*, Department of Mathematics, University of Texas.
* Boender, J., F. Kammüller and R. Nagarajan, 2015, “Formalization of Quantum Protocols using Coq”, *12th International Workshop on Quantum Physics and Logic (QPL)*, Oxford, arXiv preprint arXiv:1511.01568.
* Bofill, M., R. Nieuwenhuis, A. Oliveras, E. Rodriguez-Carbonell and A. Rubio, 2008, “A Write-Based Solver for SAT Modulo the Theory of Arrays”, *Formal Methods in Computer-Aided Design (FMCAD’08)*, pp. 1–8.
* Bonacina, M. P., 1999, “A Taxonomy of Theorem-Proving Strategies”, *Artificial Intelligence Today*, (Lecture Notes in Computer Science: Volume 1600), Berlin: Springer-Verlag, pp. 43–84.
* Bordg, A., H. Lachnitt and Y. He, 2021, “Certified Quantum Computation in Isabelle/HOL”, *Journal of Automated Reasoning*, 65 (5): 691–709.
* Boyer R., *et al*., 1994, “The QED Manifesto”, *CADE-12: Proceedings of the 12th International Conference on Automated Deduction*, (Lecture Notes in Artificial Intelligence: Volume 814), A. Bundy (ed.), Berlin: Springer-Verlag, pp. 238–251.
* Boyer, R. S., M. Kaufmann and J. S. Moore, 1995, “The Boyer-Moore Theorem Prover and its Interactive Enhancement”, *Computers and Mathematics with Applications*, 29: 27–62.
* Boyer, R.S. and J. S. Moore, 1979, *A Computational Logic*, New York: Academic Press.
* Brakensiek, J., M. Heule, J. Mackey and D. Narváez, 2022, “The Resolution of Keller’s Conjecture”, *Journal of Automated Reasoning*, 66 (3): 277–300.
* Bridge, J.P., S.B. Holden and L.C. Paulson, 2014, “Machine Learning for First-Order Theorem Proving”, *Journal of Automated Reasoning*, 53 (2), 141–172.
* Brown, C. E., 2012, “Satallax: An Automatic Higher-Order Prover”, *Automated Reasoning: Proceedings of the 6th International Joint Conference on Automated Reasoning (IJCAR 2012)*, LNAI 7364, B. Gramlich *et al*. (eds.), pp. 111–117, Springer-Verlag.
* –––, 2013, “Reducing Higher-Order Theorem Proving to a Sequence of SAT Problems”, *Journal of Automated Reasoning*, 51 (1): 57–77.
* Buchberger B., T. Jebelean, T. Kutsia, A. Maletzky and W. Windsteiger, 2016, “Theorema 2.0: Computer-Assisted Natural-Style Mathematics”, *Journal of Formalized Reasoning*, 9 (1): 149–185.
* Bundy, A., 2011, “Automated theorem proving: a practical tool for the working mathematician?”, *Annals of Mathematics and Artificial Intelligence*, 61 (1): 3–14.
* Bundy, A., F. van Harmelen, J. Hesketh and A. Smaill, 1991, “Experiments with Proof Plans for Induction”, *Journal of Automated Reasoning*, 7 (3): 303–324.
* Bundy, A., A. Stevens, F. van Harmelen, A. Ireland and A. Smaill, 1993, “Rippling: A Heuristic for Guiding Inductive Proofs”, *Artificial Intelligence*, 62: 185–253.
* Buresh-Oppenheim, J. and T. Pitassi, 2007, “The Complexity of Resolution Refinements”, *Journal of Symbolic Logic*, 72 (4): 1336–1352.
* Chan, HL. and M. Norrish, 2019, “Classification of Finite Fields with Applications”, *Journal of Automated Reasoning*, 63 (3): 667–693.
* Chang, C. L. and R. C. T. Lee, 1973, *Symbolic Logic and Mechanical Theorem Proving*, New York: Academic Press.
* Chou, S., 1987, *Mechanical Geometry Theorem Proving*, Dordrecht: Kluwer Academic Publishers.
* Church, A., 1936a, “An unsolvable problem of elementary number theory”, *American Journal of Mathematics*, 58 (2): 345–363.
* –––, 1936b, “A note on the Entscheidungsproblem”, *Journal of Symbolic Logic*, 1 (1): 40–41.
* –––, 1940, “A Formulation of the Simple Theory of Types”, *Journal of Symbolic Logic*, 5: 56–68.
* Claessen, K. and N. Sörensson, 2003, “New Techniques that Improve MACE-style Finite Model Finding”, *Proceedings of the CADE-19 Workshop: Model Computation – Principles, Algorithms, Applications*, P. Baumgartner and C. Fermueller (eds.)
* Clarke, E. and X. Zhao, 1994, “Combining Symbolic Computation and Theorem Proving: Some Problems of Ramanujan”, *CADE-12: Proceedings of the 12th International Conference on Automated Deduction*, (Lecture Notes in Artificial Intelligence: Volume 814), A. Bundy (ed.), Berlin: Springer-Verlag, pp. 758-763.
* Clocksin, W. F. and C. S. Mellish, 1981, *Programming in Prolog*, Berlin: Springer-Verlag.
* Colmerauer, A., H. Kanoui, R. Pasero and P. Roussel, 1973, *Un Système de Communication Homme-machine en Français*, Rapport, Groupe Intelligence Artificielle, Université d’Aix Marseille.
* Constable, R. L., S. F. Allen, H. M. Bromley, W.R. Cleaveland, J. F. Cremer, R. W. Harper, D. J. Howe, T. B. Knoblock, N. P. Mendler, P. Panangaden, J. T. Sasaki and S. F. Smith, 1986, *Implementing Mathematics with the Nuprl Proof Development System*, Englewood Cliffs, NJ: Prentice Hall.
* Cook, S. A., 1971, “The complexity of Theorem-Proving Procedures”, *Proceedings of the 3rd Annual ACM Symposium on Theory of Computing*, New York: Association for Computing Machinery, pp. 151–158.
* Coquand, T. and G. Huet, 1988, “The Calculus of Constructions”, *Information and Computation - Semantics of Data Types*, A. R. Meyer (ed.), 76 (2–3): 95–120.
* Coquand, T. and C. Paulin-Mohring, 1988, “Inductively Defined Types”, *COLOG88: Proceedings of the International Conference on Computer Logic*, P. Martin-Löf and G. Mints (eds.), LNCS 417, pp. 50–66.
* Davis, M., G. Logemann and D. Loveland, 1962, “A Machine Program for Theorem-Proving”, *Communications of the Association for Computing Machinery*, 5 (7): 394–397.
* Davis, M. and H. Putnam, 1960, “A Computing Procedure for Quantification Theory”, *Journal of the Association for Computing Machinery*, 7 (3): 201–215.
* de Bruijn, N. G., 1968, “Automath, a Language for Mathematics”, in *Automation of Reasoning (Volume 2)*, J. Siekmann and G. Wrighston (eds.), Berlin: Springer-Verlag, 1983, pp. 159–200.
* de Moura, L., 2007, “Developing Efficient SMT Solvers”, *Proceedings of the CADE-21 Workshop on Empirically Successful Automated Reasoning in Large Theories*, G. Sutcliffe, J. Urban and S. Schulz (eds.), Bremen.
* Denney, E., B. Fischer and J. Schumann, 2004, “Using Automated Theorem Provers to Certify Auto-generated Aerospace Software”, *Automated Reasoning, Second International Joint Conference (IJCAR)* (Lecture Notes in Artificial Intelligence: Volume 3097), D. Basin and M. Rusinowitch (eds.), Berlin: Springer-Verlag, pp. 198-212.
* Denney, E., J. Power and K. Tourlas, 2006, “Hiproofs: A Hierarchical Notion of Proof Tree”, *Proceedings of the 21st Annual Conference on Mathematical Foundations of Programming Semantics (MFPS XXI)* (Electronic Notes in Theoretical Computer Science, Vol. 155), pp. 341–359.
* Deutsch, D., 1982, “Quantum theory, the Church-Turing principle and the universal quantum computer”, *Proceedings of the Royal Society of London A*, 400: 97–117.
* Dieks, D., 1982, “Communication by EPR devices”, *Physics Letters A*, 92: 271–272.
* Eisert, J., M. Wilkens and M. Lewenstein, 1999, “Quantum games and quantum strategies”, *Physical Review Letters*, 83: 3077–3080.
* –––, 2020, “Erratum: quantum games and quantum strategies”, [*Physical Review Letters*, 83: 3077–3080], *Physical Review Letters*, 124: 139901.
* Ernst, Z., B. Fitelson, K. Harris and L. Wos, 2002, “Shortest Axiomatizations of Implicational S4 and S5”, *Notre Dame Journal of Formal Logic*, 43 (3): 169–179.
* Farmer, W. M., J. D. Guttman and F. J. Thayer, 1993, “IMPS: An Interactive Mathematical Proof System”, *Journal of Automated Reasoning*, 11 (2): 213–248.
* Fitelson B. and E. Zalta, 2007, “Steps Toward a Computational Metaphysics”, *Journal of Philosophical Logic*, 36 (2): 227–247.
* Fitting, M., 1990, *First-Order Logic and Automated Theorem Proving*, Berlin: Springer-Verlag.
* –––, 2002, *Types, Tableaus and Gödel’s God*. Kluwer.
* Fuenmayor, D. and C. Benzmüller, 2017, “Automating Emendations of the Ontological Argument in Intensional Higher-Order Modal Logic”, *KI 2017: Advances in Artificial Intelligence - Proceedings of the 40th Annual German Conference on AI*, LNCS 10505, G. Kern-Isberner *et al*. (eds.), pp. 114-127.
* Furbach , U., 1994, “Theory Reasoning in First Order Calculi”, *Management and Processing of Complex Data Structures*, (Lecture Notes in Computer Science Volume 777), pp. 139–156.
* Furbach, U., C. Schon and F. Stolzenburg, 2014, “Automated Reasoning in Deontic Logic”, *MIWAI2014: Proceedings of the 8th Multi-disciplinary International Workshop on Artificial Intelligence*, LNAI 8875, M. N. Murty *et al*. (eds.), pp. 57–68.
* Ganesalingam, M. and W. T. Gowers, 2017, “A Fully Automatic Theorem Prover with Human-Style Output”, *Journal of Automated Reasoning*, 58 (2): 253–291.
* Ganzinger, H., G. Hagen, R. Nieuwenhuis, A. Oliveras, C. Tinelli, 2004, “DPLL(T): Fast Decision Procedures”, *Computer Aided Verification*, (Lecture Notes in Computer Science: Volume 3114), pp. 175–188.
* Gentzen, G., 1935, “Investigations into Logical Deduction”, in Szabo 1969, pp. 68–131.
* Giarratano, J. and G. Riley, 2004, *Expert Systems: Principles and Programming*, 4th edition, Boston, MA: PWS Publishing Co.
* Gödel, K., 1970, “Appendix A: Notes in Kurt Gödel’s Hand“, in Sobel 2004, pp. 144–145.
* Gordon, M. J. C. and T. F. Melham, eds., 1993, *Introduction to HOL: A Theorem Proving Environment for Higher Order Logic*, Cambridge: Cambridge University Press.
* Gordon, M. J. C., A. J. Milner and C. P. Wadsworth, 1979, *Edinburgh LCF: A Mechanised Logic of Computation* (LNCS 78), Berlin: Springer-Verlag.
* Gorenstein, D., 1982, *Finite Simple Groups: An Introduction to their Classification* (University Series in Mathematics), New York: Plenum Press.
* Green, C., 1969, “Application of Theorem Proving to Problem Solving”, *IJCAI’69 Proceedings of the 1st international joint conference on Artificial intelligence*, San Francisco: Morgan Kaufmann, pp. 219–239
* Haack, S., 1978, *Philosophy of Logics*, Cambridge: Cambridge University Press.
* Hales, T. C., 2005a, “A proof of the Kepler Conjecture”, *Annals of Mathematics*, 162 (3): 1065–1185.
* –––, 2006, “Introduction to the Flyspeck Project”, *Dagstuhl Seminar Proceedings 05021: Mathematics, Algorithms, Proofs*, T. Coquand *et al*. (eds.)
* Hales, T. C. *et al*., 2015, “A Formal Proof of the Kepler Conjecture”, *arXiv:1501.02.02155 9 [mat.MG]*, Cornell University Library.
* Harrison, J., 2000, “High-Level Verification Using Theorem Proving and Formalized Mathematics”, *CADE-17: Proceedings of the 17th International Conference on Automated Deduction*, (Lecture Notes in Artificial Intelligence: Volume 1831), D. McAllester (ed.), Berlin: Springer-Verlag, pp. 1-6.
* –––, 2006, “Verification: Industrial Applications”, *Proof Technology and Computation*, H. Schwichtenberg and K. Spies (eds.), Amsterdam: IOS Press, pp. 161–205.
* –––, 2009, “Formalizing an Analytic Proof of the Prime Number Theorem”, *Journal of Automated Reasoning (Special Issue: A Festschrift for Michael J. C. Gordon)*, 43 (3): 243–261.
* Harrison, J. and L. Théry, 1998, “A Skeptic’s Approach to Combining HOL and Maple”, *Journal of Automated Reasoning*, 21: 279–294.
* Herbrand, J., 1930, *Recherches sur la Theorie de la Demonstration*, Travaux de la Societé des Sciences at des Lettres de Varsovie, Classe III, Science Mathématique et Physique, No. 33, 128.
* Heule, M. J. H. and O. Kullmann, 2017, “The Science of Brute Force”, *Communications of the ACM*, 60 (8): 70–79.
* Heule, M. J. H., O. Kullmann and V. W. Marek, 2016, “Solving and Verifying the Boolean Pythagorean Triples problem via Cube-and-Conquer”, *Theory and Applications of Satisfiability Testing — SAT 2016, 19th International Conference*, LNCS 9710, N. Creignou and D. Le Berre (eds.), pp. 228–245.
* Hilbert, D. and W. Ackermann, 1928, *Principles of Mathematical Logic*, L. Hammond, G. Leckie, and F. Steinhardt (trans.), New York: Chelsea Publishing Co., 1950.
* Huet, G. P., 1975, “A Unification Algorithm for Typed λ-calculus”, *Theoretical Computer Science*, 1: 27–57.
* Kaliszyk, C. and J. Urban, 2014, “Learning-Assisted Automated Reasoning with Flyspeck”, *Journal of Automated Reasoning*, 53 (2), 173–213.
* Kanckos, A., and B. W. Paleo, 2017, “Variants of Gödel’s Ontological Proof in a Natural Deduction Calculus”, *Studia Logica*, (3): 553–586.
* Kerber, M., Kohlhase and V. Sorge, 1998, “Integrating Computer Algebra into Proof Planning”, *Journal of Automated Reasoning*, 21: 327–355.
* Kirchner, D., 2017, “Representation and Partial Automation of the Principia Logico-Metaphysica in Isabelle/HOL”, *Archive of Formal Proofs*. Formal proof development. ISSN: 2150–914x. URL: http://isa-afp.org/entries/PLM.html.
* –––, 2021, *Computer-Verified Foundations of Metaphysics and an Ontology of Natural Numbers in Isabelle/HOL*, Ph.D. Dissertation, Fachbereich Mathematik und Informatik, Freie Universität Berlin.
* Kirchner, D., C. Benzmüller and E. Zalta, 2019, “Computer Science and Metaphysics: A Cross-Fertilization”, *Open Philosophy*, 2: 230–251.
* –––, 2020, “Mechanizing Principia Logico-Metaphysica in Functional Type Theory", *Review of Symbolic Logic*, 13 (1): 206–18.
* Knuth, D. and P. B. Bendix, 1970, “Simple Word Problems in Universal Algebras”, in *Computational Problems in Abstract Algebra*, J. Leech (ed.), Oxford, New York: Pergamon Press, pp. 263–297.
* Kleene, S. C., 1962, *Introduction to Metamathematics*, Amsterdam: North-Holland.
* Kovács, L. and A. Voronkov, 2013, “First-Order Theorem Proving and VAMPIRE”, *CAV 2013: Proceedings of the International Conference on Computer Aided Verification*, N. Sharygina and H. Veith (eds.), LNCS 8044, pp. 1–35.
* Kowalski, R., 1974, “Predicate Logic as a Programming Language”, *Proceedings of the International Federation for Information Processing* (Proc. IFIP ’74), Amsterdam: North Holland, pp. 569–574.
* Küchlin, W. and C. Sinz, 2000, “Proving Consistency Assertions for Automotive Product Data Management”, *Journal of Automated Reasoning* (Special Issue: Satisfiability in the Year 2000), I. P. Gent and T. Walsh (eds.), 24 (1–2): 145–163.
* Kühlwein, D., T. van Laarhoven, E. Tsivtsivadze, J. Urban and T. Heskes, 2012, “Overview and Evaluation of Premise Selection Techniques for Large Theory Mathematics”, *Automated Reasoning: 6th International Joint Conference, IJCAR 2012*, (Lecture Notes in Computer Science: Volume 7364), B. Gramlich, D. Miller and U. Sattler (eds.), Manchester, UK: Springer-Verlag, pp. 378–392.
* Lemmon, E. J., C. A. Meredith, D. Meredith, A. N. Prioir and I. Thomas, 1957, *Calculi of Pure Strict Implication*, Philosophy Dept., Canterbury University, Christchurch, New Zealand.
* Lloyd, J. W., 1984, *Foundations of Logic Programming*, Berlin: Springer-Verlag.
* Loveland, D. W., 1969, “A Simplified Format for the Model Elimination Procedure”, *Journal of the Association for Computing Machinery*, 16: 349–363.
* –––, 1970, “A Linear Format for Resolution”, *Proceedings of the IRIA Symposium on Automatic Demonstration*, New York: Springer-Verlag, pp. 147-162.
* –––, 1978, *Automated Theorem Proving: A Logical Basis*, Amsterdam: North Holland.
* Luckham, D., 1970, “Refinements in Resolution Theory”, *Proceedings of the IRIA Symposium on Automatic Demonstration*, New York: Springer-Verlag, pp. 163-190.
* Maggesi, M., 2018, “A Formalization of Metric Spaces in HOL Light”, *Journal of Automated Reasoning*, 60 (2): 237–254.
* Martin-Löf, P., 1982, “Constructive Mathematics and Computer Programming”, *Logic, Methodology and Philosophy of Science* (Volume IV), Amsterdam: North-Holland, pp. 153-175.
* Massacci, F. and L. Marraro, 2000, “Logical Cryptanalysis: Encoding and Analysis of the U.S. Data Encryption Standard”, *Journal of Automated Reasoning* (Special Issue: Satisfiability in the Year 2000), I. P. Gent and T. Walsh (eds.), 24 (1–2): 165–203.
* McCarthy, J., 1962, “Towards a Mathematical Science of Computation”, *International Federation for Information Processing Congress* (Munich, 1962), Amsterdam: North Holland, pp. 21–28.
* McCharen, J. D., R. A. Overbeek and L. A. Wos, 1976, “Problems and Experiments for and with Automated Theorem-Proving Programs”, *IEEE Transactions on Computers* 8: 773–782.
* McCune, W., 1997, “Solution of the Robbins Problem”, *Journal of Automated Reasoning*, 19 (3): 263–276.
* –––, 2001, *MACE 2.0 Reference Manual and Guide*, Mathematics and Computer Science Division, ANL/MSC-TM-249, Argonne National Laboratory.
* McRobie, M. A., 1991, “Automated Reasoning and Nonclassical Logics: Introduction”, *Journal of Automated Reasoning*, 7 (4): 447–451.
* Meng, J. and L. C. Paulson, 2008, “Translating higher-order clauses to first-order clauses”, *Journal of Automated Reasoning*, 40 (1): 35–60.
* Meredith, C. A. and A. N. Prior, 1964, “Investigations into Implicational S5”, *Z. Math. Logik Grundlagen Math.*, 10:203–220.
* Meyer, J.-J. Ch., 2014, “Logics for Intelligent Agents and Multi-Agent Systems”, *Handbook of the History of Logic, Volume 9: Computational Logic*, J. Siekmann (ed.), pp. 629–658, Elsevier.
* Miller, D. and G. Nadathur, 1988, “An Overview of λProlog”, *Proceedings of the Fifth International Logic Programming Conference — Fifth Symposium in Logic Programming*, R. Bowen and R. Kowalski (eds.), Cambridge, MA: MIT Press.
* Minker, J., D. Seipel and C. Zaniolo, 2014, “Logic and Databases: A History of Deductive Databases”, *Handbook of the History of Logic, Volume 9: Computational Logic*, J. Siekmann (ed.), pp. 571–627, Elsevier.
* Muzalewski, M., 1993, *An Outline of PC Mizar*, Fondation Philippe le Hodey, Brussels.
* Nipkow, T., L. C. Paulson and M. Wenzel, 2002, “Isabelle/HOL: A Proof Assistant for Higher-Order Logic“, LNCS Vol. 2283, pp. 207–208.
* Nivens, A. J., 1974, “A Human-Oriented Logic for Automatic Theorem Proving”, *Journal of the Association of Computing Machinery*, 21 (4): 606–621.
* Oppenheimer, P. and E. Zalta, 2011, “A Computationally-Discovered Simplification of the Ontological Argument”, *Australasian Journal of Philosophy*, 89 (2): 333–349.
* Paulson, L. C., 1990, “Isabelle: The Next 700 Theorem Provers”, *Logic and Computer Science*, P. Odifreddi (ed.), Academic Press, pp. 361–386.
* –––, 1994, *Isabelle: A Generic Theorem Prover* (Lecture Notes in Computer Science: Volume 828), Berlin: Springer-Verlag.
* –––, 2010. “Three Years of Experience with Sledgehammer, a Practical Link Between Automatic and Interactive Theorem Provers”, *PAAR-2010*, B. Konev *et al*. (eds.), pp. 1–10.
* Paulson, L. C. and K. Grabczewski, 1996, “Mechanizing Set Theory”, *Journal of Automated Reasoning*, 17 (3): 291–323.
* Pease, A. and G. Sutcliffe, 2007, “First Order Reasoning on a Large Ontology”, *Proceedings of the CADE-21 Workshop on Empirically Successful Automated Reasoning in Large Theories* (Volume 257), G. Sutcliffe and J. Urban (eds.), Bremen.
* Pelletier, F. J., 1986, “Seventy-Five Problems for Testing Automatic Theorem Provers”, *Journal of Automated Reasoning*, 2 (2): 191–216.
* –––, 1998, “Natural Deduction Theorem Proving in THINKER”, *Studia Logica*, 60 (1): 3–43.
* Pelletier, F. J., G. Sutcliffe and A. P. Hazen, 2017, “Automated Reasoning for the Dialetheic Logic RM3”, *Proceedings of the Thirtieth International Florida Artificial Intelligence Research Society Conference*, V. Rus and Z. Markov (eds.), pp. 110–115.
* Pelletier, F. J., G. Sutcliffe, and C. Suttner, 2002, “The Development of CASC”, *AI Communications*, 15 (2–3): 79–90.
* Peterson, J. G., 1977, *The Possible Shortest Single Axiom for EC-Tautologies*, Report 105, Department of Mathematics, University of Auckland.
* Pollock, J., 1989, “OSCAR: A General Theory of Rationality”, *Journal of Experimental & Theoretical Artificial Intelligence*, 1 (3): 209–226
* –––, 1995, *Cognitive Carpentry*, Cambridge, MA: Bradford/MIT Press.
* –––, 2006, “Against Optimality: Logical Foundations for Decision-Theoretic Planning in Autonomous Agents”, *Computational Intelligence*, 22(1): 1–25.
* Portoraro, F. D., 1994, “Symlog: Automated Advice in Fitch-style Proof Construction”, *CADE-12: Proceedings of the 12th International Conference on Automated Deduction*, (Lecture Notes in Artificial Intelligence: Volume 814), A. Bundy (ed.), Berlin: Springer-Verlag, pp. 802-806.
* –––, 1998, “Strategic Construction of Fitch-style Proofs”, *Studia Logica*, 60 (1): 45–66.
* Prasad, M., A. Biere and A. Gupta, 2005, “A Survey of Recent Advances in SAT-Based Formal Verification”, *International Journal on Software Tools for Technology Transfer*, 7 (2): 156–173.
* Prawitz, D., 1965, *Natural Deduction: A Proof Theoretical Study*, Stockholm: Almqvist & Wiksell.
* Quaife, A., 1992, *Automated Development of Fundamental Mathematical Theories*, Kluwer Academic Publishers.
* Robinson, J. A., 1965, “A Machine Oriented Logic Based on the Resolution Principle”, *Journal of the Association of Computing Machinery*, 12: 23–41.
* –––, 1965, “Automatic Deduction with Hyper-resolution”, *Internat. J. Comput. Math.*, 1: 227–234.
* Robinson, J. A. and A. Voronkov (eds.), 2001, *Handbook of Automated Reasoning: Volumes I and II*, Cambridge, MA: MIT Press.
* Schmitt, P. and I. Tonin, 2007, “Verifying the Mondex Case Study”, *Proceedings of the Fifth IEEE International Conference on Software Engineering and Formal Methods*, IEEE Computer Society, pp. 47–58.
* Schulz, S., 2004, “System Abstract: E 0.81”, *Proceedings of the 2nd International Joint Conference on Automated Reasoning* (Lecture Notes in Artificial Intelligence: Volume 3097), D. Basin and M. Rusinowitch (eds.), Berlin: Springer-Verlag, pp.223-228.
* Scott, D., 1972, “Appendix B: Notes in Dana Scott’s Hand”, in Sobel 2004, pp. 145–146.
* Sieg, W. and J. Byrnes, 1996, *Normal Natural Deduction Proofs (in Classical Logic)*, Report CMU-PHIL 74, Department of Philosophy, Carnegie-Mellon University.
* Slaney, J. K., 1984, “3,088 Varieties: A Solution to the Ackerman Constant Problem”, *Journal of Symbolic Logic*, 50: 487–501.
* Sobel, J. H., 2004, *Logic and Theism: Arguments for and Against Beliefs in God*, Cambridge University Press.
* Steen, A. and C. Benzmüller, 2021, “Extensional Higher-Order Paramodulation in Leo-III”, *Journal of Automated Reasoning*, 65 (6): 775–807.
* Stickel, M. E., 1992, “A Prolog Technology Theorem Prover: A New Exposition and Implementation in Prolog”, *Theoretical Computer Science*, 104: 109–128.
* Suppes, P., *et al*., 1981, “Part I: Interactive Theorem Proving in CAI Courses”, *University-Level Computer-Assisted Instruction at Stanford: 1968–1980*, P. Suppes (ed.), Institute for the Mathematical Study of the Social Sciences, Stanford University.
* Sutcliffe, G., 2017, “The TPTP Problem Library and Associated Infrastructure”, *Journal of Automated Reasoning*, 59 (4): 483–502.
* Sutcliffe, G. and C. Benzmüller, 2010, “Automated Reasoning in Higher-Order Logic Using TPTP THF Infrastructure”, *Journal of Formalized Reasoning*, 43 (4): 337–362.
* Sutcliffe, G. and C. Suttner, 1998, “The TPTP Problem Library – CNF Release v1.2.1”, *Journal of Automated Reasoning*, 21 (2): 177–203.
* Szabo, M. E. (ed.), 1969, *The Collected Papers of Gerhard Gentzen*, Amsterdam: North-Holland.
* Trybulec, A., 1978, “The Mizar Logic Information Language”, *Bulletin of the Association for Literary Linguistic Computing*, 6(2): 136–140.
* Trybulec, A. and H. Blair, 1985, “Computer Assisted Reasoning with Mizar”, *Proceedings of the 9th International Joint Conference on Artificial Intelligence*, (IJCAI-85: Volume 1), Los Angeles, pp. 26–28.
* Turing, A., 1936, “On computable numbers, with an application to the Entscheidungsproblem”, *Proceedings of the London Mathematical Society*, 42 (2): 230–265.
* Urban, J., 2007, “MaLARea: A Metasystem for Automated Reasoning in Large Theories”, *Proceedings of the CADE-21 Workshop on Empirically Successful Automated Reasoning in Large Theories*, J. Urban, G. Sutcliffe and S. Schulz (eds.), pp. 45–58.
* Urban, J., K. Hoder, A. Voronkov, 2010, “Evaluation of Automated Theorem Proving on the Mizar Mathematical Library”, *Mathematical Software – ICMS 2010: Proceedings of the Third International Congress on Mathematical Software*, Kobe, Japan, (Lecture Notes in Computer Science, Volume 6327), pp. 155–166.
* Urban, J. and J. Vyskocil, 2012, “Theorem Proving in Large Formal Mathematics as an Emerging AI Field”, *arXiv:1209.3914 [cs.AI]*, Report No. DPA-12271, Cornell University.
* Urquhart, A., 1987, “Hard Examples for Resolution”, *Journal of the ACM*, 34 (1): 209–219.
* –––, 1994 (ed.), *The Collected Papers of Bertrand Russell, Volume 4: Foundations of Logic, 1903-05*, Routledge, London and New York.
* van Benthem Jutting, L. S., 1977, *Checking Landau’s “Grundlagen” in the Automath system*, Ph.D. Thesis, Eindhoven University of Technology; published in *Mathematical Centre Tracts*, Number 83, Amsterdam: Mathematisch Centrum, 1979.
* Voronkov, A., 1995, “The Anatomy of Vampire: Implementing Bottom-Up Procedures with Code Trees”, *Journal of Automated Reasoning*, 15 (2): 237–265.
* Wallen, L. A., 1990, *Automated Deduction in Nonclassical Logics*, Cambridge, MA: MIT Press.
* Wang, H., 1960, “Proving Theorems by Pattern Recognition – I”, in *Automation of Reasoning (Volume 1)*, J. Siekmann and G. Wrightson (eds.), Berlin: Springer-Verlag, 1983, pp. 229–243.
* –––, 1960, “Toward Mechanical Mathematics”, in *Automation of Reasoning* (Volume 1), J. Siekmann and G. Wrightson (eds.), Berlin: Springer-Verlag, 1983, pp. 244-264.
* Wegner, B., 2011, “Completeness of reference databases, old-fashioned or not?”, *Newsletter of the European Mathematical Society*, 80: 50–52.
* Wiedijk, F., 2006, *The Seventeen Provers of the World*, (Lecture Notes in Artificial Intelligence: Volume 3600), F. Wiedijk (ed.), New York: Springer-Verlag.
* –––, 2007, “The QED Manifesto Revisited”, *Studies in Logic, Grammar and Rhetoric*, 10 (23): 121–133.
* Wooters, W.K. and W. H. Zurek, 1982, “A single quantum cannot be cloned”, *Nature*, 299: 802–803.
* Wos, L. (ed.), 2001, *Journal of Automated Reasoning* (Special Issue: Advances in Logic Through Automated Reasoning), 27 (2).
* Wos, L., D. Carson and G. R. Robinson, 1965, “Efficiency and Completeness of the Set of Support Strategy in Theorem Proving”, *Journal of the Association of Computing Machinery*, 12: 698–709.
* Wos, L., R. Overbeek, E. Lusk and J. Boyle, 1984, *Automated Reasoning: Introduction and Applications*, Englewood Cliffs, NJ: Prentice-Hall.
* Wos, L., D. Ulrich, and B. Fitelson, 2002, “Vanquishing the XCB Question; The Methodological Discovery of the Last Shortest Single Axiom for the Equivalential Calculus”, *Journal of Automated Reasoning*, 29 (2):107–124.
* Wos, L., S. Winker, R. Veroff, B. Smith and L. Henschen, 1983, “Questions Concerning Possible Shortest Single Axiom for the Equivalential Calculus: An Application of Automated Theorem Proving to Infinite Domains”, *Notre Dame Journal of Formal Logic*, 24: 205–223.
* Yoo, J., E. Jee and S. Cha, 2009, “Formal Modeling and Verification of Safety-Critical Software”, *IEEE Software*, 26 (3): 42–49.
* Zalta, E., 1983, *Abstract Objects: An Introduction to Axiomatic Metaphysics*, Synthese Library, SYLI Volume 160, Springer.
* –––, 1999, “Natural Numbers and Natural Cardinals as Abstract Objects: A Partial Reconstruction of Frege’s Grundgesetze in Object Theory”, *Journal of Philosophical Logic*, 28 (6): 619–660.
* –––, 2018, “How Computational Investigations Improved an Ontology”, *2018 Annual Meeting of the International Association for Computing and Philosophy*, Warsaw, Polska Akademia Nauk (PAN), Copernicus Center,
* –––, 2022, *Principia Logico-Metaphysica*, Draft/Excerpt dated September 2, 2022, URL: http://mally.stanford.edu/principia.pdf
* Zhang, L. and S. Malik, 2002, “The Quest for Efficient Boolean Satisfiability Solvers”, *CADE-18: Proceedings of the 18th International Conference on Automated Deduction*, (Lecture Notes in Artificial Intelligence: Volume 2392), A. Voronkov (ed.), Berlin: Springer-Verlag, pp. 295-313.

## Academic Tools

> | ![sep man icon](https://plato.stanford.edu/symbols/sepman-icon.jpg) | [How to cite this entry](https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=reasoning-automated). |
> | --- | --- |
> | ![sep man icon](https://plato.stanford.edu/symbols/sepman-icon.jpg) | [Preview the PDF version of this entry](https://leibniz.stanford.edu/friends/preview/reasoning-automated/) at the [Friends of the SEP Society](https://leibniz.stanford.edu/friends/). |
> | ![inpho icon](https://plato.stanford.edu/symbols/inpho.png) | [Look up topics and thinkers related to this entry](https://www.inphoproject.org/entity?sep=reasoning-automated&redirect=True) at the Internet Philosophy Ontology Project (InPhO). |
> | ![phil papers icon](https://plato.stanford.edu/symbols/pp.gif) | [Enhanced bibliography for this entry](http://philpapers.org/sep/reasoning-automated/) at [PhilPapers](http://philpapers.org/), with links to its database. |

## Other Internet Resources

### Publications

* Hales, T. C., 2005b, [*The Flyspeck Project Fact Sheet*](http://code.google.com/p/flyspeck/wiki/FlyspeckFactSheet)
* Hales, T. C., 2014, [*Flyspeck*](http://code.google.com/p/flyspeck/wiki/AnnouncingCompletion)
* Martin, U. and A. Pease, 2013, “[What does mathoverflow tell us about the production of mathematics?](http://arxiv.org/abs/1305.0904),” *Computing Research Repository*, at arxiv.org.
* Sutcliffe, G., 2014, *Proceedings of the 7th IJCAR Automated Theorem Proving System Competition (CASC-J7)*, [available online](http://www.cs.miami.edu/~tptp/CASC/J7/Proceedings.pdf), pp. 1–36.
* Sutcliffe, G., 2016, *Proceedings of the 8th IJCAR Automated Theorem Proving System Competition (CASC-J8)*, [available online](http://www.cs.miami.edu/~tptp/CASC/J8/Proceedings.pdf), pp. 1–40.

### Web Sites

* [ACL2: A Computational Logic](http://www.cs.utexas.edu/users/moore/acl2/)
* [Alfa/Agda](http://wiki.portal.chalmers.se/agda/pmwiki.php)
* [The Coq Proof Assistant](http://coq.inria.fr/)
* [CVC4](http://cvc4.cs.stanford.edu/web/)
* [E Theorem Prover](http://wwwlehre.dhbw-stuttgart.de/~sschulz/E/E.html)
* [EQP Equational Prover](http://www.cs.unm.edu/~mccune/eqp/)
* [HOL Automated Reasoning Group](http://www.cl.cam.ac.uk/research/hvg/HOL/)
* [HOL Light](http://www.cl.cam.ac.uk/~jrh13/hol-light/)
* [IMPS: An Interactive Mathematical Proof System](http://imps.mcmaster.ca/)
* [iProver](http://www.cs.man.ac.uk/~korovink/iprover/)
* [Isabelle](http://www.cl.cam.ac.uk/research/hvg/Isabelle/)
* [leanCoP](http://www.leancop.de/)
* [LEO-II](http://www.cl.cam.ac.uk/~lp15/Grants/LEO-II/index.html)
* [LEO-III](http://page.mi.fu-berlin.de/lex/leo3/)
* [Metamath](http://us.metamath.org/)
* [MetiTarski](http://www.cl.cam.ac.uk/~lp15/papers/Arith/)
* [The Minlog System](http://www.minlog-system.de/)
* [The Mizar Project](http://www.mizar.org/)
* [The Nuprl Project](http://www.nuprl.org/)
* [Paradox](http://vlsicad.eecs.umich.edu/BK/Slots/cache/www.cs.chalmers.se/~koen/paradox/)
* [Prover 9 and Mace 4](http://www.cs.unm.edu/~mccune/prover9/)
* [PVS Specification and Verification System](http://pvs.csl.sri.com/)
* [Satallax](http://www.ps.uni-saarland.de/~cebrown/satallax/)
* [Sledgehammer](https://isabelle.in.tum.de/website-Isabelle2009-1/sledgehammer.html)
* [SPASS](http://www.spass-prover.org/)
* [TPS Theorem Proving System](http://gtps.math.cmu.edu/tps.html)
* [Vampire](http://vprover.github.io/)
* [Waldmeister](http://www.waldmeister.org/)
* [Yices 2](http://yices.csl.sri.com/)
* [Z3](http://github.com/Z3Prover/)
* [The CADE ATP System Competition](http://www.cs.miami.edu/~tptp/CASC/)
* [The TPTP Problem Library for Automated Theorem Proving](http://www.cs.miami.edu/~tptp/)
* [The SMT-LIB Satisfiability Modulo Theories Library](http://smtlib.cs.uiowa.edu/)
* [The QED Manifesto](http://www.cs.ru.nl/~freek/qed/qed.html)
* [CADE: The Conference on Automated Deduction](http://www.cadeinc.org/)
* [IJAR: The International Joint Conference on Automated Reasoning](http://ijcar.org/)

## Related Entries

[artificial intelligence: logic-based](https://plato.stanford.edu/entries/logic-ai/) | [logic: classical](https://plato.stanford.edu/entries/logic-classical/) | [logic: modal](https://plato.stanford.edu/entries/logic-modal/) | [reasoning: defeasible](https://plato.stanford.edu/entries/reasoning-defeasible/)

[Copyright © 2024](https://plato.stanford.edu/info.html#c) by  
[Frederic Portoraro](http://www.symlog.ca/Profile/Fred.htm) <[*fred.portoraro@symlog.ca*](mailto:fred%2eportoraro%40symlog%2eca)>
<!--md-padding-ignore-end-->
