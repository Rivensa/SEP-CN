# 递归函数 recursive functions (Walter Dean and Alberto Naibo)

*首次发布于 2020 年 4 月 23 日；实质修订于 2024 年 3 月 1 日*

递归函数是在可计算性理论中研究的一类自然数函数，这是当代数学逻辑的一个分支，最初被称为递归函数理论。这些函数的名称来自于递归过程，即通过将相同函数应用于较小的参数来定义函数的值。

这个过程可以通过考虑熟悉的阶乘函数来说明，即如果为，则返回乘积，否则返回 1。这个函数的另一种递归定义如下：

这样的定义一开始可能看起来是循环的，因为左边的的值是通过右边的相同函数来定义的。然而，递归定义的一个特征是它们允许通过逐步“展开”直到达到（所谓的基本情况）的子句来计算所描述的函数的值。例如，可以使用前面的定义来计算的值如下：

以这种方式理解，定义方程（）为计算提供了一种算法，即计算其值的有效过程，可以由人类或机械计算设备在有限步骤内执行。正因为如此，一类类似于（）的递归定义，即一般递归函数，首先被用作递归函数理论最初建立的数学模型。

本条目的第 1 节概述了逻辑和数学的基础发展，这些发展导致了 20 世纪 30 年代递归函数理论的建立。第 2 节概述了不同形式的递归定义，包括对于这一学科的经典发展最为核心的原始递归函数和部分递归函数。第 3 节概述了可计算性理论，包括所谓的递归定理（第 3.4 节）——这一结果突显了递归对于计算的普遍性以及它与自我引用的关系。本条目的后续更新将概述在证明论和计算机科学中使用的子递归层次以及对当代可计算性理论的更全面的处理。

[附录：Ackermann-Péter 函数的历史](https://plato.stanford.edu/entries/recursive-functions/ackermann-peter.html)

---

## 1. 历史背景

递归函数理论通常被作为递归函数理论的历史章节来介绍。这个学科的根源可以追溯到二十世纪上半叶的基础性辩论。在这个背景下，出现了需要对我们通常描述为归纳或递归推理方式进行精确分析的需求，这种推理方式在数学公理理论的演绎机制中起着一定作用。本节将追溯这段历史，重点介绍不同形式的递归如何被理解为展示各种逐步算法过程的例证。

本节假设读者对第 2 节和第 3 节中介绍的一些术语有一定的了解。建议对递归函数或可计算性理论的技术概述感兴趣的读者从那里开始阅读。

### 1.1 递归定义的早期历史

递归定义的例子可以在古代和中世纪数学的历史中间断地找到。一个熟悉的例子是由递推关系给出的斐波那契数列（见第 2.1.3 节）。这个数列的定义传统上被归功于 13 世纪的意大利数学家比萨的列奥纳多（也被称为斐波那契），他在他的《阿巴西书》中引入了这个数列，涉及到人口遗传学的一个例子（见斐波那契 1202 年[2003: 404-405]）。但类似数列的描述也可以在公元前 700 年的希腊、埃及和梵文文献中找到（见，例如，辛格 1985 年）。

19 世纪中叶，对递归作为函数定义模式的普遍兴趣起源于算术分析的数值化程序和对算术基础的讨论。在这个背景下，为数论函数制定递归定义与将数学归纳作为自然数推理方式的隔离密切相关。正是在这个背景下，格拉斯曼（1861 年）和皮尔斯（1881 年）首次给出了熟悉的加法和乘法的递归定义：[1]

然后他们使用这些定义来证明这些运算的结合律、交换律和分配律。[2]

第一个使用“递归定义”这个表达的人似乎是戴德金在他的论文《什么是数和数应该是什么》（1888）中。这项工作提出了一个集合论的算术基础，戴德金证明了可以将通过原始递归定义的函数作为数学定理来陈述和证明其存在性和唯一性（§125-126）。他对加法（§135）、乘法（§147）和指数运算（§155）进行了递归定义，并通过归纳法形式地证明了这些定义的函数满足预期的代数恒等式。这两个定义后来被皮亚诺（1889）采用，并作为基于戴德金专著的直接公理化算术中的符号定义。

### 1.2 原始递归的起源

第一部专门研究递归可定义性的工作是斯科勒姆（1923）的论文

> 通过递归思维方式建立的初等算术基础，而不使用明显变量范围超过无限域。

这项工作对于后来的可计算性理论的发展至少有三个重要原因。首先，它包含了我们现在称之为原始递归函数的非正式描述。其次，它可以被看作是递归可定义性与有效计算的首次关联（另见斯科勒姆 1946 年）。第三，它证明了一系列函数和关系在原始递归中是可行的，这种方式预示了哥德尔（1931）在句法算术化中使用原始递归的方法。

Skolem 的一个明确目标是为数论提供一个逻辑基础，避免使用无限制的量词。他在这方面的灵感来自于这样的观察：在 Russell 和 Whitehead 在《数理哲学原理》（1910-1913）中给出的数论形式化中，可以在不使用“总是”（即对于所有）和“有时”（即存在）这些表达式的情况下发展大部分初等算术。这是通过将算术定理表述为他所称的函数断言来实现的。这些函数断言采用了由 Skolem 称为描述性函数的原始递归操作定义的术语之间的等式形式。例如，加法的交换性可以通过一个带有自由变量的方程式来表示。

在 Skolem 所描述的系统中，如果这样的陈述是可证明的，那么其预期解释是该主张对所有自然数普遍成立，例如。但在 Skolem 的系统中，没有办法否定这样的陈述以表达一个裸的存在主张而不产生一个证人。

Hilbert 和 Bernays（1934）（他们提供了递归的第一本教科书式的处理）后来将这样的陈述称为可验证的，因为它们的各个实例可以通过将变量替换为具体数字来进行计算验证。这是通过 Skolem 所称的“递归思维方式”来实现的。这个短语的意义在于他所描述的系统的以下特性的澄清：

1. 自然数被视为基本对象，连同继承函数一起；
2. 假设已经证明相等的描述性函数可以在其他表达式中互相替代；
3. 所有对自然数的函数和关系的定义都是通过递归给出的；
4. 函数断言，如()必须通过归纳法证明。

在这些原则作为基础的基础上，斯科勒姆展示了如何获得递归定义的前驱和减法函数、小于、可除性和素性关系、最大公约数、最小公倍数以及类似于下面 2.1.2 节中给出的有界和积的求和。

总体上，斯科勒姆考虑了我们现在称之为原始递归、值域递归、双重递归和函数类型递归的实例。然而，他没有引入一般的模式来系统地区分这些定义模式。尽管如此，斯科勒姆的处理的特性 i-iv 提供了一种将类似于()的计算与无量词一阶逻辑推导相结合的方法。因此，很容易在斯科勒姆（1923 年）中发现我们现在所知的原始递归算术系统的核心（后来由希尔伯特和伯奈斯 1934 年引入：第 7 章）。

递归函数的一般理论发展中的下一步重要步骤是由于希尔伯特计划与哥德尔（1931 年）的不完备性定理证明之间的相互作用而产生的。希尔伯特（1900 年）宣布了证明算术的一致性——最终也包括分析和集合论——面对集合论悖论的目标。他最初的计划是通过在 1910 年代和 1920 年代的一系列讲座和演讲中描述的方法来进行这样的证明，这些讲座和演讲提供了所谓有限立场的描述——即与有限组合对象相关的数学推理片段，旨在作为一致性证明的安全基础。证明本身将使用希尔伯特所称的元数学方法进行，即公理和推导的形式研究，这将发展成为现在被称为证明论的学科。

在他对这个计划的最初描述之一中，希尔伯特（1905 年）勾勒了一种证明一致性的元数学形式。例如，假设  是一个关于它可能证明以下条件的数学理论：

1. 如果对于一个系统的公理应用推理规则的  次应用不会导致矛盾，那么  次应用也不会导致矛盾。

如果能够对 i)提供数学证明，似乎可以得出结论

2. 是一致的。

然而，庞加莱（1906 年）观察到希尔伯特的方法依赖于数学归纳法从 i 推导出 ii。他反对的理由是这使得希尔伯特提出的方法在涉及到自身包含旨在形式化归纳的原则的系统的情况下成为循环的。[3]

与他的合作者阿克曼和伯奈斯一起，希尔伯特在 1910 年至 1920 年代大大发展了元数学。这为希尔伯特的（1922 年）演讲奠定了基础，他在演讲中回应了庞加莱，通过对“形式”数学归纳在客体语言中的出现和归纳作为“内容性”原理的元理论使用进行系统区分，以便推理有限组合对象的证明。也正是在这个背景下，希尔伯特将后一种归纳形式与“数字符号的构建和解构”联系起来（1922 [1996: 1123]）。

正如后续的演示所明确的那样，希尔伯特理解“数字符号”是以笔画符号书写的一元数字符号，形式为

这样的表达式可以通过添加或删除笔画来具体操作，这种操作方式与斯科勒姆的“递归思维模式”中出现的继承者和前继者的算术运算相呼应。这一观察结果进一步为希尔伯特解释了如何从递归定义中逻辑推导出类似于()的函数断言的含义，这些递归定义也用作计算它们定义的函数值的过程（希尔伯特 1920 [2013: 54–57]）。

1923 年，希尔伯特首次描述了一个递归和直观归纳的有限数论的逻辑演算（[1996: 1139]）。[4]虽然这个描述还包括了对同时递归定义的讨论，但更详细的递归方案的处理在他著名的论文“关于无穷”（1926）中给出。这包括了对希尔伯特所称的普通递归（类似于斯科勒姆对原始递归的描述）、超限递归以及更高类型的递归的讨论。（这些不同形式的递归将在关于阿克曼-彼得函数的补充中进一步讨论。）这个处理清楚地表明，希尔伯特及其合作者在发展递归可定义的一般理论方面已经迈出了实质性的步伐。然而，由于哥德尔很快提供了更精确的原始递归定义，希尔伯特的演示的影响最终减弱了。[5]

哥德尔（1931 [1986: 157–159]）的定义如下：

> 如果一个数论函数在数论函数和的基础上递归定义，则称其为递归定义。
>
> 适用于所有的。
>
> 如果存在一个有限的数论函数序列，以及这个序列的最后一个函数具有以下性质：序列中的每个函数都是通过两个前面的函数递归定义的，或者通过替换前面的任何函数得到的，或者是一个常数或后继函数...那么这个数论函数被称为递归的。如果存在一个递归函数，使得对于所有的自然数都成立，那么自然数之间的关系被称为递归的。

抛开哥德尔使用“递归”而不是“原始递归”的术语（下面将解释），这个阐述几乎与第 2.1 节中给出的原始递归函数的当代定义相吻合。哥德尔的定义还改进了他的前辈们的定义，通过明确定义原始递归定义中允许的初始函数类，并声明每个原始递归函数都具有一个由函数序列定义的定义，显示了它是如何从初始函数构建起来的。这清楚地表明原始递归函数构成了一个在自然数上的数学上明确定义的函数类（在这里表示为 PR）。哥德尔还证明了原始递归关系（通过()定义为特征函数）在命题操作和由原始递归函数限定的量化下是封闭的（见第 2.1.2 节）。

### 1.3 算术可表示性和哥德尔的第一不完全性定理

上述定义出现在哥德尔著名的（1931 年）论文《论普林西比数学及相关系统中不可判定命题》中。正如他在提出定义之前立即观察到的那样，原始递归的定义实际上是论文的主要焦点的一个离题——即证明他所称的算术公理系统的不完全性。为了理解哥德尔对递归函数理论最初发展的贡献，同时关注一些关于该系统的特点以及他对第一不完全性定理本身的证明将是有用的。（关于哥德尔的不完全性定理的更多细节和背景信息，请参见相关条目。）

通过省略类型的分支，将自怀特海德和罗素的《普林西比数学》（1910-1913）的系统转化而来，将自然数作为最低类型，并为它们添加了二阶皮亚诺公理。因此，它是一个固定的形式系统，具有有限数量的非逻辑公理，足以发展初等数论。[7]还要记住，如果一个算术系统不同时证明了对于每个自然数（其中 n 次），则称其为-一致性，并且-一致性意味着简单一致性（即一个公式及其否定不可导出）。

Gödel 证明的不完全性定理表明，如果ω-一致，则存在一个在其公理中既不可证明也不可证伪的公式。为了得到这样的公式，Gödel 首先展示了如何通过一种被称为语法算术化的技术，将-公式和证明的各种句法和元元理性质表示为原始递归关系。其次，他证明了对于每个原始递归关系，存在一个“类符号”（即公式），使得对于给定的数字元组，成立（或不成立）的事实在对应的实例中的可证明性（或可证伪性）中得到了反映，当将形式化数字（n 次）替换为-时，

根据 Gödel 在 1934 年后引入的术语，这种情况下表示。在这个表述中，他还将他之前的定义推广到说一个函数在中是可表示的，只要存在一个公式，对于所有的，

哥德尔对语法的算术化提供了一种方法，根据其语法结构为每个原始符号、术语、公式和证明分配一个唯一的哥德尔数。这种技术利用了一个熟悉的观察结果，即有限数列可以编码为素数幂的乘积，从而可以证明各种序列的相关操作是原始递归的，例如将两个数字和编码序列相连后返回结果的代码的操作。基于这一基础，哥德尔进一步表明，关于语法和证明理论的一系列概念是原始递归的，例如返回由编码的公式的否定的哥德尔数的函数可以定义为。相关递归定义的可用性自然而然地得出，因为语法概念的归纳定义，如良构公式的“数字符号的构造和解构”，是由希尔伯特描述的方式所推广的。[8]

哥德尔列表中倒数第二个定义是关系，它在哥德尔数为的公式和哥德尔数为的有限公式序列之间成立，当且仅当后者是从公理到的正确形成的推导。

iff  via a derivation  in which each  is either an axiom of  or follows from prior formulas via its rules of inference.

从()可以推出存在一个表示的公式，因此也存在一个公式

著名的哥德尔将后一个公式（用于可证明）命名为，因为可以理解为存在一个从公理到具有哥德尔数的公式的证明。但与其定义中的其他表示原始递归关系的公式不同，包含一个无界存在量词。因此，正如哥德尔小心地观察到的那样，没有理由期望它定义了一个原始递归关系。

尽管如此，正是这个公式使得哥德尔能够构造一个在中不可判定的句子。这可以通过所谓的对角线引理（参见哥德尔的不完全性定理）的应用来实现，该引理指出对于每个的公式，存在一个句子使得

当应用于公式时，对角引理产生一个句子，即所谓的哥德尔句子，使得。因此，可以解释为在中“说自己”是不可证明的。哥德尔证明了这个公式具有以下特性：

1. 如果是一致的，则；
2. 如果是ω-一致的，则。

这构成了现在被称为哥德尔第一不完备定理的内容。

这个事实的证明明确依赖于关系的可表示性，而这又源自于它的原始递归性。但是，哥德尔证明所依赖的技术也以几种额外的方式促进了可计算性理论的后续发展。首先，由于哥德尔可以对公式进行编号，我们也可以有效地枚举它们，例如按照递增顺序。这为通过索引引用公式提供了一种机制，这在柯尼（1936a）在他的正规形式定理证明中使用了类似的一般递归定义的索引化之前起到了重要的先例作用（见第 2.2.2 节）。其次，对角引理的证明还展示了如何以一种可以理解为产生康托尔对角论证的有效形式的方式对自由变量进行术语替换的形式化（参见关于自我引用的条目）。这种技术为对角化在诸如停机问题的不可判定性（图灵 1937，见第 3.2 节）、递归定理（柯尼 1938，见第 3.4 节）和层次定理（柯尼 1943，见第 3.6 节）等结果中的使用提供了重要的先例。

Gödel 的论文的另一个重要贡献在于他证明了不完备性之后，他采取了几个步骤来确定公理化理论的特征，以确保它们满足类似的不可判定性结果。除了足够强大以满足()之外，他确定的另一个要求是“公理的类和推理规则是递归可定义的”（1931 [1986: 181]）。正如他所指出的，这些特征对于泽尔梅洛-弗兰克尔集合论和一个类似于我们现在称为一阶皮亚诺算术的一阶算术系统来说都是成立的，相对于它们的公理的适当的哥德尔编号。特别是，虽然这两个系统都不能被有限公理化，但它们可以通过有限数量的方案（例如归纳或包容）来公理化，使得关系是 T 的一个公理的哥德尔编号是原始递归的。这正是因为问题中方案的成员资格是由对其结构与原始递归定义相似的公式的归纳条件决定的。

这一观察为 Gödel 随后在讲座中重新审视不完备性定理（1934）奠定了基础，其中他提出了对他最初的（1931）递归性定义的重要概括。Gödel 首先提供了对刚才描述的理论要求的以下非正式描述：

> 我们要求推理规则和有意义的公式和公理的定义是构造性的；也就是说，对于每个推理规则，都应该有一个有限的过程来确定给定的公式是否是给定的公式的直接推论（通过该规则），并且应该有一个有限的过程来确定给定的公式是否是有意义的公式或公理。（Gödel 1934: 346）

他还明确指出，他所称的“递归性”应首先被视为一个非正式的概念，他正试图使其精确化：

> 递归函数具有重要的性质，对于每组给定的参数值，函数的值可以通过有限的过程计算得出。同样，递归关系（类）是可判定的，因为对于每个给定的自然数 n 元组，可以通过有限的过程确定关系是否成立（数字是否属于该类），因为表示函数是可计算的。（哥德尔 1934 [1986: 348]）

哥德尔的一个目标是提供一个数学定义，将“递归”一词的概念推广到以前的递归可定义的例子，并尽可能地捕捉到可以通过有限过程计算的函数类。这导致他定义了所谓的一般递归函数（见第 1.5 节），而这一定义又在形成丘奇论题（见第 1.6 节）中起到了重要作用。然而，哥德尔的定义也发生在其他工作的背景下，这些工作受到希尔伯特对不同形式的递归定义的最初考虑的启发。现在检查这些发展将是有用的。

### 1.4 递归函数

在（1926 年）的时候，希尔伯特已经预见到可以制定函数的定义，其值可以以递归的方式计算，但它们本身不是原始递归的。为了说明如何获得这样的定义，他提出了一个启发性的论证，涉及以下函数序列：

⋰

这个序列中的函数被定义为通过原始递归得到的，其中包括一个适当的基本情况。因此，考虑函数，其第一个参数表示函数在先前列表中的位置。对于固定的，可以通过首先构造的定义，然后在上面评估它来有效地计算的值。但是，也很容易看出，对于足够大的，最终将支配。这反过来表明不能通过有限次数的原始递归方案来定义。因此，本身不是原始递归的。

刚刚给出的规范并不具有递归定义的形式。但是可以以一种推广方案的格式定义类似的函数。一种方法是使用 Skolem 和 Hilbert 都考虑过的高类型的简单递归。为此，考虑迭代函数，它以函数和自然数作为参数，并返回作为与自身的 i 次组合得到的函数。换句话说，具有类型

The specification of  just given does not have the form of a recursive definition. But it is possible to define similar functions in a manner which generalizes the format of the scheme (). One means of doing so is to use a simple form of recursion at higher types as considered by both Skolem and Hilbert. To this end, consider the *iteration functional*  which takes as arguments a function  and a natural number  and returns the function which is obtained as *i*-fold composition of  with itself. In other words,  has the type

这样的函数可以形式化地定义如下：

这里表示恒等函数（即 ）和

表示我们更常规地表达为 —即，

或者与组合的结果。

现在我们可以定义一个以自然数为输入并返回类型为的函数，如下所示：

由于的值是一个函数，这里和

应该将它们都理解为依赖于隐含抽象变量的函数类型。换句话说，如果我们采用递归的符号表示法，那么我们应该将这些术语视为抽象的函数和

在这些定义确定之后，现在可以验证当变化时，对应于增长速度递增的函数序列如下：

⋰

这提供了一种定义现在通常称为 Péter 函数（或者也称为 Ackermann-Péter 函数）的方法。它与具有相同的增长阶数，并且可以通过上面概述的论证方式证明不是原始递归的（参见，例如，Péter 1967: ch. 9）。

与函数序列一样，每个函数对于每个具体的数字都是可计算的。然而，为了统一地定义这个函数，我们不得不使用递归定义函数，而这个函数本身是通过对类型进行递归定义的。因此，问题是是否也可以通过对自然数本身进行递归的形式来定义一个在外延上等价的函数。

Ackermann（1928a）对于稍微复杂一些的 Ackermann 函数（在补充中描述）以及 Péter（1935）的一个函数直接给出了肯定的答案。特别地，可以通过 Ackermann 最初所称的同时递归来制定一个与外延上等价的函数的定义，如下所示：[9]

在这个定义中的第三个子句中，通过的值是根据的值来确定的。因此，很可能不会立即明显地看出定义（）描述了一种计算值的算法，该算法始终以计算（）所示的方式终止。然而，需要注意的是，当我们展开定义的右侧子句时，要么减少，要么保持不变并减少。因此，每次达到时，将开始减少，直到最终达到基本情况。因此，尽管的值增长非常迅速（例如，），但仍然可以合理地将（）视为满足哥德尔的要求，即递归定义的函数可以通过有限过程计算。

对（）所示的这种替代递归方案的系统考虑是由彼得（1932）发起的。正是她引入了术语“原始递归”来描述哥德尔方案（）给出的函数类，这个选择在克利尼（1936a）采纳后成为标准。彼得还证明了原始递归函数是值递归（参见第 2.1.3 节），多重递归和一个变量的嵌套递归（请参见补充说明）。因此，“原始”这个术语的选择不应被理解为减少原始递归函数类的丰富性。相反，它标志着像希尔伯特、阿克曼和彼得这样的理论家从他们的研究开始就将像（）这样导致更复杂的计算过程的定义也视为“递归”。

1930 年代，彼得的工作还导致了她的书（彼得 1967 年），其原始德文版《递归函数》（1951 年）是第一本专门研究递归函数的专著。与格雷戈尔奇克（1953 年）的后续工作一起，这些发展也激发了对各种次递归层次的研究，这些层次在证明论和计算机科学中后来发挥了作用。[10]

### 1.5 一般递归函数

哥德尔在 1934 年对递归的讨论的直接来源不是阿克曼或彼得的工作，而是与赫尔布兰德的私人通信。赫尔布兰德在之前的两篇论文（1930 年，1932 年）中提出了一种相关的推广递归定义的方法。哥德尔对赫尔布兰德建议的非正式描述如下：[11]

> 如果表示一个未知的函数，而和是已知的函数，并且如果在最一般的方式中将的和相互替换，并且将得到的表达式的某些对等式，那么如果得到的函数方程组有且仅有一个解，那么是一个递归函数。（哥德尔 1934 [1986: 308]）

作为一个例子，考虑以下一组方程：

在这种情况下，由辅助函数指定的“未知”函数以一种只在方程的左侧（除了基本情况）出现一次的方式进行了说明。尽管如此，这样的方程组与原始递归定义不同，因为它没有指定一种通过“拆解”来计算的唯一方法，这种方法可以通过计算（）来说明。

在一般情况下，确实没有保证存在一个满足这样定义的唯一外延函数。但在这个例子中，可以证明是满足系统方程中的唯一类型函数。这可以通过考虑以下计算来说明：

正如哥德尔所指出的，这样的计算可以理解为无量词一阶逻辑的推导，其中允许的规则只有将数字替换为变量和将方程右侧的项替换为已经推导出相应等式的数字。

哥德尔引入了递归的概念来描述以这种方式定义的函数。根据奥迪弗雷迪（1989 年：第 I.2 章）的现代化呈现，可以基于以下初始定义来指定这个类别：[12]

**定义 1.1**

1. 数字类是包含 0 并且在后继函数下封闭的最小集合。我们用表示数字 n 的次数。
2. 术语类是包含数字、变量并且在操作下封闭的最小集合，其中是术语，是原始的 n 元函数符号。
3. 如果和是术语，并且是形式为的，则是一个方程。
4. 一组方程是一个有限的方程集。将用来表示包含基本函数符号和变量的方程系统。

Herbrand（1932）通过要求系统有解并且与对于每个解相符，给出了一个对于数论函数被方程系统定义的语义特征。他还建议这个事实应该以直观的方式证明，这可能会产生一个计算的有效过程。然而，他没有指定一个形式系统来进行这样的证明。因此，Gödel（基本上）建议用以下的句法替换 Herbrand 的定义：

定义 1.2：如果存在一组方程，使得如果是最后一个方程中的最左边的函数符号，则函数是一般递归的。

当且仅当方程

可以从组成的方程中推导出，通过以下两个规则：

R1:

在方程中，将特定变量的每个出现替换为一个数字。

R2:

如果已经推导出，则可以将替换为方程右侧的数字。

在这种情况下，我们说定义了。

可以验证方程组()和推导()满足上述要求，从而说明如何使用一组通用递归方程机械计算。然而，某些系统（例如）在自然数上不满足，而其他系统（例如）不唯一满足。 Gödel 对通用递归性的定义的一个明显缺点是，没有明显的方法来确定给定的方程组是否确定唯一的函数（即使只是部分定义）。这是为什么在计算理论的后续发展中，Gödel 的特征化已被其他等价的定义（如 Kleene 的部分递归函数）所取代的原因之一（参见第 2.2 节）。

### 1.6 Church 的论题

通过通过定义 1.2 对递归性的非正式描述进行形式化，哥德尔成功地制定了一个定义，该定义包含了原始递归方案（），阿克曼-彼得函数的定义，以及希尔伯特考虑的其他几个方案。哥德尔对一般递归性的定义因此也定义了一个类型为的函数类 GR，该类适当地包含了原始递归函数 PR。此外，我们现在知道，在（事实上在更弱的算术系统中）可表示的函数类对应于一般递归函数，而不是原始递归函数。因此，将一个形式系统的公理（哥德尔数）集合的假设弱化为要求它们是一般递归的，而不是原始递归的，确实提供了哥德尔设想的第一不完全性定理的一般化方式。

GR 的定义在历史上也具有重要意义，因为它是最早的几个等价（几乎同时的）定义之一，最初被称为递归函数，但现在通常被称为可计算函数（见第 2.2 节）。这些发展也为在计算性理论作为一个独立学科开始之前的递归可定义性研究的最后两章之一做出了贡献，即孤立和最终采用了现在被称为 Church 的论题。

Church 的论题对应于这样一个主张：可以通过有限的机械过程计算的函数类（或者，传统上说，有效计算的函数类）与一般递归函数类完全一致，即

(CT)

如果且仅如果是有效计算的。

有关 CT 所声称分析的有效可计算函数的概念，作者在其注释中存在一些历史变化。（有关此观点的更多信息，请参见 Church's Thesis 和 Computational Complexity Theory 的条目。）尽管如此，普遍认同这个概念近似于由算法计算的函数，并且对该论题的适当理解要求必须以非正式方式理解后者的概念。[14]

在这种理解下，可能会认为哥德尔在 1934 年已经提出了 Church's Thesis 的一个版本。然而，他并没有在 Church 首次明确表述之后立即支持它。[15]由于周围的历史复杂，记录以下观察作为第 2 和第 3 节的序言将是有用的。[16]

哥德尔在 1934 年春季访问普林斯顿期间发表了这些讲座（哥德尔 1934）。在那个时候，Church 与他的学生 Kleene 和 Rosser 一起，在发展现在被称为无类型λ演算的形式系统方面取得了重大进展。该系统还提供了一种将自然数表示为形式术语（即所谓的 Church 数）的方法。这导致了一个类似于()的λ可定义函数的概念。Church 的定义也表征了一类类似于 GR 的λ可定义函数。在这个时期，Kleene 通过展示如何在λ演算中实现原始递归，证明了广泛的数论函数包含在内。这最终导致 Church 在 1934 年初提出λ可定义函数与具有他所称之为“有效可计算性”的属性的函数相一致。[17]

因此，一个自然的猜想是，λ-可定义性在外延上与一般递归性相一致。与（CT）不同，（CT）将一个非正式特征化的函数类与具有精确数学定义的函数类等同起来，该陈述潜在地可以进行形式上的证明。Church（1936b）给出了这样的证明，并由 Kleene（1936b）更详细地阐述，这是 Kleene（1952：sec. 60，sec. 62）引用的几个外延等价结果中的第一个，这些结果最终成为他所提出的“Church 论题”的证据。

Church 的论题在当代可计算性理论中具有基础性，因为它证明了通过研究相对于单一形式主义（如 GR 或）的可计算性，我们从根本上提供了哪些函数可以和不能通过算法原则上有效地计算的一般解释。鉴于此，将有助于在斯坦福百科全书中列举一些关于 Church 论题的额外证据，这些证据以 GR 与其他几种计算形式主义的等价性形式呈现：

1. 设为一致的、可计算公理化的理论，扩展（即罗宾逊算术）。那么在上述意义上，可以在中表示的函数类（用替换）是这样的，即。 （参见哥德尔不完全性定理中的可表示性和 Odifreddi（1989：ch. I.3）。）
2. 由部分递归函数类（通过对类 PR 进行无界最小化操作的闭包）的成员组成的总函数类 REC 是这样的。 （参见第 2.2.1 节和 Odifreddi [1989：ch.I.2]。）
3. 在组合逻辑（与λ演算相关的形式系统）中可表示的函数类 CL 是这样的。 （参见组合逻辑和 Bimbó [2012：ch.5.3]中的可计算函数和算术。）
4. 由图灵机（在其定义的几个变体下）可计算的函数类是这样的。 （参见图灵机和 Odifreddi [1989：ch.I.4]中的替代历史模型的可计算性。）
5. 由 Shepherdson＆Sturgis（1963）引入的无限寄存器机可计算的函数类是这样的。（参见 Cutland [1980：ch. 1-3]和 Cooper [2004：ch. 2]。）

这些形式的等价结果证明了 GR 类的数学鲁棒性，从而也证明了有效计算本身的非正式概念的鲁棒性。正如我们所见，哥德尔最初通过尝试分析递归定义的背景概念作为受 19 世纪末和 20 世纪初基础发展启发的有效计算模型而导致了一般递归性的制定。[18]关于如何将 Church，Turing 和 Post 的工作视为提供独立动机的可计算性分析并支持 Church 的论题的进一步讨论，可以在 Gandy（1980）和 Sieg（1994, 1997, 2009）中找到。

### 1.7 Entscheidungsproblem 和不可判定性

除了扩大哥德尔不完备定理的范围的目标之外，上世纪 30 年代对递归函数的研究的另一个动机是研究所谓的不可判定（或不可解决）问题。这类问题的最初例子是确定给定的一阶逻辑公式是否有效，即在其所有模型中是否为真。这最初被描述为希尔伯特和阿克曼在他们的教科书《理论逻辑基础》（1928 年）中的一阶逻辑的决策问题：

> 如果我们知道一种过程，可以通过有限次操作来决定给定逻辑表达式的普遍性（即有效性）或可满足性，那么决策问题就得到解决。决策问题的解决对于所有可以用有限公理逻辑描述的领域的理论来说都具有基本重要性。（希尔伯特和阿克曼 1928 年：73）

这段文字说明了逻辑推导的可判定性问题与引发希尔伯特对元数学研究的关注之间的另一种联系。请注意，如果是有限公理集，则问题是否是逻辑推论的逻辑结果等价于句子是否在逻辑上有效。根据哥德尔的完全性定理（参见哥德尔的条目）对于一阶逻辑，这等价于从希尔伯特和阿克曼的一阶逻辑公理化中推导出。对于决策问题的肯定回答可以被解释为显示在数学中可以机械化搜索证明的可能性，即允许我们通过算法确定一个表达一个开放问题（例如黎曼猜想）的公式是否是一个适当强大的有限公理化理论（例如哥德尔-伯奈斯集合论）的逻辑结果。

除了分析有效可计算性的概念本身之外，图灵（1937 年）和丘奇（1936a，b）的数学目标是对决策问题提供一个数学上精确的否定答案。他们提供的答案可以理解为经过三个阶段的进行：

1. 通过在第 1.3 节中描述的语法算术化方法，图灵和丘奇展示了决策问题如何与一组自然数相关联。
2. 然后他们在数学上证明了它是不可判定的，即其特征函数在形式上或相对于模型或中是不可计算的。
3. 他们最终提供了进一步的论据，以证明这些模型包含了所有有效可计算的函数，从而暗示这个函数在非正式意义上也是不可计算的。

这些步骤中的第一步可以通过定义来完成。

其中是如第 1.3 节所述的的哥德尔编号。图灵和丘奇对于“决策问题”的否定回答的第二步依赖于他们先前对于模型、和 GR 的类似决策问题的具体规定。他们与克里恩（1936a）一起证明了以下内容：

命题 1.1：以下集合的特征函数在相关模型中是不可计算的：

3. 方程系统的项决定了一个一般的递归函数

例如，命题 1.1 的第一部分表明，不存在一个图灵机，如果在上停机则输出 1，否则输出 0。这因此是图灵著名的停机问题不可解的一个表述（参见图灵机的条目）。第二部分和第三部分也可以描述为表达集合和都是不可判定的。通过考虑第 1.6 节总结的等价结果，命题 1.1 因此表明，这些集合的成员资格不能相对于任何相关模型来决定。

在此基础上，图灵（对于 ）和丘奇（对于 和 GR）随后证明了以下事实：

命题 1.2：如果 是可判定的（相对于所讨论的任何模型），那么 、 和 也是可判定的。

图灵和丘奇给出的这些事实的证明是具有建设性的，因为它们展示了如何有效地将一个模型的个别实例转化为一个一阶公式，使得当且仅当该实例具有所讨论的属性时，该公式是有效的。例如，给定一个图灵机和输入 ，我们构造一个公式 ，当且仅当计算停机时，该公式是有效的。因此，这种方法预示了下面第 3.5.1 节中给出的一对一可约性的定义。

与 Church 和 Turing 已经提出的支持 Church's Thesis 的其他论证一起（见第 1.6 节），命题 1.1 和 1.2 可以被认为证明了 Entscheidungsproblem 在 Hilbert & Ackermann（1928）所描述的非正式意义上确实是不可判定的——即不可通过“使用有限次操作的机械过程”来判定。正如我们将在第 3 节中看到的，发展这种不可判定性结果及其相互关系的一般理论的愿望是 20 世纪 40 年代以来计算理论进一步发展的重要动力。

### 1.8 递归函数理论和可计算性理论的起源

刚才描述的发展是当代数学逻辑的一个子领域的前史，该子领域最初被称为递归函数理论（或更简单地称为递归论）。这个主题是由 Kleene、Turing 和 Post 在 20 世纪 30 年代末开始认真研究的，直接基于第 1.6 节和第 1.7 节中总结的等价性和不可判定性结果的论文。特别重要的是 Kleene 的论文（1936a、1938、1943、1955a、b、c），它们分别包含了部分递归函数的定义、它们与 GR 的等价性的证明、正规形式定理、递归定理以及算术和分析层次的定义。同样重要的是 Turing 的论文（1937、1939）（分别包含了停机问题的不可判定性和图灵可约性的定义）以及 Post 的论文（1944）（引入了多对一和一对一可约性，并提出了后来被称为 Post's Problem 的问题）。

这些发展将在第 3 节中进行调查。正如我们将在那里看到的，可计算性理论早期阶段的一个重要主题是对有效可计算性概念的表征，该概念能够支持基于关于算法计算性直觉的严格证明，但同时又抽象出了第 1.6 节中提到的模型的细节。为此，哥德尔对一般递归方程的原始定义在早期教科书中（例如，Shoenfield 1967; Rogers 1987）被克里尼的偏递归函数定义所取代，该定义使用了第 2.2 节中引入的无界最小化运算符。这种表征又被基于机器的表征所取代，例如图灵（1937）或 Shepherdson＆Sturgis（1963）在后来的教科书中（例如，Soare 1987; Cutland 1980）中，这些表征在形式上更接近于非正式描述的计算机程序。

在这些处理中保留的是将计算理解为以有效方式操作有限组合对象的手段，这仍然可以理解为早期理论家（如 Skolem，Hilbert，哥德尔和彼得）所理解的“递归思维方式”。但与此同时，递归函数理论中的许多基本定义和结果只与本节中描述的非正式意义上的递归可定义性间接相关。鉴于此，Soare（1996）提议将递归函数理论更名为可计算性理论，并相应地将传统上称为递归函数的函数称为可计算函数。

这种术语上的变化在当代实践中已被广泛采用，并反映在最近的教科书中，如 Cooper（2004）和 Soare（2016）。尽管如此，这两套术语仍然广泛使用，特别是在哲学和历史来源中。因此，建议读者记住第 3 节开头的术语讨论。

## 2. 递归的形式

注意：寻找递归函数的数学概述的读者建议从这里开始。本节中主要定义和结果的历史背景讨论可在第 1 节中找到。

本节介绍了在可计算性理论中研究的递归定义函数的主要类别的定义。其中，原始递归函数 PR 和部分递归函数 PartREC 是最基本的。前者基于对递归过程的形式化描述，该过程在本条目的介绍中描述，并包括在普通数学中研究的几乎所有数论函数。部分递归函数是通过在无界最小化操作下封闭原始递归函数而形成的，即搜索可判定谓词的最小证明。递归函数 REC 的类别，即在所有输入上定义的部分递归函数，传统上被认为通过 Church 的论题（第 1.6 节）对应于可以通过算法有效计算的函数。

在本条目的其余部分将使用以下符号约定：

* 表示自然数集，表示 k 次的笛卡尔积，表示固定数字的向量（当从上下文中清楚时）。
* 小写的罗马字母表示类型为（对于某些 ）的函数——即，具有定义域和值域的函数类。对于固定的 ，表示是一个 -元函数（或具有元数）——即，具有定义域和值域的函数。小写的希腊字母将类似地用于特殊函数（例如，投影）的定义如下。
* 用作表示函数参数的形式变量。将非正式地用于表示此列表中的任意变量。将用于缩写变量向量（当元数从上下文中清楚时）。
* 粗体字母（或缩写如 PR）将用于表示是的函数类的子集。
* 递归字母（或缩写，如 ）将用于表示对的函数（可能具有不同元数）到其他函数的操作。
* 大写字母将用于表示关系—即，的子集，其中范围保留用于表示一元关系—即，的子集。
* 关系的特征函数用表示，即

### 2.1 递归函数（PR）

#### 2.1.1 定义

通过给出一个初始函数类并在一个或多个函数类中封闭，可以指定一类递归定义的函数。通常可以通过这种方式在任意一组初始函数上定义一个类。然而，在本条目中考虑的所有函数类都将确定类型的函数，即它们将以 k 元组的自然数作为输入，并（如果定义了）返回一个自然数作为输出。

在原始递归函数 PR 的情况下，初始函数包括返回值为 0 的零元函数（因此可以视为常量符号），表示一元后继函数，并表示到第 k 个参数的 k 元投影函数（其中）-即，

这类函数将被表示为。请注意，由于对于每个，是一个不同的函数，因此已经包含了无限多个函数。

PR 的函数是由复合和原始递归组成的。复合接受具有个数的函数和一个具有个数的函数，并返回它们的复合函数-即，函数

的类型。例如，假设是乘法函数，是常数 3 函数（我们可以将其隐式地视为只接受一个参数），是后继函数。那么与和的组合是一元函数，我们通常用表示。

组合操作可以理解为一类函数，对于每个 ，它接受元数的函数和一个元数的函数作为输入，并返回将这些函数按照刚刚展示的方式组合的元数函数。这可以通过以下方案描述：

定义 2.1：假设和 。那么术语表示的函数

 类型的

原始递归也是一个函数操作。在最简单的情况下，它通过接受一个一元函数和一个自然数，并返回由定义的一元函数来运行。

在这样的定义中，第一个子句（称为基本情况）确定在 0 处的值，而第二个子句确定在处的值如何取决于在处的值。在这种情况下，很容易看出的值决定了函数迭代（即，应用于自身）以确定的值的次数。例如，如果和，则。

完全原始递归方案在两个方面上对()进行了推广。首先，它允许函数在 t 处的值不仅依赖于其自身在 t 处的值，还依赖于变量本身的值。这导致了以下方案

例如，通过()可以获得在本条目引言中定义的阶乘函数的定义，其中和

第二种可能的推广到()的方式是允许的值依赖于一系列称为参数的辅助变量的有限序列，这些参数也可以是基本情况的参数。在单个参数的情况下，这导致了以下方案

例如，加法函数可以通过取和来定义。这个定义也可以被理解为指定和是通过从初始值开始迭代应用后继函数次数得到的值，类似于()的方式。同样地，可以通过取和来定义。这将把乘积定义为通过从初始值 0 开始迭代将添加到其参数的函数得到的值。

因此，这样的定义可以被理解为为计算所定义函数的值提供算法。观察到每个自然数要么等于 0，要么是形式为的形式。如果我们现在引入 n 次的缩写，将后继函数应用于表示的数字的结果将得到表示的数字。因此，我们可以使用先前递归定义的加法来计算的值，如下所示：

原始递归操作的完整定义将()的两个泛化结合为一个单一的方案，该方案接受一个 k 元函数，一个 n 元函数作为参数，并返回一个 m 元函数，定义如下

这里的第一个参数是参数，第二个参数是递归变量，第三个参数给出了的先前值。一个基本的集合论论证表明，对于每个 ，如果是 k 元的，是元的，那么存在一个满足()的唯一元函数—参见，例如，Moschovakis（1994 年：第 5 章）。

再次引入一个正式的方案来引用以这种方式定义的函数将会很有用：

定义 2.2：假设和 。那么术语表示满足()的唯一类型函数。

我们现在可以正式地将原始递归函数类 PR 定义如下：

定义 2.3：原始递归函数类 PR 是包含初始函数并在函数上封闭的最小函数类。

有了 PR 的定义，我们也可以定义什么是原始递归关系。

定义 2.4：如果其特征函数是一个原始递归函数，则是一个原始递归关系。

定义 2.4 因此将原始递归关系的特征化作为存在一种类似上面所示的算法，该算法在输入时返回输出 1，如果对于则成立，并且在输入时返回输出 0，如果对于不成立。如下所示，将会清楚地看到，在日常数学中考虑的大多数自然数上的集合和关系，例如质数集 PRIMES 或关系

[Definition 2.4](https://plato.stanford.edu/entries/recursive-functions/#prereldefn) thus conventionalizes the characterization of a primitive recursive relation  as one for which there exists an algorithm similar to that illustrated above which returns the output 1 on input  if  holds of  and the output 0 if  does not hold of . As will become clear below, most sets and relations on the natural numbers which are considered in everyday mathematics—e.g., the set *PRIMES* of prime numbers or the relation

—是原始递归的。

前述定义将 PR 指定为在函数下的最小闭包。换句话说，PR 可以等价地定义为满足以下属性的子类：

i.

 二进制

对于所有的和，如果是-元的，是 k 元的（对于），那么。

 三进制。

对于所有的和，如果是 k 元的，是元的，则。

 四.

除非可以通过 i-iii 来定义，否则没有函数是 PR 的成员。

定义 2.3 的另一个结果是，每个函数都具有一个规范，该规范显示了如何通过有限次的复合和原始递归的应用来定义它。这个过程可以通过进一步考虑上述函数的定义来说明。

首先注意，虽然熟悉的加法和乘法的递归定义符合()的格式，但它们不符合()的格式，因为在这种情况下，原始递归方案的参数必须是一个 3 元函数。然而，可以通过采用——即恒等函数——和——即将后继函数与 3 元投影函数在第二个参数上进行组合得到的函数来提供一个官方形式的定义。然后，表达式可以被理解为一个编码了我们为加法提供的定义的术语。乘法可以通过()和来定义。

 因此

—或以显式形式

—可以被视为一个类似的术语，编码了我们用 缩写的乘法定义。

这些例子说明了在许多非正式递归定义中使用的更简单的递归方案可以被归类为定义 2.3——例如，可以将在()中定义的函数获得为。在 2.1.2 节中提供的示例中，将经常使用这种类似的观察（通常不加评论）。

由于每个都是通过()中给定的术语来定义的，因此这种方式给出的事实的另一个结果是：

命题 2.1：函数类 PR 是可数的。

这可以通过展示可以将 PR 枚举为来证明，方法是通过引入从表达式和中形成的术语的哥德尔编号，如 1.3 节所述。由于对于所有的类型有不可数多个函数，这个观察结果也提供了一个非构造性的证明，即存在着不是原始递归的数论函数。

#### 2.1.2 示例

几乎所有在普通数学中遇到的数论函数和关系都可以被证明是原始递归的。为了说明这个类的范围，我们将在这里介绍一系列标准的定义，这些定义可以追溯到 Skolem（1923）。这可以用来证明下面定义的序列编码和解码操作是原始递归的。这反过来又需要 Gödel 的语法算术化（见第 1.3 节）以及像正规形式定理（2.3）这样的结果，这将在下面讨论。

##### a. 常数函数

对于每个定义为原始递归的常数 k 函数。为了证明这一点，我们首先通过原始递归定义常数 0 函数如下：

然后我们可以通过重复组合来定义常数 k 函数：

##### b. 指数运算，超级指数运算

我们已经看到，加法函数可以通过原始递归来定义，其中使用了后继函数的重复应用，而乘法函数可以通过原始递归来定义，其中使用了加法的重复应用。我们可以通过观察到指数函数可以通过原始递归来定义，其中使用了乘法的重复应用，如下所示：

超级指数函数

⋰

可以通过重复指数运算的原始递归来定义，如下所示：

函数序列

其中第 st 个成员是以第 th 个成员的原始递归方式定义的，形成了一个函数层次结构，其值与其输入成比例地增长。虽然该序列中的每个函数都是原始递归的，但我们还可以考虑定义为——所谓的 Ackermann-Péter 函数的一个版本，在第 1.4 节中定义——其值不受任何固定函数的限制。由于可以证明的值不受任何函数的限制，这表明不能通过有限次应用该方案来定义。这提供了一个构造性的证明，即存在类型为的函数，它们不是原始递归的。

##### c. 前任和适当减法

适当前任函数由以下给出

该函数是原始递归的，因为它可以定义为

注意，()的第二个子句不依赖于的先前值。但是，通过取和，仍然可以将此定义符合()的方案。

适当的减法函数由给出

该函数也是递归的，因为它可以定义为

##### d. 绝对差异、符号、最小值和最大值

绝对差异函数的定义如下

可以通过组合定义为  ，因此是原始递归的。

符号函数的定义如下

这个函数可以通过组合定义，并且因此是原始递归的，反向符号函数也是如此，它返回 1 如果，否则返回 1。

最小值和最大值函数可以通过从先前被认为是原始递归的函数进行组合定义，如下所示：

##### e. 顺序和身份

自然数上小于关系（）和等于关系（）的特征函数可以定义如下：

因此，这些关系是原始递归的。

由于小于等于关系（）在逻辑上等同于，根据下一组观察结果，可以得出这个关系也是原始递归的。同样适用于和。

##### f. 命题运算的闭包

原始递归关系的集合在布尔运算下是封闭的。换句话说，如果和是原始递归的，那么、、、和也是原始递归的。

鉴于经典连接词的互定义性，这一点可以通过注意以下事实得出：

##### 例如有界和与有界积

假设是递归的。那么有界和与有界积都是递归的，因为它们可以分别定义如下：

##### h. 有界量词下的闭包

原始递归关系的集合也在有界量词下是闭合的 - 即，如果是一个原始递归关系，那么关系和也是原始递归的。它们可以分别定义如下：

由于下面会有用到，我们在特征函数的符号约定中扩展了自由变量和约束变量在所定义函数的下标中的显示。

##### i. 有界最小化下的闭包

原始递归关系的集合也在有界最小化下闭合。这意味着如果是一个原始递归关系，那么返回最小的满足的函数也是原始递归的，其中是存在的最小的满足的，否则为—即，

要看到这一点，观察到如果是原始递归的，那么也是原始递归的。然后很容易验证

##### j. 可除性和素性

自然数被称为可除的，当且仅当存在一个数 ，即除以时没有余数。在这种情况下，我们写作 。注意，如果成立，则必须存在一个除数 ，使得 。因此，我们可以通过以下方式定义 ，从而证明它是递归的：

我们还可以定义非可除关系 ，从而证明它也是递归的。

接下来回想一下，一个自然数是质数，当且仅当它大于 1 且只能被 1 和它自己整除。因此，我们可以用以下方式定义这个关系，以显示它是递归的：

质数形成了一个熟悉的无限序列... 让——即返回第 n 个质数的函数。可以通过相对于返回最小的 k 使得 k 是质数的函数的原始递归来定义。如下所示：

回想一下，欧几里得定理指出，在 n 和 2n 之间总有一个质数，而且这个函数是原始递归的。因此，可以通过有界最小化来定义。

由此可见，递归是原始递归的。

##### k. 序列和编码

前面的定义序列为原始递归关系和函数的稳健性提供了一些证据。进一步的证据是，可以开发出对自然数的有限序列进行编码和解码的机制，并对序列进行各种组合操作，例如元素的连接、子序列的提取、一个元素替换为另一个元素等等。这些操作的原始递归性是哥德尔的句法算术化的基础，如 1.3 节所述。我们在这里只介绍了基本定义，以证明 k 元组和投影函数的原始递归性，这些函数在可计算性理论中的结果中是必需的，例如下面讨论的正规形式定理（2.3）。

给定一个自然数的有限序列，我们将其编码定义为数字

其中是上述定义的第个素数。换句话说，的编码是从到的乘积得到的自然数。这将被表示为——例如，

（注意，每个指数都加 1，以便，例如，3, 1, 4, 1, 5 与 3, 1, 4, 1, 5, 0 具有不同的编码，即编码操作是单射的。）

将任意长度的序列转换为其代码的操作没有固定的元数，因此不能由单个原始递归函数给出。但是，如果我们限制注意力在给定长度的序列上，很容易看出是原始递归的，因为它只是由()给出的有界乘积。接下来考虑函数，其中和，并且当不在此范围内或或时返回 0（因此不是序列的代码）。为了看到也是原始递归的，首先观察到可以通过搜索最小的来恢复——即由编码的序列的长度，使得和。由于还限制了所有能够被它整除的质数，我们可以定义

显然，通过具有原始递归条件的情况定义的函数是原始递归的。因此，也是原始递归的。类似地，很容易看出关系是序列的代码是原始递归的。

最后观察到等于最小的指数，使得但是且这样的指数也被界定为。因此，我们可以如下提供对的原始递归定义：

下面的函数将使用常规缩写。

#### 2.1.3 原始递归函数的附加闭包性质

原始递归函数和关系包括了一个广泛的类别，几乎包括了在逻辑或可计算性理论之外的普通数学中遇到的所有函数。这在一定程度上可以通过 PR 包含的函数来说明，这些函数的增长速度远远超过了我们在实践中可以计算的函数的值，这是计算复杂性理论中研究的意义上的。但是，PR 类的鲁棒性也可以通过其定义对各种修改的不变性来证明，例如，对其定义所基于的初始函数和函数式的类别的不变性。

作为一个初始的说明，考虑以下所谓纯迭代的方案：

很容易看出，由此定义的函数()是的迭代，即-times 的，其中约定。我们将用表示这个函数。方案()通过将基本情况的值作为参数传递给来推广()。但是，这是()的明显限制，因为不能依赖于递归变量或其他参数。

现在假设我们考虑一个替代的初始函数类，其中包含二进制编码函数，以及在第 2.1.2 节末尾定义的解码函数和。 （注意，这些函数类似于第一个和第二个生产函数，它们作用于有序对的编码。）现在定义为包含和在内，并在函数下封闭的最小函数类。

定理 2.1（罗宾逊 1947 年）：该类等于原始递归函数的类 PR。

这说明，如果我们稍微扩大初始函数的类，仍然可以通过一种功能迭代方案获得整个类 PR，尽管这种方案起初似乎不如原始递归那么普遍。有关在这个方向上可以获得的进一步改进的解释，请参见 Odifreddi（1989 年：第 I.5 章）。

其他结果表明，如果用其他可能起初看起来更普遍的方案替代原始递归，类 PR 也将保持稳定。其中最熟悉的是所谓的值递归方案，传统上使用所谓的斐波那契函数进行说明，该函数在第 1 节的开头简要讨论过。可以定义如下：

这个定义可以很容易地用递归的方式来计算的值，例如，

这导致了熟悉的序列 0, 1, 1, 2, 5, 8, 13, 21, 34, 55, 89, 144，其中和。然而，请注意，定义()不能直接 assimilated 到原始递归方案()，因为第三个子句将的值定义为和的函数。然而，仍然可以证明。一种方法是再次利用二进制编码和投影函数来首先定义一个辅助函数和

枚举对，然后很容易看出。

() 因此是一个实例，其中函数在的值取决于先前的值和其图形（对于）。当然，也可以考虑取决于任意数量先前值的情况。为此，假设我们给定并定义

然后我们说是通过值递归从定义的

假设我们现在让  表示相应的函数操作，并让  是包含  并且在  和  下封闭的最小函数类。由于很容易看出如果  是原始递归的话  也是，我们还有以下：

定理 2.2（彼得 1935 年）：该类等于原始递归函数类 PR。

由于在数学实践中使用了值递归，重要的是它不会超出原始递归函数类。然而，还有许多其他可能的方式可以推广方案（），包括所谓的双重递归和嵌套递归。第 1.4 节中的函数定义展示了前者，因为其在的值取决于其在和的值，而后者则是因为定义的函数的出现“嵌套”在自身内部（而不是辅助函数）在第三条子句的右侧。有关原始递归函数相对于这些方案的闭包性质的更多详细信息，请参见关于 Ackermann-Péter 函数的补充说明。

### 2.2 部分递归函数（PartREC）和递归函数（REC）

我们现在已经看到了两种证明存在非原始递归的数论函数的方法，即通过观察到虽然原始递归函数只有可数多个，但类型为()的函数有不可数多个，以及通过构造一个比任何原始递归函数都增长更快的函数。第三个证明——最初由希尔伯特和伯奈斯（1934 年：第 7 章）提出——基于这样的观察：可以将类 PR 枚举为——例如，通过对第 2.1.1 节末尾考虑的定义类型进行哥德尔编号。然后，如果我们考虑修改后的对角线函数

很容易看出这个函数也不能是原始递归的。因为如果它与枚举中的某个函数相等，那么我们将有，这是一个矛盾。注意，这也表明相对于这样的枚举，一元原始递归函数的通用函数本身也不能是原始递归的，否则我们可以将其定义为。希尔伯特和伯奈斯（1939 年：第 5 章）后来在他们所谓的指称悖论方面讨论了这一观察——参见，例如，普里斯特 1997 年。

另一方面，对于计算这些函数，存在直观有效的过程。例如，在的情况下，我们可以按照以下步骤进行：

1. 使用  来构建 的定义；
2. 通过执行相应的原始递归计算来计算 的值；
3. 加 1 并停止。

与递归和函数的定义一样，前述过程在 1.6 节中讨论的意义上是有效的。但由于步骤 ii 中变量的一致性，相应的函数不能通过单一的原始递归定义来计算。因此，自然而然地有动机来扩展类 PR 的定义，以包括这样的函数。

实现这一目标的一种方法是基于有界最小化操作的观察，该操作具有直接的算法特征化——即，通过连续检查…，…来计算输出值，并在满足条件时停止，如果在之前找不到正实例，则停止。这可以推广到所谓的无界搜索操作。特别地，给定一个关系，我们可以定义操作，返回最小的使得如果存在这样的，则为，否则为未定义。注意，如果是原始递归的，则仍然可以通过连续检查…来有效地搜索的值。但由于事先没有指定上界，我们不能保证该过程总是终止。特别地，如果不存在满足条件的，则该过程将无限继续。在这种情况下，我们规定为未定义，由此可知将对应于所谓的部分函数的概念——这一概念通过以下一系列定义来明确。

#### 2.2.1 定义

所谓部分递归函数的类是通过在我们之前对 PR 的定义下进行一个类似于对函数而不是关系进行的操作的封闭得到的。为了定义这个类，我们首先引入了以下关于部分函数的约定，这些约定扩展了第 2 节开头给出的那些：

* 如果对于所有的，函数被称为总的。否则被称为部分的。
* 我们写作来表示在定义在上的情况下，还有如果在上定义且等于的情况下。否则，我们写作来表示在上是未定义的。
* 的域是集合 。
* 我们写作 ，当且仅当对于所有 ，要么 和 都未定义，要么 和 都定义且相等。

假设我们给定一个部分函数 。现在我们引入以下形式的术语 ：

换句话说，递归是等于最小的数，只要存在这样的数，并且对于所有的，定义但不等于 0。另一方面，只有在以下情况下未定义：要么没有这样的，要么有这样的，但对于某些未定义。

由于这个定义唯一确定，()也可以被视为将-元部分函数映射到 k 元部分函数的函数。我们现在定义函数 PartREC 和 REC 的类如下：

定义 2.5：部分递归函数 PartREC（也称为-递归函数）是类型为的部分函数的最小类，包含初始函数并在函数上封闭。

我们说一个函数是部分递归的如果。此外，我们说如果是递归的并且是总的。递归函数的集合将用 REC 表示。

自从上世纪 30 年代以来，“部分递归函数”这个名称用于表示这个类已经成为标准用法，我们将在这里保留它。然而，它在至少两个方面可能会引起困惑。首先，由于“部分”用于修改“函数”而不是“递归”在断言“是一个部分递归函数”中，一个更自然的表达应该是“递归部分函数”。其次，尽管它的名称如此，部分递归函数的类包含总函数。特别地，递归函数是根据定义，既是部分递归的又是总的。我们将在第 3.2 节中看到，还存在真正部分的部分递归函数和不是递归的总函数。

最后请注意，如果是递归的，它可以通过一些有限次的复合、原始递归和无界最小化的应用来定义，这种方式保持了其定义中中间函数的总性。因此，尽管的规范可能涉及一次或多次无界搜索的应用，但计算其值所需的每次搜索都保证在有限步骤内终止。因此，尽管我们很快将看到这个类包含了不是原始递归的函数，但 REC 中的所有函数都可以通过算法计算（这构成了 Church 的论点的一部分，即 REC 与有效计算函数的类重合，这在第 1.6 节中进行了调查）。

#### 2.2.2 正规形式定理

一旦我们定义了 PartREC 类，一个自然而然的问题是是否所有的部分递归函数都可以以规范的方式定义。正规形式定理（最初由 Kleene（1936a）提出）通过显示仅需要一次无界最小化运算符的应用就可以获得所有这样的函数，从而对这个问题给出了肯定的答案。为了阐述这个结果，方便起见，我们正式将-运算符的应用扩展到原始递归关系上，这一点在本节开始时已经讨论过，即，

定理 2.3：对于所有的，存在一个-元原始递归关系，即所谓的 Kleene T 谓词，以及一个原始递归函数（不依赖于），满足以下条件：对于所有的 k 元部分递归函数，存在这样的，对于所有的

由于，很容易看出，PartREC 类也可以通过对()定义的操作对原始递归函数进行闭包来获得。定理 2.3 的一个结果是，确实可以通过对适当选择的关系进行无界搜索的单次应用来定义任何 k 元部分递归函数。更一般地说，正规形式定理说明了如何从单个关系中定义任何这样的函数，其中的值用作描述的方式，该方式是基于基础函数和操作定义的。这样的是被称为的索引。正如我们将在第 3 节中看到的那样，这些索引的可用性是部分递归函数的核心特征之一，它们使它们能够为可计算性和不可计算性的一般理论提供基础。

定理 2.3 的证明的完整细节很复杂。但基本思想可以总结如下：

1. 每个部分递归函数都由语言中的术语定义。

以扩展第 2.1.1 节末尾介绍的部分递归函数符号方案的方式。通过将该语言的原子表达式与哥德尔编号中描述的自然数相关联，然后使用第 1.3 节描述的编码机制，可以将自然数与可以用作索引的自然数相关联。

2. 现在可以通过形式化以下决策算法来构建的定义：
3. 在输入中，从构造一个定义的项。
4. 将理解作为一系列中间计算步骤的潜在代码，类似于计算()所示的方式，检查是否编码了执行输入为的计算的一种方式；
5. 如果是这样，则接受-即成立-如果不是，则拒绝-即成立。
6. 通过以这种方式对计算序列的代码进行无限搜索，我们实现了两个目的：确定输入为的计算是否在有限步骤后停止，并且如果是这样，还找到了一个计算序列的代码，证明了这一事实。[22]然后可以通过形式化从编码的序列的最后一步提取计算输出的操作来定义函数。在成立的情况下，将对应于值。由于前述步骤仅需要执行有界搜索并检查有限序列的局部组合性质，还可以证明和是原始递归的。

这个证明中使用的技术也可以用来证明，通用的 k 元原始递归评估函数和修改的对角线函数都是递归的（尽管我们之前已经看到它们不是原始递归的）。例如，注意上述描述的 k 元部分递归函数定义的编码也允许我们通过考虑不包含的项的代码来统一枚举所有原始递归函数。我们可以以这种方式定义一个枚举这些函数的索引的原始递归函数，以便我们可以得到 k 元原始递归函数的通用函数。但请注意，由于始终被定义，不仅是部分递归的，而且是总的，因此是递归的。

考虑到第 1.6 节总结的计算模型之间的等价性，也可以为每个提到的计算模型制定定理 2.3 的一个版本。例如，在图灵机模型的情况下，正常形式定理的类似版本可以用来证明存在一个单一的通用图灵机（参见图灵机条目），使得每个部分递归函数对应于某个计算的函数。图灵（1937 年：第 6 节）对，Kleene（1936a：第 2 节）对一般递归函数 GR 给出了这种类型的完整证明（另见 Kleene 1952：第 58 节），Shoenfield（1967 年：第 7.4 章）对可在 Peano 算术中表示的函数类给出了这种类型的完整证明，Cutland（1980 年：第 5 章）对无限寄存器机模型给出了这种类型的完整证明。

## 3. 可计算性理论

可计算性理论是当代数学逻辑的一个子领域，致力于根据其绝对和相对可计算性以及可定义性质，对自然数的函数和集合进行分类。这个主题在起源和内容上与递归函数的研究密切相关。这反映在可计算性理论从 20 世纪 30 年代开始直到 20 世纪 90 年代末被称为递归函数理论（或简称递归论）。这也反映在所谓的递归定理的表述和证明中，该定理提供了递归可定义和自我引用构造之间的基本联系，这些构造是可计算性理论中许多方法的核心（见第 3.4 节）。

如第 1.7 节所讨论的原因，可计算性理论的当代阐述通常以抽象的方式呈现，试图最大限度地减少对计算模型的特定特征（如部分递归函数）的引用。因此，有必要强调以下对传统术语的修改，这些术语已在第 1 节和第 2 节中使用，并将在本节中使用更现代的术语：

* 将可计算函数和部分可计算函数的表达式用于传统术语递归函数和部分递归函数的定义（见第 2.2.1 节）。
* 可计算集合这个术语将被用来代替传统的递归集合。同样地，可计算可枚举（或 c.e.）集合将被用来代替传统的递归可枚举（或 r.e.）集合（见第 3.3 节）。

在本节中将保留在第 2.1 节和第 2.2 节开头引入的其他符号约定。

### 3.1 索引，s-m-n 定理和普遍性

在可计算性理论中，第一个重要的结果是克林（Kleene）在 1936 年证明的正规形式定理，该定理在 2.2.2 节中介绍。如前所述，正规形式定理可以理解为说明如何将每个 k 元部分可计算函数与一个称为其索引的自然数相关联，使得。这样的可以被视为一个由基本函数、组合、原始递归和最小化构建的计算机程序的名称，通过这些函数可以计算出值。这也导致了所谓的 k 元部分可计算函数的索引化。

其中。这样的枚举提供了一种统一的方法，按照它们的索引顺序列出所有部分可计算函数。然而，需要注意的是，每个部分可计算函数都有无限多个索引。例如，给定一个由计算的函数，可以定义无限多个在外延上相等但索引不同的函数，例如通过对编码的定义进行“填充”，每个都逐次添加然后减去。由于这产生了一个外延等价函数的定义，因此可以得出结论，将对应于相同函数的无限多个。

与正规形式定理密切相关的一个结果是以下定理，通常称为 s-m-n 定理：

定理 3.1：对于所有的，存在一个原始递归函数，使得

在这里，应该将函数视为作用于一个-元部分可计算函数的索引以及其第一个参数的值。该函数返回另一个部分可计算函数的索引，该函数通过固定第一个参数但保留下一个变量作为输入来计算确定的 n 元函数。虽然 s-m-n 定理的表述可能一开始看起来很技术性，但其在 Rice 定理（3.4）和递归定理（3.5）的证明中将得到说明。

正则形式定理的另一个结果是以下内容：

定理 3.2：对于每个 ，存在一个 -元部分可计算函数，它在以下意义上是通用的：对于所有的 -元部分可计算函数 ，存在一个 ，使得 。

这个结论可以立即从定理 2.3 中得出，取 ，其中 是在 -元部分可计算函数的枚举中的索引。由于 可以用来统一计算所有 -元部分可计算函数的值，因此它通常被称为 -元通用部分可计算函数。

值得注意的是，虽然我们刚刚为每个 定义了这样一个函数，但也可以定义一个二元函数，将其第二个参数视为一个有限序列的编码，然后按照与 -元通用函数相同的方式计算，以便我们有 。这提供了一种用单个一元函数替换先前的 -元部分可计算函数枚举的方法。

 在

与定理 2.3、定理 3.1 和定理 3.2 一起，将计算模型的基本属性编码为适用于计算可行性的一般理论的发展。在第 2 节中，这样的模型已经以部分递归函数的形式定义。但正如在第 2.2.2 节末尾简要讨论的那样，这些结果的版本也可以用于第 1.6 节中讨论的其他计算模型。这使得在计算可行性理论的大多数现代处理中，可以更自由地使用基于计算机的类比和其他对 Church 定理的引用，这也将在本条目的其余部分中谨慎使用。

### 3.2 非可计算函数和不可判定问题

刚刚看到有一个普遍的部分可计算函数，一个自然的问题是这个函数是否也是可计算的（即，总的）。通过观察，我们可以立即得到一个否定的答案，即通过使用我们可以定义另一个修改的对角线函数，它是部分可计算的（因为是）。这反过来意味着对于某些。但现在请注意，如果是总的，那么将被定义，我们将会有一个矛盾。将这种情况与第 2.2 节开头描述的情况进行比较，我们可以看到部分可计算函数与原始递归函数的区别在于在同一类中允许存在一个通用函数，但同时放弃了类中函数必须是总的要求。换句话说，虽然，但第 2.2.2 节的讨论表明。

由于很容易看出最小化操作如何用于定义部分函数，因此可以预期上述观察结果。更令人惊讶的是，存在数学上定义良好的总函数，但它们是不可计算的。在第 1.7 节关于决策问题的讨论基础上，这种函数的最著名的例子源自于所谓的停机问题（参见图灵机条目）对于图灵机模型。这最初由图灵（1937）如下所述：

Since it is easy to see how the minimization operation can be used to define partial functions, the foregoing observations are expected. What is more surprising is that there are mathematically well-defined *total* functions which are not computable. Building on the discussion of the *Entscheidungsproblem* in [Section 1.7](https://plato.stanford.edu/entries/recursive-functions/#EntsUnde), the most famous example of such a function derives from the so-called *[Halting Problem](https://plato.stanford.edu/entries/turing-machine/#HaltProb)*​[(see entry on Turing machines)](https://plato.stanford.edu/entries/turing-machine/#HaltProb) for the Turing Machine model. This was originally formulated by Turing (1937) as follows:

给定图灵机的索引，机器在输入上是否停机？

一个等价的问题也可以用部分递归函数的术语来表述：

部分可计算函数在输入上是否定义？

对于这个问题的正面答案对应的自然数对决定了一个子集。

如果一个集合（或问题）的特征函数不可计算，则称其为不可判定。例如，让 ，观察到这是一个全函数的定义。现在可以将所谓的停机问题的不可判定性如下所示：

定理 3.3：不是一个可计算函数。

证明：假设存在一个可计算的递归函数。考虑定义为的函数。

在假设可计算的情况下，是部分可计算的，因为它可以通过一个程序来计算，该程序在输入时计算并返回 0，只有当时，否则进入无限循环。因此，对于某个成立。但是现在观察到以下两种情况必须成立之一：i) ；或者 ii) 。因此，我们可以按照情况进行推理如下：

1. 假设。那么根据的定义，。由于是的特征函数，这意味着。但是由于，，产生了矛盾。
2. 假设 . 那么根据 的定义， . 由于  是  的特征函数（因此是全函数），唯一的其他可能性是  ，这又意味着 . 但是由于 ， ，产生了矛盾。□

因此提供了一个数学上明确定义的全函数的初始示例，该函数不可计算。通过考虑类似于 的决策问题，可以定义其他不可计算的函数。一些众所周知的例子如下：

假设我们让 ，和 为这些集合的特征函数。通过对定理 3.3 的证明进行适当的修改，可以直接证明以下内容：

命题 3.1：递归函数、函数和函数都是不可计算的。

例如，在情况下，我们可以如下论证：

1. 定义一个函数，如果，则返回 0，否则未定义；
2. 如前所述，如果假设  是可计算的，则  是部分可计算的，因此存在一个索引  使得 ;
3. 但现在观察到  当且仅当  当且仅当  当 .

由于这又是一个矛盾的情况，我们可以得出结论  是不可计算的。

注意，每个在()中定义的集合都具有以下属性：如果和，则也。具有这种属性的集合被称为索引集，因为它们收集了所有共享相同“语义”属性的部分可计算函数的索引，即完全由它们的图确定的属性，例如在的情况下与常数 0 函数重合，在的情况下在所有输入上定义。如果索引集是非平凡的，即或，则它既不包括也不排除所有索引。很容易看出，()中定义的所有集合都是非平凡的索引集。因此，这些集合的不可判定性可以从以下更一般的结果推导出来：

定理 3.4（Rice 1953）：如果是一个非平凡的索引集，则是不可判定的。

证明：设为一个非平凡的索引集，并假设为可计算的以推导出矛盾。考虑到处未定义的一元函数，即对于所有。由于是部分可计算的，存在一个索引使得。我们可以假设不失一般性。 （如果是的情况，那么我们可以在以下论证中交换与其补集的角色，并得到相同的结果）。由于，我们还可以选择一个索引，并定义一个函数如下：

注意，这是部分可计算的，因为它根据的值的情况进行定义。因此存在一个索引，使得。通过应用 s-m-n 定理（3.1），我们有。但请注意，我们现在有以下推论序列：

（根据我们的选择）

（根据我们的假设，是的索引，即处处未定义的函数，和）。

由此可见，可以通过应用以下算法来计算的值：

1. 在输入的情况下，计算值（其可计算性来自 s-m-n 定理）；
2. 计算值（这可以实现，因为我们假设是可计算的）。

通过调用 Church 的论题或将先前的算法形式化为部分递归定义，可以得出是可计算的。但这与命题 3.1 相矛盾，该命题表明是不可计算的。□

Rice 定理（3.4）提供了一种方法来显示许多实际重要的决策问题是不可判定的，例如确定一个程序是否总是返回输出，或者是否正确计算给定的函数（例如加法或乘法）。它的证明还表明，如果是一个非平凡的索引集，那么决定问题可以“归约”到以下问题：如果我们可以有效地决定后者，那么我们也可以通过首先计算然后检查该值是否在中来有效地决定前者。这种显示不可判定性的方法将在下面的第 3.5 节中通过一对一归约的概念进行形式化描述。

### 3.3 可计算和可枚举集合

一个集合被称为可计算的（或根据第 2 节的旧术语递归的）当且仅当其特征函数是可计算的。更一般地，我们有以下定义：

定义 3.1：一个关系是可计算的，当且仅当是可计算的。

这个定义扩展了第 2.1 节中给出的原始递归关系的定义。例如，由于像 PRIMES 和 DIV 这样的集合是原始递归的，它们也是可计算的。通过 Church 的论题，可计算集合的概念也推广了关于有效可判定性的伴随启发式方法，即当且仅当存在一种算法来判断是否成立，该算法总是在有限（尽管可能是无界）步骤之后返回一个答案。另一方面，根据第 3.2 节中记录的观察结果，HP、K、Z、TOT 或 FIN 都不是可计算集合。

一个相关的定义是可计算可枚举（或 c.e.）集合的定义，即其成员可以通过有效的过程进行枚举。（在第 2 节的旧术语中，这样的集合被称为递归可枚举，传统上缩写为 r.e.）官方上我们有以下内容：

定义 3.2：如果或者是可计算函数的值域，则为可计算可枚举（或 c.e.）。

对于某个总计算函数的索引。

这个定义可以通过将递归视为有限序列的代码来扩展到关系上，即当且仅当存在可计算函数时，递归是可枚举的，使得当且仅当对于某个.

如果递归是可计算枚举的，那么它的成员可以被列举出来.

可能会有重复，例如，常数函数枚举了单例集合，从而使其成为可枚举的. 很容易看出，可计算集合是可计算枚举的. 因为如果，那么根据定义，是可枚举的. 而如果，我们可以选择，然后定义.

在这种情况下，计算是可计算的，并且其范围为。

在证明关于可计算可枚举集合的事实时，通常可以使用几个等价的定义之一：

命题 3.2：假设。那么以下陈述是等价的：

1. 是可计算可枚举的。
2. 或者是原始递归函数的范围。
3. 对于可计算关系。
4. 是部分可计算函数的域。

命题 3.2 的证明主要是解释定义的问题。例如，要看到 iv 蕴含 i，假设——即。如果它是自动 c.e.否则，存在一个元素。我们现在可以定义

因此，将其输入视为一对，其中包括对的输入和在正规形式定理（2.3）的证明中定义的计算序列。随着变化，它会遍历所有可能的输入和所有可能的见证，证明在上的计算终止。然后，如果是这样的终止计算的见证，它返回，否则。因此，的范围将对应于的范围。由于是可计算的（实际上是原始递归）关系，很容易看出是一个具有范围的可计算函数。这表明所需的是 c.e.。

命题 3.2 的第四部分还为可计算可枚举集合提供了一种方便的统一表示法，即如果我们用.来表示。因此，该序列相对于我们之前对一元部分可计算函数的枚举提供了一种统一的枚举方式。这种表示法还有助于以下内容的制定：

**命题 3.3：**

1. 可计算可枚举集合在并集、交集和笛卡尔积下是有效封闭的，即存在可计算函数和，使得如果和，则

 和

2. 可计算集合还在补集和相对补集下封闭——即，如果和是递归的，那么和也是递归的。

这些事实的证明也可以通过引用 Church 的论题来直接得到。例如，如果和是递归的，那么可以取一个程序的索引，该程序在交替阶段模拟和的计算，并在只有这些子计算之一停机的情况下停机。还要注意，如果是可计算的，那么也是可计算的，由此可得是可计算的。[23]

一个相关的观察是以下内容：

命题 3.4（1944 年后）：当且仅当和都是可计算枚举的时候，是可计算的。

从左到右的方向被命题 3.3 包含在内。对于从右到左的方向，假设和。然后，为了决定，我们可以进行一个无界搜索，找到一个计算序列，使得要么或者，在第一种情况下接受，在第二种情况下拒绝。由于，搜索必定终止，由于，条件是互斥的。因此，再次引用 Church 的论题，是可计算的。

我们已经看到可计算集合包含在可计算可枚举集合中。在这个阶段出现的两个问题如下：

1. 是否存在可计算可枚举但不可计算的集合的例子？
2. 是否存在不可计算可枚举的集合的例子？

对于这两个问题都给出了积极的答案：

推论 3.1：回想一下集合——即所谓的对角线停机问题。是可计算可枚举的，但不可计算，而不是可计算可枚举的。

显然是可枚举的，因为它是的定义域。另一方面，我们已经看到，——即在第 3.2 节中定义的函数的特征函数——是不可计算的。因此，确实是一个可计算可枚举的集合，但不可计算。要看出不是可枚举的，观察到如果是可枚举的，那么根据命题 3.4，将是可计算的。这反过来表明，在任何可计算集合中，决定是否属于比决定是否属于更“困难”。在第 3.5 节和第 3.6 节中引入的层次结构将提供一种使这些观察变得精确的方法。

### 3.4 递归定理

现在最常被称为 Kleene 的递归定理的结果可以用来统一一些类似于定理 3.3 的有效对角线论证，并且在可计算性理论和数理逻辑以及计算机科学的其他领域都有广泛的应用[24]。虽然它的陈述很直接，但是在考虑后续的应用时，它的重要性和下面的证明会变得更加清晰。

定理 3.5（Kleene 1938）：假设是一个可计算的总函数。那么存在一个数，使得。

证明：考虑以下定义的函数：

由于很明显是部分可计算的，对于某些 。根据 s-m-n 定理（3.1），我们有 。令 ，注意到我们有 ，只要被定义。注意是一个完全可计算的函数，并且独立于给定的函数的定义。

接下来，令  是  与  的复合函数的索引，即 。我们现在声称  是定理陈述中所要求的数字。首先注意到，由于  和  都是总的，  也是总的，因此  被定义。由此可得 。现在我们有以下的函数等式序列：

□

递归定理有时也被称为不动点定理。然而，请注意，定理 3.5 并不保证给定函数存在一个外延不动点，即一个使得的数值。（事实上，很明显存在可计算函数，对于它们不存在这样的值，例如。）但是假设我们将视为将索引映射到部分可计算函数的映射，或者更形象地说，将其视为将计算部分可计算函数的程序转换为另一个程序的方法。在这种解释下，该定理表达了对于每个这样的可计算转换，都存在某个程序，使得它计算的函数与转换下的图像计算的函数相同。

虽然乍一看这样的程序定义方式是循环的，但为什么这样的程序必须存在也不清楚。事实上，Soare（2016: 28–29）指出，递归定理的上述证明“非常简短但神秘”，并且“最好将其视为失败的对角线论证”。为了澄清这个评论和证明，考虑图 1 中所示的矩阵，其行列举的不是部分可计算函数的值，而是函数本身，即行将包含函数，理解为如果，则表示完全未定义的函数。（这样的描绘最初归功于 Owings 1973 年。）

图 1：在递归定理（3.5）的证明中使用的部分可计算函数的矩阵

我们可以将定理 3.5 中给出的函数视为对行进行变换，使得被映射到。为此，让是与总可计算函数复合的索引，使得我们有

接下来考虑这个矩阵的对角线，即。由于构成的函数的索引是有效给出的，因此必然存在对应于某一行的。

但是现在考虑下面的图像 - 即行。根据（），我们必须有

但请注意，根据的定义，以及根据（），我们也有

但是现在请注意，由于和都是全局的，因此该值是定义的。因此，根据（），我们可以设置，如所需。

如上所述，递归定理经常被用于提供紧凑的证明，这些证明传统上被描述为涉及自我引用。例如，一个直接的结果是对于每个存在一个这样的，使得。要看到这一点，请注意定理 3.5 蕴含了这样一个存在，对于每个可计算的。但由于函数的定义域必须相同，所以得出。

记录下递归定理的以下替代形式是有用的：

推论 3.2：对于每个部分可计算函数，存在一个索引使得。

证明：根据 s-m-n 定理（3.1），对于某个 。然后通过将定理 3.5 应用于 ，可以得到所需的存在性。□

这里有一些简单的推论，符合上述描述的精神，并利用了这个表述：

1. 存在一个数，使得 。（这是通过在推论 3.2 中取 ，类似的观察可以得到存在 ，等等。）
2. 存在一个数字，使得。 （取

 在推论 3.2 中。）

3. 考虑一个对应于“程序”的术语，该术语确定具有索引的部分可计算程序（如第 2.2.2 节所述）。我们说，如果对于所有的输入，计算在输出上。由于为了构造它似乎需要事先知道，因此可能看起来自我复制的程序可能不存在。然而，请注意，将其转换回我们的官方术语，这样的程序的存在等同于存在一个数字，使得。通过将推论 3.2 应用于函数，这是有保证的。

关于自我引用和在可计算性理论中更高级应用的递归定理的进一步讨论，请参见 Cutland（1980：第 11 章），Rogers（1987：第 11 章），Odifreddi（1989：第 II.2 章）和 Y. Moschovakis（2010）。

在离开递归定理之前，反思它如何与第 1 和第 2 节中讨论的递归可定义的一般概念相关是非常有用的。例如，考虑一个简单的定义：

在情况下，我们已经指出，通过外部集合论论证可以证明存在一个满足()的唯一函数。但是，我们也可以考虑这样一种情况，即假设相对于与原始递归函数不同的计算模型（例如图灵机模型或无限寄存器机模型）是可计算的。如果我们在这种情况下简单地将()写下作为定义，我们无法事先保证相对于是可计算的，即使是可计算的。

经过检查，然而，很明显，计算模型的唯一特征，定理 3.5 的证明依赖于的索引存在，其中 s-m-n 定理（3.1）的一个版本可用。如果满足这些条件，那么相对于可计算的声明等价于其中是从某个适当的索引中提取的索引的计算函数。但是，由于 s-m-n 定理允许我们将索引视为变量，我们还可以考虑由以下函数定义的函数

现在请注意，存在这样的的存在是由推论 3.2 再次保证的。这反过来产生了

这说明了满足递归定义的可计算函数的存在，即使我们没有从第 1 节中讨论的非正式意义上的“递归”定义一个“可计算函数”。这反过来有助于解释为什么定理 3.5 被称为递归定理。

### 3.5 减少和程度

当代可计算性理论的一个核心主题是相对可计算性的研究，即如果我们假设我们能够决定一个给定集合的成员资格或计算一个给定函数，那么我们将能够决定或计算哪些其他集合或函数？这个问题可以使用一个集合对另一个集合的归约的概念来研究，这个概念最初由科尔莫戈洛夫（1932）非正式地引入，作为将一个“解决方案”转化为另一个“解决方案”的手段。图灵（1939）在他对序数逻辑的研究中首次给出了计算归约的正式定义。然而，正是波斯特在他极具影响力的论文“可递归可枚举的正整数集及其决策问题”（1944）中首次提出了系统研究可归约概念及其相关程度结构的建议。

在其中，波斯特解释了归约的基本思想及其重要性如下：

> 关于问题的可解性或不可解性的相关问题是一个问题是否可以归约到另一个问题的可归约性或不可归约性。因此，如果问题被归约到问题 ，那么问题 的解决方案立即导致问题 的解决方案，而如果被证明是不可解的，那么必须也是不可解的。对于不可解问题，可归约性的概念导致了不可解程度的概念，如果每个问题都可以归约到另一个问题，则两个不可解问题的不可解程度相同，如果一个问题可以归约到另一个问题，但另一个问题不能归约到它，则它的不可解程度较低，如果两个问题都不能归约到对方，则它们的不可解程度无法比较。在递归可枚举集合理论中的一个主要问题是确定不可解决决策问题的不可解程度。我们很快会看到，对于这样的问题，肯定存在一个最高的不可解程度。我们的整个发展主要集中在一个问题上，即在这些问题中是否存在一个比它们更低的不可解程度，或者它们都具有相同的不可解程度。（Post 1944: 289）

为了理解这段话，再次将一个集合视为与决定成员资格的问题相关联——例如，给定一个自然数 ，它是质数吗？（即 ？）或者第个部分可计算函数在输入上是否有定义？（即 ？）。但是，即使有了这种对应关系，问题的解决方案“立即导致”问题的解决方案仍然可以从多个不同的角度进行分析。其中两个最重要的可能性如下：

1. 假设存在一个算法来决定形式的问题，那么可以指定一个算法来决定形式的问题。
2. 假设我们可以访问一个能够在单步中回答任意形式问题的“神谕”，那么可以指定一个使用该神谕的算法来决定。

这些问题之间的关系的形式化导致了多对一可约性和图灵可约性的概念，它们提供了对这些概念的不同但互补的分析，即解决难度不比难度更大，而且不可解性（或困难程度）与相等。[26]后者的概念在历史上首次出现，并由图灵（1939）和克利尼（1943）以等价形式引入。然而，正是 Post（1944）既引入了前者的概念，也开始了图灵可约性的一般研究。实际上，上面引用的段落的最后一句描述了一个关于图灵度的重要技术问题，这个问题将塑造可计算性理论的早期发展（即下面的“Post 问题”作为问题 3.1 给出）。

#### 3.5.1 多对一度量

我们已经在 Rice 定理（3.4）的证明中看到了多对一可归约的一个例子。特别地，证明表明，决定是否属于的问题可以归约为决定是否属于任何非平凡索引集的问题，具体来说：对于所有 ，如果 ，则 。因此，如果存在一个决定是否属于的算法，我们可以使用它来测试是否 。函数（其可计算性由 s-m-n 定理给出）因此是一个所谓的多对一归约。

正式定义将此示例推广如下：

定义 3.3：给定集合 ，如果存在一个可计算函数 ，使得对于所有 ，则称为多对一（或 m-one）可归约于 。

在这种情况下，我们写道。

使用这种表示法，上述例子表明。

命题 3.5：假设。

1. 如果  是可计算的，那么  也是可计算的。
2. 如果  是可计算可枚举的，那么  也是可计算可枚举的。

通过反证法推导出命题 3.5，因此要证明一个集合是不可计算的（或不可枚举的），只需证明存在一个已知的不可计算的（或不可枚举的）集合，使得可以通过多对一归约将其归约到。例如，假设我们首先证明了对角线停机问题是不可计算的。那么为了证明停机问题也是不可计算的，只需注意到——即自身的可计算配对函数——是一个多对一归约，证明了。

减少性概念通常还伴随着一个关于指定集合何时被认为是相对于一类集合完备的概念，即每个类中的集合都可以被归约到该集合，并且该集合本身是该类的成员。作为一个初始的例子，我们有以下内容：

定义 3.4：如果满足以下条件，则称集合是多对一（或 m-）完备的可计算可枚举集合：

1. 是可计算可枚举的；
2. 对于所有可计算可枚举集合，。

一个明显的完全可枚举集合的例子是。因为和是可计算关系，根据命题 3.2 可知是可枚举的。另一方面，如果，那么当且仅当，从而表明。

尽管如此，通常将而不是作为规范的完全可枚举集合。虽然乍一看似乎包含的“计算信息较少”，但很容易看出也是这样的，即每个可枚举集合都可以通过 m-可约化到它。假设，我们可以定义一个函数

由于明显是部分可计算的，s-m-n 定理（3.1）给出了一个总递归函数，使得。然后我们有

这些双条件成立是因为当且仅当是（即常数 1 函数）而不是到处未定义的函数时。但是，由于后一条件等价于，是一个多对一的归约，显示。

这说明了在某种意义上，决定是否属于也可以理解为对可计算可枚举集合的普遍性，或者说不存在比更难解决的可计算可枚举集合。尽管如此，存在比更难解决的问题，即使我们拥有一个决策算法。例如，从下面给出的结果可以得出结论，虽然可以 m-归约到，但不能 m-归约到。这说明了如何使用 m-归约来研究解决计算问题的相对难度。

这些考虑自然地引出了困难程度的概念 - 另一个可以根据不同的可约性概念明确的概念。对于多对一可约性的版本由以下定义给出：

定义 3.5：如果和彼此多对一可约 - 即，和 - 那么我们说和是多对一等价的，并且我们写作 。

从定义 3.3 立即得出是自反的。它也显然是传递的。（因为如果和是可计算函数，分别作为多对一约化显示和的函数，那么它们的组合是一个多对一约化显示的函数。）因此，既然是一个等价关系，定义以下也是有意义的：

定义 3.6：——的多对一（或 m-）度是关于——的等价类，即。如果一个 m-度包含一个可计算集合，则称其为可计算的；如果它包含一个可计算可枚举集合，则称其为可枚举的。

的 m-度将所有与其多对一等价的集合聚集在一起。因此，可以将其视为相对于在后者中以 m-可约性解释时决定成员资格的相对难度的抽象表示。例如，由于我们之前的观察表明，它们因此是“同样困难”的可枚举度。

传统上使用粗体小写罗马字母来表示度（尽管应记住这些是自然数集的集合）。我们接下来按照以下方式定义 m-度的排序：

定义 3.7：设和为 m-度。我们随后定义

1. 当且仅当存在集合 和 集合 ，使得 。
2. 当且仅当 和 。

显然，是 m-度上的偏序关系，即非自反、反对称和传递的。因此，我们引入了传统上被称为多对一（或 m-）度的结构。

与图灵度的类似研究（将在第 3.5.2 节中定义）一起，自从 Post（1944 年）引入多对一度以来，研究的重点一直是结构的调查。这个结构的一些性质如下：

**命题 3.6：**

1. m-度数在补集下不封闭 - 即存在集合使得和不属于 m-度数。
2. 和是不同的 m-度数，它们都是（显然）可计算的。
3. 除了和之外，还有一个可计算的 m-度数 - 即对于任何可计算集合 。此外，对于除了和之外的所有度数，是最小的。
4. 如果是一个 c.e.度和，则也是一个 c.e.度。
5. 在所有 c.e.度中存在一个最大的 m 度，即，对于所有 c.e.度。
6. 任何一对 m 度都有一个最小上界，即和，并且小于和的任何其他上界。由于我们已经看到也是一个偏序，这意味着它还是一个上半格。
7. 在和之间存在一个递归等级。

Post (1944) demonstrated part vii by showing that there exist so-called *simple sets*—i.e., sets  which are c.e. and such that  is infinite but does not contain an infinite c.e. subset. It is easy to see that a simple set cannot be computable. But on the other hand, Post also showed that a simple set cannot be *m*-complete. And it thus follows that if  is simple  but  and thus . Suppose we now understand “degrees of unsolvability” in the passage quoted at the beginning of this section as corresponding to the c.e. *m*-degrees. It thus follows from part v of [Proposition 3.6](https://plato.stanford.edu/entries/recursive-functions/#mdegsprops) that  is indeed a “highest” such degree and also from part vii that there is a lower but still “unsolvable” (i.e., non-computable) degree.

Although the other parts of [Proposition 3.6](https://plato.stanford.edu/entries/recursive-functions/#mdegsprops) have straightforward proofs, they provide some insight into the fact that  is itself a highly complex structure (see, e.g., Odifreddi 1999b: 1). Nonetheless the first two parts of this theorem are often taken to illustrate awkward features of the many-one degrees as an abstract representation of computational difficulty—i.e., the exceptional behavior of  and  and the fact a set and its complement may inhabit different degrees (as is easy to see is exemplified by  and ). It is partly in light of these features that the Turing degrees  are the structure which are now most widely studied in computability theory. But as Post also alludes, it is relative to  for which he was originally unable to demonstrate the existence of a c.e. set of an intermediate degree of unsolvability.

#### 3.5.2 图灵度量

在本节开始提到的相对可计算性概念现在通常是通过在一个集合中的可计算性来分析的。非正式地说，我们说一个函数在集合中是可计算的，只要存在一个算法，该算法在传统意义上是有效的，只是其计算可能依赖于计算一个或多个值。这些值被假定在算法中的一个步骤中可用，即使它本身可能是不可计算的，例如，如果。

这个概念最初是由图灵（1939）引入的，他描述了他所称的标准图灵机模型的一个 oracle（或 o-）机器变体。o-机器除了具有一个只读的 oracle 磁带（和相应的只读头）之外，与普通图灵机相似。在计算开始时，假定在 oracle 磁带上写有一个集合的特征函数。o-机器的转换由其内部状态和读写磁带以及 oracle 磁带上当前扫描的符号决定，从而形式化了机器在计算过程中可以“咨询 oracle”关于一个或多个时间的特征函数的想法。[27]

Kleene（1943）描述了递归函数的类似思想如下：

> 通过一系列应用一般递归模式从给定函数定义的函数，我们称之为给定函数中的一般递归函数；特别地，通过这些方法从头开始定义的函数，我们称之为一般递归函数。（Kleene 1943: 44）

这个特征的前半部分与第 1.5 节中给出的一般递归性定义不同，它允许除了初始函数和之外，函数还可以进入定义函数的方程组中。这对应于假设在计算过程中可以直接使用的值，而无需进行进一步的计算。

也可以修改第 2.2.1 节中给出的部分递归函数的定义，以允许对附加类别的初始函数进行相对化。由于对有限函数集的相对化可以通过对单个函数的连续相对化和函数的图形编码到一个集合中来实现，因此现在通常如下实现：

定义 3.8：给定一个集合，我们定义 A-部分递归函数的类别为包含初始函数并在函数上封闭的最小部分函数类别

当然，自然数有不可数多个子集。但是对于每个这样的子集，我们仍然可以将其理解为一个新的原始函数符号，可以在构造一种可数多个 A-部分递归定义的方式中使用，这种方式在第 2.1.1 节中讨论过。因此，也可以列出所有一元 A-部分递归函数，相对于它们的定义的编码，以获得统一的枚举。

同样地，对于其他的元数也是如此。因此，我们可以很容易地看出，我们可以通过这种方式获得相对化版本的结果，例如 s-m-n 定理（3.1）和普遍性定理（3.2），如下所示：

定理 3.6：对于所有的，存在一个 A-部分可计算函数，它在某种意义上是通用的，对于所有的一元 A-部分可计算函数，存在一个，使得。

这些观察进一步授权使用“可计算于”这一表达来描述既是 A-部分递归且总的函数，也是一个集合，使得在 A-部分递归函数的范围内可计算，并使用符号来表示的域。然后很容易看出，我们之前关于非可计算性的许多证明也适用于相对化的情况——例如，是一个在中可计算但不可计算的集合的例子。

我们现在可以如下定义图灵可约性：

定义 3.9：给定集合 ，如果在计算中可计算，则称为图灵（或 -）可约于 。在这种情况下，我们写作 。

这个定义的一个结果是，当且仅当与（总）-可计算函数相符，该函数由某个索引 的给出。例如，如果我们采用图灵对相对可计算性的描述，我们可以将 视为描述一个可以查询 作为预言机的机器的程序。在这种情况下， 意味着通过执行 在输入上的程序来决定 是否可能，这可能需要在计算过程中对预言机 进行查询。

我们还可以根据以下方式定义关于的完备性概念：

定义 3.10：如果是 c.e.的，并且所有的 c.e.集合都满足，则我们称为图灵完备。

很容易看出蕴含。 （如果是到的 m-归约，则考虑首先计算，然后使用作为 oracle，检查是否，如果是则输出 1，否则输出 0。）因此，也是图灵完备的，即在这个概念下它体现了 c.e.集合中的最大“不可解程度”，无论是以图灵可归约还是以多对一可归约的方式理解。

这样的观察可以通过首先定义图灵等价的概念来精确描述：

定义 3.11：如果和彼此图灵可约，即和 ，那么我们说和是图灵等价的，并且我们写作 。

由于很容易看出是一个等价关系，我们也可以如下定义图灵度的概念：

定义 3.12：—的图灵程度是关于—的等价类，即—。

现在我们可以如下定义图灵程度的排序：

定义 3.13：设和为图灵程度。我们随后定义

1. 以防万一存在一个集合和一个集合，使得.
2. 以防万一和.

与 m-度数一样，如果包含一个可计算集合和一个可计算枚举（c.e.）度数，则称为可计算图灵度数；如果包含一个 c.e.集合，则称为 c.e.度数。如果我们考虑结构

—这被称为图灵度，很容易看出它是一个偏序。以下是一些说明和一一度之间关系的观察：

**定理 3.7：**

1. 存在一个唯一的可计算图灵度，用（当与 m-度没有歧义时通常写作）。由所有可计算集合组成，是唯一的最小图灵度。
2. 对于所有集合 , 和  以及 .
3. 是所有 c.e. 图灵度中的最大值.
4. 对于任意集合 ,  和如果

 然后

由于和都是（显然）可计算的集合，根据第一部分，我们有，与 m-度不同。而且，与 m-度不同，根据第二部分，我们有。 （如果我们可以通过使用一个作为 oracle 的算法来决定，那么我们也可以通过在我们以前的算法中简单地交换所获得的响应来使用作为 oracle 来决定。）

递归和 c.e.度的结构

自 1950 年代以来，已经广泛研究。首先通过定义集合的操作来考虑它们最基本的属性之一

被称为和的有效连接，因为它编码了在上的“信息”，该信息包含在其偶数成员上，以及在其奇数成员上。如果和都是 c.e.的话。假设我们还定义了操作

对于度数和。然后很容易看出，是相对于结构的上确界。像 m-度数一样，和都形成一个上半格，即一个偏序，其中总是存在最小上界。[28]

给定，我们还可以考虑——即，与上述对应的相对于 oracle 的对角线停机问题的集合。称为的跳跃，我们也写作。这个符号也用于通过设置为某个代表来表示图灵度上的操作。以下汇集了关于集合和度数上的跳跃操作的几个事实：

命题 3.7：对于任何具有和的集合：

1. 如果可计算，则。
2. 在计算机科学中，递归是指一个函数在其定义中调用自身的过程。
3. 如果条件 A 成立，则执行操作 B；如果条件 C 成立，则执行操作 D。
4. 如果条件 E 成立，则执行操作 F。
5. 如果在中是 c.e.，那么。

命题 3.7 的第二部分记录了这样一个事实：对于任何集合的可计算性相对化，是 c.e.但不可计算的基本结果成立。由此可得，因此也可得到对于任何集合迭代跳跃操作的结果产生一个序列。

作为图灵程度的基准，我们还定义集合。

和度数。请注意，后者对应于一个线性有序序列

---

![diagram link to extended description below](https://plato.stanford.edu/entries/recursive-functions/fig2.svg)

图 2：图灵度数。[图 2 的扩展文本描述可用。]

如图 2 所示，可以使用这个序列来对第 3.2 节中定义的许多问题进行分类。

这样的分类说明了集合内部的位置可以被理解为离可计算性有多远的度量，即其不可解性或困难程度。然而，与其他常规的测量尺度不同，的结构既不简单，也不总是容易辨别。这一点的一些证据是由 Post（1944）提出的以下问题的答案被提出但未被回答[29]：

问题 3.1（Post 的问题）：是否存在一个 c.e.程度，使得？

Post 的问题最终由 Friedberg（1957）和 Muchnik（1956）独立肯定地回答，他们证明了以下事实：

定理 3.8：存在 c.e.集合和，使得和。因此，如果和，则和，因此也和。

Friedberg-Muchnik 定理（3.8）的证明需要开发一种称为优先级方法（或伤害方法）的新技术，该方法已成为可计算性理论后续发展的核心工具。该方法提供了一种构造具有特定属性的 c.e.集合的方法，可以描述如下：

1. 所需的属性被分为无限列表的要求，如果所有要求都满足，则将满足。
2. 然后将要求与优先级相关联，这些优先级对应于构建过程中要保持满足的顺序 - 例如，可能具有最高（或“最重要”）优先级，第二高优先级；
3. 然后，每个阶段都尝试满足当前未满足的最高优先级要求，方法是通过向当前近似值添加数字或在后续阶段禁止其他数字进入；
4. 可能会发生这样的情况，即在某个阶段满足某个要求会导致另一个要求不满足（即，阶段会损害）。
5. 在这种情况下，按优先顺序咨询以确定采取什么行动。

在定理 3.8 的情况下，使用这种技术同时构造两个 c.e.集合和，这两个集合的程度介于和之间，通过在要求之间交替进行，这些要求在偶数阶段确保和，在奇数阶段确保。

从 1960 年代开始，优先方法在可计算性理论中得到了复杂的应用，以研究和的结构。[30]可以通过这种方式或更基本的技术获得一些说明性的结果，如下所示：

1. 有无限多个不同的图灵度。特别地，对于给定的度，使得的集合是可数的，使得的集合是不可数的（Kleene＆Post 1954）。
2. 对于每个度，存在一个度与不可比的，即和。此外，存在一组两两不兼容的度（Kleene＆Post 1954）。
3. 存在最小度，即不存在这样的度（Sacks 1963b）。因此，一般来说不是一个稠密的顺序。（但根据下面的事实 vii，不存在最小的可计算度）。
4. 存在一对度数 和 ，它们没有最大下界。因此，尽管 是一个上半格，但它不是一个格（Kleene 和 Post 1954）。对于 也是如此（Lachlan 1966）。
5. 每个可数的偏序集可以嵌入到（Thomason 1971）。然而，对于，存在有限的非分配格无法嵌入（Lachlan 和 Soare 1980）。
6. 存在一个非 c.e. 度数 （Shoenfield 1960）。
7. 对于任何 c.e.度，存在一个 c.e.度，使得（Sacks 1964）。因此，与图灵度一般不同，c.e.度是密集有序的。
8. 对于任何 c.e.度，存在不可比较的 c.e.度，使得（Sacks 1963b）。
9. 让成为具有和的语言中的结构的一阶理论。不仅是不可判定的（Lachlan 1968），它事实上是真二阶算术的多对一等价（Simpson 1977）。
10. 如同很容易证明的那样，连接操作的递归在具有递归和函数的语言中是可定义的（Shore＆Slaman 1999）。

这些属性证明了作为数学结构的递归的复杂性。一个相关的问题是递归是否在以下意义上是刚性的：

问题 3.2：是否存在一个非平凡的递归自同构，即保持并且不是恒等映射的映射？

对这个问题的否定回答将表明与其他程度的关系唯一确定了相对于的不可解性程度。最近的研究已经指出了这个方向（例如，Slaman 2008）。然而，在 2020 年更新本条目时，问题 3.2 仍然是计算可行性理论中一个重要的开放问题，其起源可以追溯到图灵、Post 和 Kleene 的原始基础工作。

### 3.6 算术和分析层次

一对一程度和图灵程度有时被称为层次，因为它们以相对可计算性的方式确定了自然数的子集集合的排序。在 20 世纪 40 年代和 50 年代的一系列论文中，Kleene（从 1943 年开始）和 Mostowski（从 1947 年开始）意识到，还可以通过最简单的谓词在一阶或二阶算术语言中定义集合的逻辑复杂性来施加另一种排序。这个想法导致了所谓的算术和分析层次，两者都可以理解为根据其定义（或描述）复杂性对集合进行分类。正如我们将看到的，所得到的分类与相对可计算性相关。它们在形式上也类似于计算复杂性理论中研究的其他可定义层次（例如，多项式层次）和描述集合论中的层次（例如，Borel 和投射层次）。

#### 3.6.1 算术层次结构

根据第 3.3 节中给出的定义，如果一个关系的特征函数是可计算函数，那么它被称为可计算的；如果一个关系是可计算函数的范围，那么它被称为可计算可枚举的。为了介绍算术层次结构，使用一种语义类似于在第 1.3 节中讨论的证明论概念的算术可表示性的替代特征是有用的。

回顾一下，一阶算术语言包含原始符号，分别用于表示自然数上的小于关系、后继、加法和乘法函数，以及第一个自然数 0。一阶算术公式是使用这些表达式、变量、命题连接词和一阶量词构建的，其中变量的范围是自然数。还要记住，一阶算术的标准模型是指符号接收其预期解释的结构。最后，我们说一个 -公式定义了一个关系，当且仅当 。例如，定义了小于等于关系，定义了偶数，以及

定义了质数。

定义 3.14：如果一个公式只包含有界的一阶量词，即形如和的形式，那么它被称为类。如果一个公式是形式的，那么它被称为类。最后，如果一个公式在语义上等价于一个公式和一个公式，即当且仅当对于所有 。

标准做法是根据量词复杂性将公式的这种句法分类扩展到可以由给定类中的公式定义的自然数上的集合和关系。因此，例如，是一个公式，相应地，自然数上的关系被称为。另一方面，虽然是一个公式，但偶数集也可以由定义。因此，由于存在这个后一定义，这个集合也被归类为，这个定义在算术层次上更简单。

将这些分类与可计算性理论概念相关联的第一步是由以下内容提供的：

**命题 3.8：**

1. 如果存在一个定义了的公式，则关系是可计算可枚举的。
2. 如果且仅当存在一个定义的公式，关系才是可计算的。

命题 3.8 可以通过直接展示每个部分递归函数都可以构造一个相应的公式来证明，该公式的逻辑结构模拟了前者定义中的步骤。这可以通过使用一个算术可定义的有限序列编码来形式化原始递归，并使用无界存在量词来表达最小化（例如，参见 Kaye 1991 年第 3 章）。但也可以通过展示存在一个所谓的通用公式来以统一的方式获得命题 3.8。为了指定这样的公式，首先注意到可以有效地枚举所有具有自由变量的公式为，并定义相应的枚举为…。然后我们有以下结果：

定理 3.9（Kleene 1943 年）：对于所有，存在一个公式，使得对于所有具有 k 个自由变量的公式，以下双向条件成立。

在标准模型中保持所有的。

定理 3.9 可以通过首先观察到一个-公式的真值等价于某个的事实来证明。接下来注意到在 2.1.2 节中记录的观察序列足以表明所有的-可定义关系都是原始递归的。因此，我们可以考虑一个算法，该算法在输入上使用来构造，然后执行一个无界搜索，以找到一个使得成立的。通过对 Church 的论题的呼吁（当然，可以用一个明确的构造来替代），存在一个可计算函数，对于该函数，我们有以下结果：

为了构造定理 3.9 所承诺的公式，观察到来自语法算术化的标准技术允许我们获得一个-公式，该公式定义了在 2.2.2 节中引入的 Kleene-谓词。最后，我们可以定义。命题 3.8 的第一部分现在通过令为这样的，然后取其中的，其中是这样的，得到。这通常被表述为所谓的枚举定理，可以与定理 3.2 进行比较：

命题 3.9：如果存在一个数（称为的 c.e.索引），那么一个关系是可计算可枚举的当且仅当由定义。

命题 3.8 的第二部分可以通过观察到如果是递归的，那么和都是 c.e.的来得到。因此，如果是的一个 c.e.索引，那么由定义，等价于一个-公式，因为。

公式类和因此提供了可计算和可计算可枚举集合的另一种算术特征。这些类还定义了算术层次的最低级别，其完整的一般性定义如下：

定义 3.15：为了简化符号，类和都被用作类的替代名称。如果一个公式的形式为，则称其属于类；如果一个公式的形式为，则称其属于类。如果一个公式在语义上等价于一个-公式和一个-公式，则称其为-公式。

因此，一个公式只有在形式为时才是递归的。

（其中存在个量词类型的交替，如果是偶数则为，如果是奇数则为）。类似地，一个-公式的形式为

, , 和 也是标准用来表示可以由相应句法类中的公式定义的集合和关系的类。例如，根据命题 3.8 的第二部分，是（因为它是可计算的），根据第一部分，和是（因为它们是 c.e.）。因此，它们的补集和都是。很容易看出，是的事实可以用上面引入的 -谓词的算术化表达式表示为。类似地，是 -可定义的，因为只有有限个参数的定义可以表达为。

这是一阶逻辑的前纳式范式定理的结果，即每个 -公式可证明等价于形式之一，或（例如，Boolos，Burgess，和 Jeffrey 2007：ch. 19.1）。因此，根据可证明等价性，每个这样的公式都是或某个 的形式。由于在定义 3.15 中允许量词块为空是常规的，因此有

 和

这些包含是严格的事实是所谓的层次定理的结果，其中一个简单形式可以陈述如下：

定理 3.10（Kleene 1943）：对于所有的，存在一个集合是-可定义的但不是-可定义的，因此也不是-也不是-可定义的。因此，对于任何，是-可定义的但不是-可定义的，因此也不是-也不是-可定义的。

可以通过直接的语法构造来证明定理 3.10。例如，基于通用-谓词的定义，可以证明在算术层次的每个级别上，存在一个-公式，它在标准模型中定义了-满足的意义上。

对于所有的和（在这里我们还定义了我们的哥德尔编号与上面介绍的-公式的索引一致）。现在考虑-公式，让是由定义的集合。一个标准的对角线论证表明不能是-可定义的，而且如果在-公式的枚举中，那么是一个-公式，它不能被证明等价于一个-公式（参见，例如，Kaye 1991: ch. 9.3）。因此，正如 Kleene（1943: 64）观察到的那样，层次定理的一部分意义在于它说明了悖论可以如何形式化，从而得到了塔斯基关于真理不可定义性的分层形式的定理（参见关于自我引用的条目）。

我们还可以根据算术层次的级别定义完备性的概念，如下所示：如果是-可定义的，并且对于所有的-可定义的，我们有（类似地，对于-完备也是如此）。很容易证明，除了是多对一完备之外，还是-完备的。类似地，是-完备的，是-完备的，是-完备的。这些观察结果可以归结为一个更一般的结果，它将算术层次与图灵度联系起来，并且从中定理 3.10 也可以作为一个推论得到。

定理 3.11（Post 1944）：

1. 是可定义的，当且仅当在某个可定义集合中是可计算可枚举的。
2. 对于所有的，是完全的。
3. 当且仅当在中是可计算可枚举的时，是可定义的。
4. 如果且仅如果是可定义的。

定理 3.11 的各个部分是根据先前的定义以及命题 3.2 和 3.7 得出的。特别要注意的是，根据定理 3.11 的 ii 和 iv 部分以及命题 3.7 的 vii 部分，是类中的一个集合的一个例子，从中也可以得出。这一观察进一步加强了层次定理（3.10），并显示和如图 3 所示。

![a diagram link to extended description below](https://plato.stanford.edu/entries/recursive-functions/fig3.svg)

图 3：算术层次结构。[有关图 3 的扩展基于文本的描述可用。]

第 3.11 定理的第四部分也可以理解为推广命题 3.4（即 Post 定理）。特别地，它将可定义集合特征化为那些在某个完全集合中既可计算枚举又可计算枚举的集合。将其限制为情况，这个观察也可以用来提供可定义集合的独立计算特征，扩展了命题 3.8 给出的可定义集合和可定义集合的特征。

定义 3.16：如果存在一个可计算的有限集序列，使得

其中表示存在且等于 1。

如果是 c.e.，那么很明显是可计算的极限。因为如果是可计算函数的范围，那么我们可以取为，其中情况下。在极限可计算的一般情况下，集合序列可以被看作是的近似，它不必以这种方式单调增长，而是可以同时增长和缩小，只要总是存在一个阶段，使得对于所有，如果且仅当。根据 Putnam（1965）的说法，极限可计算集合也可以被描述为所谓的试错谓词，即通过遵循一个猜测过程来确定成员资格，该过程最终收敛于形式的正确答案的问题？

以下传统上被称为极限引理：

定理 3.12（Shoenfield 1959）：以下是等价的：

1. 是有限可计算的。

我们已经看到命题 3.11 的第四部分将图灵可约集合表征为可定义集合。因此，定理 3.12 通过证明可定义集合与有限可计算集合的重合，扩展了命题 3.8 中给出的可计算（即可定义）和可计算可枚举（即可定义）集合的表征。

#### 3.6.2 分析层次结构

Kleene 在一系列论文中引入了现在被称为分析层次的概念（1955a，b，c），这直接建立在他在 1943 年引入算术层次的基础上。他的近因是为了提供一个所谓的超算术集合的可定义性理论特征，即那些可以通过图灵跳跃的可构造序数的超限迭代来计算的集合。另一方面，Mostowski（1947）已经注意到自然数集的算术层次和在描述集合论中研究的点集层次之间的相似性，即波雷尔、勒贝格、卢辛和苏斯林在 20 世纪初的工作中的元素集合（完备、可分离的可度量空间，如实数、康托尔空间或巴尔空间）的集合。Addison（1954）在 Kleene 的博士论文中开始，通过展示 Kleene 的初始工作也可以用来提供这一传统中几个经典结果的有效版本，进一步完善了 Mostowski 的比较。我们在这里介绍关于分析层次的基本定义，以及一些说明它与这些其他发展的联系的结果。

定义 3.17：二阶算术的语言扩展了一阶算术的语言，其中包括二元关系符号，以及集合变量和集合量词和。的标准模型是结构。集合量词的预期范围是（即的幂集），而的预期解释是数字是集合的成员，其中。 （有关 Reverse Mathematics 的更多信息和其在数学形式化中的使用，请参见 Reverse Mathematics 的条目。）

注意，在一般情况下，一个公式可能同时具有自由数变量和自由集合变量。如果由这样的公式定义，则称其为解释性的。Kleene（1955a）证明了解释性关系的一个正常形式定理，该定理表明如果是解释性的，则可以用形式为的公式来定义。

 或者

其中只包含数量化符号，而取决于是偶数还是奇数。因此，可以将-公式及其定义的集合分为以下类别：

**定义 3.18：**

我们用和来表示不包含集合量词的-公式的类（即所谓的算术公式）。如果一个公式是形式的，那么它属于这个类，其中和是关系可定义的，如果它由一个-公式定义。类似地，如果一个-公式是形式的，那么它属于这个类，其中和是关系可定义的，如果它由一个-公式定义。如果一个关系既可以由一个-公式又可以由一个-公式定义，那么它是-可定义的。

因此，正如在算术层次结构的情况一样，我们有

 和

此外，还可以证明算术集合的一个版本的枚举定理，可以用来得到层次定理的以下推广：

定理 3.13（Kleene 1955a）：对于所有的，存在一个集合，它是-可定义的但不是-可定义的，因此对于任何也既不是-可定义的也不是-可定义的。因此，对于任何，是-可定义的但不是-可定义的，也既不是-可定义的也不是-可定义的。

为了提供一些分析层次的示例，记录以下内容是有用的：

定义 3.19：当且仅当存在一个算术公式，其唯一的自由集合变量是，并且没有自由数字变量，使得是标准模型中唯一满足的集合。

真算术（）对应于在标准模型中为真的一阶算术句子的哥德尔数集，即。在分析层次本身的定义之前，希尔伯特和伯奈斯已经证明了以下内容：

定理 3.14（Hilbert＆Bernays 1939：§5.2e）：在递归中隐式定义。

然后很容易证明以下内容：

命题 3.10（Spector 1955）：如果在递归中隐式定义，则在函数中可定义。

由此可见，递归是可定义的。另一方面，根据塔斯基关于真理不可定义性的定理，递归不是算术可定义的，即对于任何。这进一步表明，分析集合适当地扩展了算术集合。

递归可定义的子集与克里尼原始研究的超算术集合类有关，通常表示为。的定义取决于一种称为的构造序数符号系统的定义，克里尼在 1938 年引入了这种系统。（在定义中，他还证明了递归定理 3.5-参见罗杰斯 1987 年：第 11.7 章和 Y. Moschovakis 2010 年。）可以非正式地描述为自然数集的集合类，其中是一个接收符号的序数，即当它可以从图灵跳跃的超递归序数迭代中计算出来时。直到第一个非递归序数为止。[32]克里尼的原始结果如下：[33]

定理 3.15（克里尼 1955b）：如果且仅当。

在分析层次结构中的下一步涉及对可定义集合的表征。Kleene（1955a）最初使用二阶算术的一种变体建立了他的正常形式定理，其中包含函数量词，这些函数量词的范围是而不是范围（Rogers 1987：ch. 16.2）。在这种设置下，可以证明以下内容：

命题 3.11：当且仅当存在一个可计算（即可定义）的关系，使得

 其中表示。

对于每个这样的关系，我们还可以定义一个可计算的树，其中包含有限序列，使得对于所有的适当的初始子序列，成立。因此，这棵树中的叶节点对应于第一个使得成立的位置。因此，递归路径对应于一个函数，使得，这又是对的证明。因此，当且仅当是良基的时候，成立。由于可以有效地枚举可计算树，因此也不难证明以下内容：

命题 3.12：对于可定义集合，良基可计算树的索引集是 m-完备的，即对于所有的和，成立。

回顾一下，表示克里尼的序数的自然数集合，一个相关的结果如下：

命题 3.13：是-complete。

可以使用层次定理 3.13 证明既不是-可定义的。这些结果为基于定理 3.15（参见 Rogers 1987：ch. 16.4）的构造序数的递归分析提供了基础，该分析建立在-和-可定义集合的结构上。

前述结果都涉及使用-公式来描述自然数集合。将分析层次与经典描述性集合论连接起来的最初步骤是通过考虑定义子类的公式来进行的。在这种情况下，可以将表示为其特征函数的图形进行标识，即作为一个无限序列，其第 th 个元素为 1，如果为 0。通过这种方式，具有单个自由集合变量的公式可以被理解为定义康托尔空间的子集，该空间由所有无限 0-1 序列组成，并且具有自由的公式作为定义的子类。

在描述性集合论中，在定义 Borel 集合和投射集的背景下，给出了一系列拓扑定义的平行序列。首先回忆一下，定义一个拓扑空间的一种方法是将所有函数集合作为基本开集，使得对于某些和 。现在，粗体 Borel 层次结构被定义为所有的开集的集合，(对于 ) 被定义为所有集合的补集的集合，被定义为所有可数并集的集合，其中 。(因此表示闭集的集合，表示所谓的集合，集合等等) 这些类的并集对应于粗体 Borel 集合，也可以被描述为包含在闭合于可数并集和补集下的最小类的集合。所谓的解释集合被定义为 Borel 集合的连续映射，用表示，而余解释集合被定义为解释集合的补集，用表示。最后，用来表示解释集合和余解释集合的交集。

Addison (1958, 1959) 观察到，这些经典定义可以通过在集合的定义中限制为可计算并集来实现。这导致了所谓的 Borel 层次结构的 lightface 版本，通常使用相同的符号表示，并用于算术层次的级别以及 (即 lightface 解释)，(即 lightface 余解释) 和集合的相应定义。特别地，这一系列定义暗示了定理 3.15 和 Suslin 的以下经典结果之间的类比：

定理 3.16 (Suslin 1917)：集合的类等于 Borel 集合的类。

可以从 Kleene 对 Theorem 3.15 的原始证明中获得一个有效的 Theorem 3.16 形式，该形式涉及到由可计算代码表示的子集与光面 Borel 集之间的关系（参见，例如，Y. Moschovakis 2009: ch. 7B）。Addison 还表明，同样可以获得 Lusin 定理（1927 年）的有效版本，即“任意两个不相交的解析集可以被一个 Borel 集分离”，以及 Kondô定理（1939 年）的有效版本，即“每个-关系可以被一个-关系一致化”。参见 Y. Moschovakis（2009: ch. 2E,4E）和 Simpson（2009: ch. V.3,VI.2）

## 4. 进一步阅读

递归函数和可计算性理论早期发展的历史调查由 Sieg（2009），Adams（2011）和 Soare（2016：第 V 部分）提供。在第 1 节中讨论的许多原始来源被收录在 Davis（1965），van Heijenoort（1967）和 Ewald（1996）中。在初级和中级水平上对可计算性理论的教科书介绍包括 Hopcroft＆Ulman（1979），Cutland（1980），Davis，Sigal 和 Weyuker（1994）和 Murawski（1999）。在第 2 节和第 3 节（直到 Post 问题的表述）中呈现的材料的原始教科书阐述包括 Kleene（1952），Shoenfield（1967）和 Rogers（1987；第一版 1967）。许多一对一和图灵度的结构在更高级的教科书中呈现，例如 Sacks（1963a），Shoenfield（1971），Hinman（1978），Soare（1987），Cooper（2004）和 Soare（2016）。除了 Shoenfield（1967：第 7 章）和 Rogers（1987：第 16 章）之外，超算术和分析层次的经典处理是 Sacks（1990）。Y. Moschovakis（2009，第一版 1980）和 Kechris（1995）中发展了经典和有效的描述性集合论。Simpson（2009）发展了可计算性理论与逆向数学之间的联系。（这对应于在语言中制定全二阶算术的子理论的公理研究。这些理论形成了一个层次结构，其中可以发展出大部分经典数学，并且其模型可以通过可计算性理论手段来表征-例如，递归集合形成最小的Π1-模型，算术集合形成最小的Σ1-模型等。请参阅逆向数学的条目。）对子递归层次的处理以及与证明论和理论计算机科学的联系由 Péter（1967），Rose（1984），Clote＆Kranakis（2002：第 6-7 章）和 Schwichtenberg＆Wainer（2011）提供。 在本条目中，对许多历史和数学主题进行了概述，这些主题在奥迪弗雷迪（Odifreddi）的《经典递归理论》（1989 年，1999a）的两卷中也有更详细的介绍，其中包含了许多额外的历史参考资料。

<!--md-padding-ignore-begin-->
## Bibliography

Note: In cases where an English translation is available, page references in the main text and notes are to the indicated translations of the sources cited below.

* Ackermann, Wilhelm, 1928a, “Über die Erfüllbarkeit gewisser Zählausdrücke”, *Mathematische Annalen*, 100: 638–649. doi:10.1007/BF01448869
* Ackermann, Wilhelm, 1928b [1967], “Zum Hilbertschen Aufbau der reellen Zahlen”, *Mathematische Annalen*, 99(1): 118–133. Translated as “On Hilbert’s Construction of the Real Numbers”, in van Heijenoort 1967: 493–507. doi:10.1007/BF01459088
* Adams, Rod, 2011, *An Early History of Recursive Functions and Computability: From Gödel to Turing*, Boston: Docent Press.
* Addison, J.W., 1954, *On Some Points of the Theory of Recursive Functions*, PhD thesis, University of Wisconsin.
* –––, 1958, “Separation Principles in the Hierarchies of Classical and Effective Descriptive Set Theory”, *Fundamenta Mathematicae*, 46(2): 123–135. doi:10.4064/fm-46-2-123-135
* –––, 1959, “Some Consequences of the Axiom of Constructibility”, *Fundamenta Mathematicae*, 46(3): 337–357. doi:10.4064/fm-46-3-337-357
* Basu, Sankha S. and Stephen G. Simpson, 2016, “Mass Problems and Intuitionistic Higher-Order Logic”, *Computability*, 5(1): 29–47. doi:10.3233/COM-150041
* Bimbó, Katalin, 2012, *Combinatory Logic: Pure, Applied and Typed*, Boca Raton, FL: Chapman & Hall.
* Boolos, George S., John P. Burgess, and Richard C. Jeffrey, 2007, *Computability and Logic*, fifth edition, Cambridge: Cambridge University Press. doi:10.1017/CBO9780511804076
* Calude, Cristian, Solomon Marcus, and Ionel Tevy, 1979, “The First Example of a Recursive Function Which Is Not Primitive Recursive”, *Historia Mathematica*, 6(4): 380–384. doi:10.1016/0315-0860(79)90024-7
* Church, Alonzo, 1936a, “A Note on the *Entscheidungsproblem*”, *Journal of Symbolic Logic*, 1(1): 40–41. doi:10.2307/2269326
* –––, 1936b, “An Unsolvable Problem of Elementary Number Theory”, *American Journal of Mathematics*, 58(2): 345–363. doi:10.2307/2371045
* Clote, Peter and Evangelos Kranakis, 2002, *Boolean Functions and Computation Models*, (Texts in Theoretical Computer Science. An EATCS Series), Berlin, Heidelberg: Springer Berlin Heidelberg. doi:10.1007/978-3-662-04943-3
* Cooper, S. Barry, 2004, *Computability Theory*, Boca Raton, FL: Chapman & Hall.
* Cutland, Nigel, 1980, *Computability: An Introduction to Recursive Function Theory*, Cambridge: Cambridge University Press. doi:10.1017/CBO9781139171496
* Davis, Martin (ed.), 1965, *The Undecidable: Basic Papers on Undecidable Propositions, Unsolvable Problems and Computable Functions*, New York: Raven Press.
* –––, 1982, “Why Gödel Didn’t Have Church’s Thesis”, *Information and Control*, 54(1–2): 3–24. doi:10.1016/S0019-9958(82)91226-8
* Davis, Martin, Ron Sigal, and Elaine J. Weyuker, 1994, *Computability, Complexity, and Languages: Fundamentals of Theoretical Computer Science*, second edition, (Computer Science and Scientific Computing), Boston: Academic Press, Harcourt, Brace.
* Dean, Walter, 2016, “Algorithms and the mathematical foundations of computer science)”, in *Gödel’s Disjunction: The Scope and Limits of Mathematical Knowledge*, Philip Welch and Leon Horsten (eds.), Oxford: Oxford University Press, pp. 19–66. doi.org/10.1093/acprof:oso/9780198759591.003.0002
* –––, 2020, “Incompleteness via Paradox and Completeness”, *The Review of Symbolic Logic*, 13(2), 541–592. doi:10.1017/S1755020319000212
* Dedekind, Richard, 1888, *Was Sind Und Was Sollen Die Zahlen?*, Braunschweig: Vieweg.
* Dreben, Burton and Akihiro Kanamori, 1997, “Hilbert and Set Theory”, *Synthese*, 110(1): 77–125. doi:10.1023/A:1004908225146
* Enderton, Herbert B., 2010, *Computability Theory: An Introduction to Recursion Theory*, Burlington, MA: Academic Press.
* Epstein, Richard and Walter A. Carnielli, 2008, *Computability: Computable Functions, Logic, and the Foundations of Mathematics*, third edition, Socorro, NM: Advance Reasoing Forum. First edition, Pacific Grove: Wadsworth & Brooks 1989.
* Ewald, William Bragg (ed.), 1996, *From Kant to Hilbert: A Source Book in the Foundations of Mathematics.*, New York: Oxford University Press.
* Feferman, Solomon, 1995, “Turing in the land of ”, in *The Universal Turing Machine a Half-Century Survey*, Rolf Herken (ed.), Berlin: Springer, pp. 103–134.
* Fibonacci, 1202 [2003], *Fibonacci’s Liber Abaci: A Translation into Modern English of Leonardo Pisano’s Book of Calculation*, L. E. Sigler (ed.), Berlin: Springer.
* Friedberg, R. M., 1957, “Two Recursively Enumerable Sets of Incomparable Degrees of Unsolvability (Solution of Post’s Problem, 1944)”, *Proceedings of the National Academy of Sciences*, 43(2): 236–238. doi:10.1073/pnas.43.2.236
* Gandy, Robin, 1980, “Church’s Thesis and Principles for Mechanisms”, in *The Kleene Symposium*, Jon Barwise, H. Jerome Keisler, and Kenneth Kunen (eds.), (Studies in Logic and the Foundations of Mathematics 101), Amsterdam: Elsevier, 123–148. doi:10.1016/S0049-237X(08)71257-6
* Gödel, Kurt, 1931 [1986], “Über formal unentscheidbare Sätze der Principia Mathematica und verwandter Systeme, I” (On Formally Undecidable Propositions of *Principia Mathematica* and Related Systems I), *Monatshefte für Mathematik und Physik*, 38: 173–198. Reprinted in Gödel 1986: 144–195.
* –––, 1934 [1986], “On Undecidable Propositions of Formal Mathematical Systems”, Princeton lectures. Reprinted in Godel 1986: 338-371.
* –––, 1986, *Collected Works. I: Publications 1929–1936*, Solomon Feferman, John W. Dawson, Jr, Stephen C. Kleene, Gregory H. Moore, Robert M. Solovay, and Jean van Heijenoort (eds.), Oxford: Oxford University Press.
* –––, 2003, *Collected Works. V: Correspondence H–Z*, Solomon Feferman, John W. Dawson, Jr, Warren Goldfrab, Charles Parsons, and Wilfried Sieg (eds.), Oxford: Oxford University Press.
* Grassmann, Hermann, 1861, *Lehrbuch Der Arithmetik Für Höhere Lehranstalten*, Berin: Th. Chr. Fr. Enslin.
* Greibach, Sheila A., 1975, *Theory of Program Structures: Schemes, Semantics, Verification*, (Lecture Notes in Computer Science 36), Berlin/Heidelberg: Springer-Verlag. doi:10.1007/BFb0023017
* Grzegorczyk, Andrzej, 1953, “Some Classes of Recursive Functions”, *Rozprawy Matematyczne*, 4: 3–45.
* Grzegorczyk, A., A. Mostowski and C. Ryll-Nardzewski, 1958, “The Classical and the ω-Complete Arithmetic”, *The Journal of Symbolic Logic*, 23(2): 188–206. doi:10.2307/2964398
* Herbrand, Jacques, 1930, “Les Bases de la Logique Hilbertienne”, *Revue de Metaphysique et de Morale*, 37(2): 243–255.
* –––, 1932, “Sur La Non-Contradiction de l’Arithmétique.”, *Journal Für Die Reine Und Angewandte Mathematik (Crelles Journal)*, 166: 1–8. doi:10.1515/crll.1932.166.1
* Hilbert, David, 1900 [1996], “Mathematische Probleme. Vortrag, Gehalten Auf Dem Internationalen Mathematiker-Congress Zu Paris 1900”, *Nachrichten von Der Gesellschaft Der Wissenschaften Zu Göttingen, Mathematisch-Physikalische Klasse*, 253–297. English translation as “Mathematical Problems” in Ewald 1996: 1096–1105.
* –––, 1905 [1967], “Über Die Grundlagen Der Logik Und Der Arithmetik”, in *Verhandlungen Des 3. Internationalen Mathematiker-Kongresses : In Heidelberg Vom 8. Bis 13. August 1904*, Leipzig: Teubner, pp. 174–185. English translation as “On the foundations of logic and and arithmetic” in van Heijenoort 1967: 129–138.
* –––, 1920, “Lectures on Logic ‘Logic-Kalkül’ (1920)”, reprinted in Hilbert 2013: 298–377.
* –––, 1922 [1996], “Neubegründung der Mathematik. Erste Mitteilung”, *Abhandlungen aus dem Mathematischen Seminar der Universität Hamburg*, 1(1): 157–177. English translation as “The new grounding of mathematics: First report” in Ewald 1996: 1115–1134. doi:10.1007/BF02940589
* –––, 1923 [1996], “Die logischen Grundlagen der Mathematik”, *Mathematische Annalen*, 88(1–2): 151–165. English translation as “The logical foundations of mathematics” in Ewald 1996: 1134–1148. doi:10.1007/BF01448445
* –––, 1925 [2013], “‘Über das Unendliche’ (WS 1924/25)”, Lecture notes. Collected in Hilbert 2013: 656–759.
* –––, 1926 [1967], “Über das Unendliche”, *Mathematische Annalen*, 95(1): 161–190. Translated as “On the Infinite” in van Heijenoort 1967: 367–392. doi:10.1007/BF01206605
* –––, 1928 [1967], *Die Grundlagen der Mathematik. Mit Zusätzen von H. Weyl und P. Bernays*, (Hamburger Mathematische Einzelschriften 5), Springer Fachmedien Wiesbaden GmbH. Translated as “The Foundations of Mathematics”, in van Heijenoort 1967: 464–479.
* –––, 1930 [1998], “Probleme der Grundlegung der Mathematik”, *Mathematische Annalen*, 102: 1–9. English translation as “Problems of the Grounding of Mathematics” in Mancosu 1998, 223–233. doi:10.1007/BF01782335
* –––, 2013, *David Hilbert’s Lectures on the Foundations of Arithmetic and Logic 1917–1933*, William Ewald and Wilfried Sieg (eds.), Berlin, Heidelberg: Springer Berlin Heidelberg. doi:10.1007/978-3-540-69444-1
* Hilbert, David and Wilhelm Ackermann, 1928, *Grundzüge der theoretischen Logik*, first edition, Berlin: J. Springer.
* Hilbert, David and Paul Bernays, 1934, *Grundlagen der mathematik*, Vol. 1, Berlin: J. Springer.
* –––, 1939, *Grundlagen der Mathematik*, Vol. II, Berlin: Springer.
* Hinman, Peter G., 1978, *Recursion-Theoretic Hierarchies*, Berlin: Springer.
* Hopcroft, John and Jeffrey Ulman, 1979, *Introduction to Automata Theory, Languages, and Computation*, Reading, MA: Addison-Wesley.
* Kaye, Richard, 1991, *Models of Peano Arithmetic*, (Oxford Logic Guides, 15), Oxford: Clarendon Press.
* Kechris, Alexander S., 1995, *Classical Descriptive Set Theory*, Berlin: Springer. doi:10.1007/978-1-4612-4190-4
* Kleene, S. C., 1936a, “General Recursive Functions of Natural Numbers”, *Mathematische Annalen*, 112(1): 727–742. doi:10.1007/BF01565439
* –––, 1936b, “λ-Definability and Recursiveness”, *Duke Mathematical Journal*, 2(2): 340–353. doi:10.1215/S0012-7094-36-00227-2
* –––, 1936c, “A Note on Recursive Functions”, *Bulletin of the American Mathematical Society*, 42(8): 544–546.
* –––, 1938, “On Notation for Ordinal Numbers”, *Journal of Symbolic Logic*, 3(4): 150–155. doi:10.2307/2267778
* –––, 1943, “Recursive Predicates and Quantifiers”, *Transactions of the American Mathematical Society*, 53(1): 41–41. doi:10.1090/S0002-9947-1943-0007371-8
* –––, 1952, *Introduction to Metamathematics*, Amsterdam: North-Holland.
* –––, 1955a, “Arithmetical Predicates and Function Quantifiers”, *Transactions of the American Mathematical Society*, 79(2): 312–312. doi:10.1090/S0002-9947-1955-0070594-4
* –––, 1955b, “Hierarchies of Number-Theoretic Predicates”, *Bulletin of the American Mathematical Society*, 61(3): 193–214. doi:10.1090/S0002-9904-1955-09896-3
* –––, 1955c, “On the Forms of the Predicates in the Theory of Constructive Ordinals (Second Paper)”, *American Journal of Mathematics*, 77(3): 405–428. doi:10.2307/2372632
* Kleene, S. C. and Emil L. Post, 1954, “The Upper Semi-Lattice of Degrees of Recursive Unsolvability”, *The Annals of Mathematics*, 59(3): 379–407. doi:10.2307/1969708
* Kolmogorov, Andrei, 1932, “Zur Deutung der intuitionistischen Logik”, *Mathematische Zeitschrift*, 35(1): 58–65. doi:10.1007/BF01186549
* Kondô, Motokiti, 1939, “Sur l’uniformisation des Complémentaires Analytiques et les Ensembles Projectifs de la Seconde Classe”, *Japanese Journal of Mathematics :Transactions and Abstracts*, 15: 197–230. doi:10.4099/jjm1924.15.0_197
* Kreisel, George, 1960, “La Prédicativité”, *Bulletin de La Société Mathématique de France*, 79: 371–391. doi:10.24033/bsmf.1554
* Kreisel, George and Gerald E. Sacks, 1965, “Metarecursive Sets”, *Journal of Symbolic Logic*, 30(3): 318–338. doi:10.2307/2269621
* Lachlan, A. H., 1966, “Lower Bounds for Pairs of Recursively Enumerable Degrees”, *Proceedings of the London Mathematical Society*, s3-16(1): 537–569. doi:10.1112/plms/s3-16.1.537
* –––, 1968, “Distributive Initial Segments of the Degrees of Unsolvability”, *Zeitschrift für Mathematische Logik und Grundlagen der Mathematik/Mathematical Logic Quarterly*, 14(30): 457–472. doi:10.1002/malq.19680143002
* Lachlan, A.H and R.I Soare, 1980, “Not Every Finite Lattice Is Embeddable in the Recursively Enumerable Degrees”, *Advances in Mathematics*, 37(1): 74–82. doi:10.1016/0001-8708(80)90027-4
* Lusin, Nicolas, 1927, “Sur Les Ensembles Analytiques”, *Fundamenta Mathematicae*, 10: 1–95. doi:10.4064/fm-10-1-1-95
* Mancosu, Paolo, (ed.), 1998, *From Brouwer to Hilbert: The Debate on the Foundations of Mathematics in the 1920s*, Oxford: Oxford University Press.
* McCarthy, John, 1961, “A Basis for a Mathematical Theory of Computation, Preliminary Report”, in *Papers Presented at the May 9-11, 1961, Western Joint IRE-AIEE-ACM Computer Conference on - IRE-AIEE-ACM ’61 (Western)*, Los Angeles, California: ACM Press, 225–238. doi:10.1145/1460690.1460715
* Médvédév, Ú. T., 1955, “Stépéni trudnosti massovyh problém” (Degrees of Difficulty of Mass Problems), *Doklady Akadémii Nauk SSSR*, 104: 501–504.
* Moschovakis, Yiannis N., 1989, “The Formal Language of Recursion”, *The Journal of Symbolic Logic*, 54(4): 1216–1252. doi:10.2307/2274814
* –––, 1994, *Notes on Set Theory*, (Undergraduate Texts in Mathematics), New York, NY: Springer New York. doi:10.1007/978-1-4757-4153-7
* –––, 2009, *Descriptive Set Theory*, second edition, Providence, RI: American Mathematical Society. First edition Amsterdam/New York: North-Holland, 1980.
* –––, 2010, “Kleene’s Amazing Second Recursion Theorem”, *The Bulletin of Symbolic Logic*, 16(2): 189–239. doi:10.2178/bsl/1286889124
* Mostowski, Andrzej, 1947, “On Definable Sets of Positive Integers”, *Fundamenta Mathematicae*, 34: 81–112. doi:10.4064/fm-34-1-81-112
* Muchnik, A. A., 1956, “On the Unsolvability of the Problem of Reducibility in the Theory of Algorithms”, *Doklady Akadémii Nauk SSSR*, 108: 194–197.
* Murawski, Roman, 1999, *Recursive Functions and Metamathematics: Problems of Completeness and Decidability, Goedel’s Theorems*, Dordrecht, Boston: Kluwer.
* Myhill, John, 1955, “Creative sets”, *Zeitschrift für Mathematische Logik und Grundlagen der Mathematik/Mathematical Logic Quarterly*, 1(2): 97–108. doi:10.1002/malq.19550010205
* Odifreddi, Piergiogio, 1989, *Classical Recursion Theory. volume 1: The Theory of Functions and Sets of Natural Numbers*, (Studies in Logic and the Foundations of Mathematics 125), Amsterdam: North-Holland
* –––, 1999a, *Classical Recursion Theory. volume 2*, (Studies in Logic and the Foundations of Mathematics 143), Amsterdam: North-Holland.
* –––, 1999b, “Reducibilities”, in *Handbook of Computability Theory*, Edward R. Griffor (ed.), (Studies in Logic and the Foundations of Mathematics 140), Amsterdam: Elsevier, 89–119. doi:10.1016/S0049-237X(99)80019-6
* Owings, James C., 1973, “Diagonalization and the Recursion Theorem.”, *Notre Dame Journal of Formal Logic*, 14(1): 95–99. doi:10.1305/ndjfl/1093890812
* Peano, Giuseppe, 1889, *Arithmetices Principia, Nova Methodo Exposita*, Turin: Bocca.
* Peirce, C. S., 1881, “On the Logic of Number”, *American Journal of Mathematics*, 4(1/4): 85–95. doi:10.2307/2369151
* Péter, Rózsa, 1932, “Rekursive Funktionen”, in *Verhandlungen Des Internationalen Mathematiker- Kongresses Zürich*, Vol. 2, pp. 336–337.
* –––, 1935, “Konstruktion nichtrekursiver Funktionen”, *Mathematische Annalen*, 111(1): 42–60. doi:10.1007/BF01472200
* –––, 1937, “Über die mehrfache Rekursion”, *Mathematische Annalen*, 113(1): 489–527. doi:10.1007/BF01571648
* –––, 1951, *Rekursive Funktionen*, Budapest: Akadémiai Kiadó. English translation is Péter 1967.
* –––, 1956, “Die beschränkt-rekursiven Funktionen und die Ackermannsche Majorisierungsmethode”, *Publicationes Mathematicae Debrecen*, 4(3–4): 362–375. doi:10.5486/PMD.1956.4.3-4.34
* –––, 1959, “Rekursivität und Konstruktivität”, in *Constructivity in Mathematics*, Arend Heyting (ed.), North-Holland, Amsterdam, pp. 226–233.
* –––, 1967, *Recursive Functions*, István Földes (trans.), New York: Academic Press. Translation of Péter 1951.
* Poincaré, Henri, 1906, “Les Mathématiques et La Logique”, *Revue de Métaphysique et de Morale*, 14(3): 294–317.
* Post, Emil L., 1944, “Recursively Enumerable Sets of Positive Integers and Their Decision Problems”, *Bulletin of the American Mathematical Society*, 50(5): 284–317. doi:10.1090/S0002-9904-1944-08111-1
* –––, 1965, “Absolutely unsolvable problems and relatively undecidable propositions: Account of an anticipation” (1941) in *The undecidable* M. Davis, ed., New York: Raven Press, 338–433.
* Priest, Graham, 1997, “On a Paradox of Hilbert and Bernays”, *Journal of Philosophical Logic*, 26(1): 45–56. doi:10.1023/A:1017900703234
* Putnam, Hilary, 1965, “Trial and Error Predicates and the Solution to a Problem of Mostowski”, *Journal of Symbolic Logic*, 30(1): 49–57. doi:10.2307/2270581
* Rice, H. G., 1953, “Classes of Recursively Enumerable Sets and Their Decision Problems”, *Transactions of the American Mathematical Society*, 74(2): 358–358. doi:10.1090/S0002-9947-1953-0053041-6
* Robinson, Raphael, 1947, “Primitive Recursive Functions”, *Bulletin of the American Mathematical Society*, 53(10): 925–942. doi:10.1090/S0002-9904-1947-08911-4
* Rogers, Hartley, 1987, *Theory of Recursive Functions and Effective Computability*, second edition, Cambridge, MA: MIT Press. First edition, New York: McGraw-Hill, 1967.
* Rose, H. E., 1984, *Subrecursion: Functions and Hierarchies*, (Oxford Logic Guides, 9), Oxford: Clarendon Press.
* Sacks, Gerald E., 1963a, *Degrees of Unsolvability*, Princeton, NJ: Princeton University Press.
* –––, 1963b, “On the Degrees Less than 0′”, *The Annals of Mathematics*, 77(2): 211–231. doi:10.2307/1970214
* –––, 1964, “The Recursively Enumerable Degrees Are Dense”, *The Annals of Mathematics*, 80(2): 300–312. doi:10.2307/1970393
* –––, 1990, *Higher Recursion Theory*, Berlin: Springer.
* Schwichtenberg, Helmut and Stanley S. Wainer, 2011, *Proofs and Computations*, Cambridge: Cambridge University Press. doi:10.1017/CBO9781139031905
* Shepherdson, J. C. and H. E. Sturgis, 1963, “Computability of Recursive Functions”, *Journal of the ACM*, 10(2): 217–255. doi:10.1145/321160.321170
* Shoenfield, Joseph R., 1959, “On Degrees of Unsolvability”, *The Annals of Mathematics*, 69(3): 644–653. doi:10.2307/1970028
* –––, 1960, “Degrees of Models”, *Journal of Symbolic Logic*, 25(3): 233–237. doi:10.2307/2964680
* –––, 1967, *Mathematical Logic*, (Addison-Wesley serices in logic), Reading, MA: Addison-Wesley.
* –––, 1971, *Degrees of Unsolvability*, Amsterdam: North-Holland.
* Shore, Richard A. and Theodore A. Slaman, 1999, “Defining the Turing Jump”, *Mathematical Research Letters*, 6(6): 711–722. doi:10.4310/MRL.1999.v6.n6.a10
* Sieg, Wilfried, 1994, “Mechanical Procedures and Mathematical Experiences”, in *Mathematics and Mind*, Alexander George (ed.), Oxford: Oxford University Press, pp. 71–117.
* –––, 1997, “Step by Recursive Step: Church’s Analysis of Effective Calculability”, *Bulletin of Symbolic Logic*, 3(2): 154–180. doi:10.2307/421012
* –––, 2005, “Only two letters: The correspondence between Herbrand and Gödel”, *Bulletin of Symbolic Logic*, 11(2): 172–184. doi:10.2178/bsl/1120231628
* –––, 2009, “On Computability”, in *Philosophy of Mathematics*, Andrew D. Irvine (ed.), (Handbook of the Philosophy of Science), Amsterdam: Elsevier, 535–630. doi:10.1016/B978-0-444-51555-1.50017-1
* Simpson, Stephen G., 1977, “First-Order Theory of the Degrees of Recursive Unsolvability”, *The Annals of Mathematics*, 105(1): 121–139. doi:10.2307/1971028
* –––, 2009, *Subsystems of Second Order Arithmetic*, second edition, (Perspectives in Logic), Cambridge: Cambridge University Press. doi:10.1017/CBO9780511581007
* Singh, Parmanand, 1985, “The So-Called Fibonacci Numbers in Ancient and Medieval India”, *Historia Mathematica*, 12(3): 229–244. doi:10.1016/0315-0860(85)90021-7
* Skolem, Thoralf, 1923 [1967], “Begründung Der Elementaren Arithmetik Durch Die Rekurrierende Denkweise Ohne Anwendung Scheinbarer Veranderlichen Mit Unendlichem Ausdehnungsbereich”, *Videnskapsselskapets Skrifter, I. Matematisk-Naturvidenskabelig Klasse*, 6: 1–38. Reprinted as “The foundations of elementary arithmetic established by means o f the recursive mode of thought, without the use of apparent variables ranging over infinite domainin” in van Heijenoort 1967: 302–333.
* –––, 1946, “The development of recursive arithmetic” In *Dixíeme Congrés des Mathimaticiens Scandinaves*, Copenhagen, 1–16. Reprinted in Skolem 1970: 499–415.
* –––, 1970, *Selected Works in Logic* Olso: Universitetsforlaget. Edited by J.E. Fenstad.
* Slaman, Theodore A., 2008, “Global Properties of the Turing Degrees and the Turing Jump”, in *Computational Prospects of Infinity*, by Chitat Chong, Qi Feng, Theodore A. Slaman, W. Hugh Woodin, and Yue Yang, (Lecture Notes Series, Institute for Mathematical Sciences, National University of Singapore 14), Singapore: World Scientific, 83–101. doi:10.1142/9789812794055_0002
* Soare, Robert I., 1987, *Recursively Enumerable Sets and Degrees: A Study of Computable Functions and Computably Generated Sets*, Berlin: Springer.
* –––, 1996, “Computability and Recursion”, *Bulletin of Symbolic Logic*, 2(3): 284–321. doi:10.2307/420992
* –––, 2016, *Turing Computability: Theory and Applications*, Berlin: Springer. doi:10.1007/978-3-642-31933-4
* Spector, Clifford, 1955, “Recursive Well-Orderings”, *Journal of Symbolic Logic*, 20(2): 151–163. doi:10.2307/2266902
* Sudan, Gabriel, 1927, “Sur le Nombre Transfinite ”, *Bulletin Mathématique de la Société Roumaine des Sciences*, 30(1): 11–30.
* Suslin, Michel, 1917, “Sur Une Définition Des Ensembles Mesurables sans Nombres Transfinis”, *Comptes Rendus de l’Académie Des Sciences*, 164(2): 88–91.
* Tait, William W., 1961, “Nested Recursion”, *Mathematische Annalen*, 143(3): 236–250. doi:10.1007/BF01342980
* –––, 1968, “Constructive Reasoning”, in *Logic, Methodology and Philosophy of Science III*, B. Van Rootselaar and J. F. Staal (eds.), (Studies in Logic and the Foundations of Mathematics 52), Amsterdam: North-Holland, 185–199. doi:10.1016/S0049-237X(08)71195-9
* –––, 1981, “Finitism”, *The Journal of Philosophy*, 78(9): 524–546. doi:10.2307/2026089
* –––, 2005, *The Provenance of Pure Reason: Essays in the Philosophy of Mathematics and Its History*, (Logic and Computation in Philosophy), New York: Oxford University Press.
* Tarski, Alfred, 1935, “Der Wahrheitsbegriff in den formalisierten Sprachen”, *Studia Philosophica*, 1: 261–405.
* Tarski, Alfred, Andrzej Mostowski, and Raphael M. Robinson, 1953, *Undecidable Theories*, (Studies in Logic and the Foundations of Mathematics), Amsterdam: North-Holland.
* Thomason, S. K., 1971, “Sublattices of the Recursively Enumerable Degrees”, *Zeitschrift für Mathematische Logik und Grundlagen der Mathematik/Mathematical Logic Quarterly*, 17(1): 273–280. doi:10.1002/malq.19710170131
* Turing, Alan M., 1937, “On Computable Numbers, with an Application to the Entscheidungsproblem”, *Proceedings of the London Mathematical Society*, s2-42(1): 230–265. doi:10.1112/plms/s2-42.1.230
* –––, 1939, “Systems of Logic Based on Ordinals”, *Proceedings of the London Mathematical Society*, s2-45(1): 161–228. doi:10.1112/plms/s2-45.1.161
* van Heijenoort, Jean (ed.), 1967, *From Frege to Gödel: A Source Book in Mathematical Logic, 1879–1931*, Cambridge, MA: Harvard University Press.
* von Plato, Jan, 2016 “In search of the roots of formal computation”, In Gadducci, F. and Tavosanis, M., editors, *History and Philosophy of Computing: Third International Conference, HaPoC 2015*, 300–320, Berlin: Springer doi:10.1007/978-3-319-47286-7_21
* Wang, Hao, 1957, “The Axiomatization of Arithmetic”, *Journal of Symbolic Logic*, 22(2): 145–158. doi:10.2307/2964176
* –––, 1974, *From Mathematics to Philosophy*, New York: Humanities Press.
* Whitehead, Alfred North and Bertrand Russell, 1910–1913, *Principia Mathematica*, first edition, Cambridge: Cambridge University Press.

## Academic Tools

> | ![sep man icon](https://plato.stanford.edu/symbols/sepman-icon.jpg) | [How to cite this entry](https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=recursive-functions). |
> | --- | --- |
> | ![sep man icon](https://plato.stanford.edu/symbols/sepman-icon.jpg) | [Preview the PDF version of this entry](https://leibniz.stanford.edu/friends/preview/recursive-functions/) at the [Friends of the SEP Society](https://leibniz.stanford.edu/friends/). |
> | ![inpho icon](https://plato.stanford.edu/symbols/inpho.png) | [Look up topics and thinkers related to this entry](https://www.inphoproject.org/entity?sep=recursive-functions&redirect=True) at the Internet Philosophy Ontology Project (InPhO). |
> | ![phil papers icon](https://plato.stanford.edu/symbols/pp.gif) | [Enhanced bibliography for this entry](https://philpapers.org/sep/recursive-functions/) at [PhilPapers](https://philpapers.org/), with links to its database. |

## Other Internet Resources

* Odifreddi, Piergiorgio and S. Barry Cooper, 2012 [2020], “Recursive Functions”, *Stanford Encyclopedia of Philosophy* (Spring 2020 Edition), Edward N. Zalta (ed.), URL = <https://plato.stanford.edu/archives/spr2020/entries/recursive-functions/>. [This was the previous entry on recursive functions in the *Stanford Encyclopedia of Philosophy*—see the [version history](https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=recursive-functions).]

## Related Entries

[chance: versus randomness](https://plato.stanford.edu/entries/chance-randomness/) | [Church, Alonzo](https://plato.stanford.edu/entries/church/) | [Church-Turing Thesis](https://plato.stanford.edu/entries/church-turing/) | [computability and complexity](https://plato.stanford.edu/entries/computability/) | [computational complexity theory](https://plato.stanford.edu/entries/computational-complexity/) | [computer science, philosophy of](https://plato.stanford.edu/entries/computer-science/) | [Gödel, Kurt](https://plato.stanford.edu/entries/goedel/) | [Gödel, Kurt: incompleteness theorems](https://plato.stanford.edu/entries/goedel-incompleteness/) | [Hilbert, David: program in the foundations of mathematics](https://plato.stanford.edu/entries/hilbert-program/) | [lambda calculus, the](https://plato.stanford.edu/entries/lambda-calculus/) | [learning theory, formal](https://plato.stanford.edu/entries/learning-formal/) | [logic: combinatory](https://plato.stanford.edu/entries/logic-combinatory/) | [paradoxes: and contemporary logic](https://plato.stanford.edu/entries/paradoxes-contemporary-logic/) | [proof theory](https://plato.stanford.edu/entries/proof-theory/) | [reverse mathematics](https://plato.stanford.edu/entries/reverse-mathematics/) | [self-reference](https://plato.stanford.edu/entries/self-reference/) | [Turing, Alan](https://plato.stanford.edu/entries/turing/) | [Turing machines](https://plato.stanford.edu/entries/turing-machine/)

### Acknowledgments

This work has been partially supported by the ANR project *The Geometry of Algorithms – GoA* (ANR-20-CE27-0004). The authors would like to thank Mark van Atten, Benedict Eastaugh, Marianna Antonutti Marfori, Christopher Porter, and Máté Szabó for comments on an earlier draft of this entry. Thanks are also owed to Piergiorgio Odifreddi and S. Barry Cooper for their work on the prior versions (2005, 2012).

[Copyright © 2024](https://plato.stanford.edu/info.html#c) by  
[Walter Dean](http://go.warwick.ac.uk/whdean) <[*W.H.Dean@warwick.ac.uk*](mailto:W%2eH%2eDean%40warwick%2eac%2euk)>  
[Alberto Naibo](https://www.pantheonsorbonne.fr/page-perso/anaibo) <[*alberto.naibo@univ-paris1.fr*](mailto:alberto%2enaibo%40univ-paris1%2efr)>
<!--md-padding-ignore-end-->
