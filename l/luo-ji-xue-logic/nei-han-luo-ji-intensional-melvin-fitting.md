# 内涵逻辑 intensional (Melvin Fitting)

*首次发表于2006年7月6日；实质性修订于2015年4月2日。*

一个术语所指和它的意义之间存在明显的区别。至少可以明显地看出存在区别。在某种程度上，意义决定了指称，但并不等同于指称。毕竟，“晨星”和“夜星”都指的是金星，但意义不同。内涵逻辑试图研究指称和意义，并探究它们之间的关系。

---

## 1. 这是关于什么的？

如果你对口语天文学不熟悉，而我告诉你晨星是夜星，我给了你信息-你的知识发生了变化。如果我告诉你晨星是晨星，你可能觉得我在浪费你的时间。然而，在这两种情况下，我告诉你的是金星是自我同一的。肯定还有更多的东西。天真地说，我们可能会说晨星和夜星在某种程度上是相同的，但在另一种程度上又不相同。"晨星"和"夜星"这两个短语可能指代同一个物体，但它们的意义并不相同。在这个意义上，意义通常被称为内涵，而被指定的事物则被称为外延。自然情况下，只有外延才是重要的情境被称为外延的，而不足够的情境被称为内涵的。数学通常在整个过程中是外延的-即使所涉及的两个术语在意义上可能有所不同（稍后详细介绍），我们也可以愉快地写下"1+4=2+3"。"已知..."是一个典型的内涵情境-"已知1+4=2+3"在涉及小孩子的知识时可能是不正确的。因此，数学教育与数学本身不同。其他内涵情境的例子包括"人们相信..."、"必须..."、"有信息表明..."、"据说..."、"令人惊讶的是..."等等。通常，当天真地应用等式的可替代性失败时，可以识别出一个内涵情境。因此，晨星等于夜星；你知道晨星等于晨星；然后在替换等于的情况下，你知道晨星等于夜星。请注意，这种知识是纯粹的逻辑推理产生的，不涉及对天空的任何调查，这应该引起一些怀疑。在知识情境中替换共指术语是有问题的举动-毕竟，这样的情境是内涵的。 诚然，这有点循环。在一个内涵的语境中，我们不应该使用扩展的相等性，而内涵的语境是指这种替代性不起作用的语境。

上面使用的例子涉及复杂术语，伪装的明确描述。但是，同样的问题也会在其他地方出现，通常以更难以形式化处理的方式。专有名词构成了一个众所周知的困难领域。名称“Cicero”和名称“Tully”表示同一个人，因此“Cicero is Tully”是真的。专有名词通常被认为是刚性的，一旦指定了一个指称，它就不会改变。这实际上使得“Cicero is Tully”成为一个必然的真理。那么，有人怎么可能不知道呢？“Superman is Clark Kent”更难处理，因为这些名称没有实际的人物指称。因此，虽然这个句子是真的，但不仅可能有人不知道，而且可能完全相信 Clark Kent 存在，也就是说，“Clark Kent”指称了某个东西，但不相信 Superman 存在。存在问题与内涵问题以复杂的方式交织在一起。此外，刚才概述的问题在类型层次结构上继续存在。具有等边的三角形的属性与具有等角的三角形的属性是一致的，尽管意义显然不同。然后有人可能会说，“一个等边三角形是一个等边三角形是微不足道的”，但有人可能否认“一个等边三角形是一个等角三角形是微不足道的”。

在古典一阶逻辑中，内涵并不起作用。它是通过设计来实现外延性的，因为它主要是为了模拟数学推理而发展起来的。形式化自然语言或日常推理的方面需要更丰富的东西。可以表示内涵特征的形式系统通常被称为内涵逻辑。本文讨论了内涵逻辑的历史和演变的一些内容。目标是找到能够形式化表示上述问题的逻辑。这并不简单，可能没有提出的逻辑完全成功。将详细讨论一个相对简单的内涵逻辑，以说明几个重要观点，指出困难，并提供其他更复杂方法的指引。

## 2. 简要历史

认识到指定术语具有双重性质远非最近的事情。Port-Royal 逻辑使用了翻译为“内涵”和“外延”的术语。约翰·斯图尔特·密尔使用了“内涵”和“外延”。弗雷格著名地使用了“Sinn”和“Bedeutung”，通常不翻译，但翻译时通常变成“意义”和“指称”。卡尔纳普则采用了“内涵”和“外延”。无论如何表达，从作者到作者的变化，本质上的二分法是一个术语的意义和它所指的东西之间的区别。“行星的数量”指的是数字 9（忽略了关于太阳系外边缘物体状态的最近争议），但它并不以数字 9 作为其意义，否则在早期科学家可能通过语言分析过程确定行星的数量是 9，而不是通过天文观测。在分析内涵问题方面做出了许多贡献的人中，有几个人脱颖而出。在名单的首位是戈特洛布·弗雷格。

### 2.1 弗雷格

关于内涵问题和问题的现代理解始于戈特洛布·弗雷格的一篇基础论文（弗雷格 1892）。这篇论文以对等概念所带来的困难的陈述开篇。在他早期的工作中，弗雷格指出，他曾将等式视为关联对象的名称或符号，而不是对象本身。否则，如果 a 和 b 指代同一对象，那么 a=a 和 a=b 之间就没有认知上的区别，然而前者是分析的，而后者通常不是。因此，他曾经认为，等式是关联指代相同事物的符号。但是，他现在意识到，这也不完全正确。符号的使用是完全任意的，任何东西都可以成为任何东西的符号，因此在考虑 a=b 时，我们还需要考虑两个符号的表达方式——将它们与所指代的事物联系起来的方式。在这种思路下，等式成为了一种相对于它们的表达方式的符号之间的关系。当然，表达方式的概念有些模糊，弗雷格很快将注意力转移到其他地方。

一个符号既有一个指称，又有弗雷格所称的一个内涵——我们可以将内涵视为某种表达方式的具体体现。从这里开始，他的论文中讨论的是内涵，而表达方式则渐渐淡出了背景。一个名称表达了它的内涵，并指定了它的指称。因此，“晨星”和“夜星”具有相同的指称，但表达了不同的内涵，代表了不同的表达方式——一个是在太阳遮挡之前的早晨最后一次看到的天体，另一个是在太阳不再遮挡之后的晚上首次看到的天体。弗雷格通过引入与符号相关的观念进一步复杂了问题，这个观念与内涵和指称是不同的。但是这个观念是主观的，因人而异，而内涵和指称则被弗雷格说成不以这种方式依赖于观念。因此，观念也渐渐淡出了背景，而内涵和指称仍然是核心。

通常情况下，当一个符号出现在陈述句中时，符号的指称是重要的。"金星"和"晨星"都指代同一个对象。句子"晨星在日出附近的天空中可见"是真的，当"晨星"被替换为"金星"时仍然是真的。等指称符号的替换保持真实性。但并非总是如此；在某些情境下，间接指称的情况下就不会发生。典型的例子是，"乔治知道晨星在日出附近的天空中可见"可能是真的，而"乔治知道金星在日出附近的天空中可见"可能是假的。除了知识的情境，间接指称还出现在涉及"我相信..."、"我认为..."、"我觉得..."、"令人惊讶的是..."、"平凡的是..."等句子中。在这种情境下，弗雷格得出结论，重要的不是指称，而是意义。因此，由于"乔治知道..."是一个间接指称的情境，意义是重要的。符号"晨星"和"金星"具有不同的意义，我们不是用一个等于它的意义来替换一个意义，因此不应该期望真实性得到保持。

弗雷格指出，一个表达式可能有意义，但没有指称。他给出的一个例子是"收敛最慢的级数"。当然，一个对象可能有几个指代它的符号，但具有不同的意义。弗雷格将意义/指称二分法扩展得相当广泛。特别是，陈述句被认为既有意义又有指称。意义是它所表达的命题，而指称是它的真值。因此，在逻辑上等价的句子具有相同的指称，但可能具有不同的意义。在间接情境中，意义而不是指称是重要的，因此我们可能知道自然数的良序原理，但不知道数学归纳原理，因为虽然它们在真值上是等价的，但它们具有不同的意义。

弗雷格（Frege）在 1892 年没有提出处理意义（sense）与指称（reference）之间关系的正式机制。但是，弗雷格定义了进一步讨论所依据的术语。有两个不同但相关的概念，即意义和指称。相等性起着基本作用，而一个核心问题是相等物的可互换性。名称、符号、表达式在指称上可以相等，但在意义上却不相等。存在直接或外延的语境和间接或内涵的语境，指称对于前者很重要，而意义对于后者至关重要。

### 2.2 教堂（Church）

弗雷格提出了一种内涵性理论的概要，但没有以任何形式的内涵逻辑。有人试图填补他的概要。阿隆佐·教堂（Alonzo Church）（1951 年）直接着手解决这个问题。在这篇论文中，有一个形式逻辑，其中术语既有意义又有指称。它们被简单地视为不同的类型，并对它们提出了最低要求。尽管如此，这个逻辑相当复杂。弗雷格为他在数学基础研究中创造的形式逻辑是无类型的。罗素展示了他著名的悖论适用于弗雷格的系统，因此它是不一致的。为了解决这个问题，罗素发展了在《数学原理》中体现的类型理论。教堂对简单类型理论（Church 1940）给出了一个优雅而精确的表述，这也是它形式复杂的原因之一，而这个理论也被纳入了他关于内涵性的工作中。

教堂使用了他所称之为概念的概念，其中任何作为某物名称的意义可以作为该某物的概念。没有试图使这更加精确 - 实际上，如何做到这一点并不清楚。明确指出概念是语言无关的，甚至可能是不可数的。有两个真值的类型 ο0。然后，有一个概念的类型 ο1，它是 ο0 成员的概念，被称为命题概念。有一个概念的类型 ο2，它是 ο1 成员的概念，依此类推。有一个个体的类型 ι0，一个 ι0 成员的概念的类型 ι1，一个 ι1 成员的概念的类型 ι2，依此类推。最后，对于任意两个类型 α 和 β，存在一个类型 (αβ)，它是从类型 β 的项目到类型 α 的项目的函数的类型。教堂对功能类型做出了简化假设。为了方便陈述，他引入了一些特殊的符号：如果 α 是一个类型符号，例如 ((ι3ο2)(ο5ι4))，那么 α1 是通过将每个下标增加 1 而得到的结果，在我们的例子中我们得到 ((ι4ο3)(ο6ι5))。（对于每个正整数 n，αn 都有类似的定义，但我们在这里不需要它。）教堂的假设是功能类型 (αβ) 的成员是类型 (α1β1) 的成员。根据这个假设，任何类型 α 的成员的概念都是类型 α1 的成员。

引入了量化和蕴涵，或者更准确地说，引入了适用于各种类型的版本。λ 抽象符号表示法存在。最后，对于每个类型 α，假设存在一个关系，它在一个类型 α 的某物的概念和该某物本身之间成立；这是类型 α1 的成员和类型 α 的成员之间的关系。这用 Δ 表示，并带有适当的类型标识下标。

教堂的一个基本问题是当两个名称、λ项具有相同的意义时。考虑了三种选择。这三种选择都有一个共同点，即在绑定变量的重命名下（在通常的自由条件下）和β规约下，意义不变。除此之外，选择 0 有些技术性，只是简单提及一下，选择 1 是细粒度的，尽可能使意义不同，而选择 2 是指两个术语具有相同的意义，只要它们之间的等式是逻辑有效的。这些选择的适当定义是公理的，并且引入了一些 53 个公理方案的各种组合，但没有详细研究其中的任何一个。显然，教堂只是提出了一个调查，而不是提出了完整的结果。

如前所述，这项工作的主要参考文献是 Church 1951，但还有其他几篇重要的论文，包括 Church 1973，Church 1974 和 Church 1944 的引言，其中包含了对一些思想的非正式讨论。此外，Anderson 的阐述性论文也很有启发性（Anderson 1984，1998）。值得注意的是，教堂的工作与 Carnap 的工作之间存在关系，下面将进行讨论。教堂的思想首先出现在一个摘要中（Church 1946），然后 Carnap 的书出版了（Carnap 1947）。几年后，教堂的论文扩展了他的摘要（Church 1951）。Carnap 的书的第二版于 1956 年出版。两位作者互相影响，两者之间的引用完全交织在一起。

### 2.3 Carnap

教会只是简单地规范了内涵的行为方式，而没有说明它们是什么。鲁道夫·卡尔纳普通过他的内涵和外延方法进一步发展了这些观点，并提供了一种语义学，其中将相当具体的模型论实体与内涵相对应（卡尔纳普，1947 年）。事实上，目标是为每个有意义的表达式提供内涵和外延，并以一种在很大程度上影响了后续工作的方式完成了这一目标。

尽管卡尔纳普参加了弗雷格的课程，但他的主要思想是基于维特根斯坦 1921 年的观点。在《论逻辑哲学》中，维特根斯坦引入了可能世界语义学的前身。存在着可以与其所有真理集合等同的事实，“（1.13）逻辑空间中的事实就是世界。”这些事实可能是原子的，并且可以独立变化，“（1.21）每个项目在其他一切保持不变的情况下可以成为情况或不成为情况。”因此，存在许多可能的事实，其中包括实际事实，即真实世界。对象在某种程度上不仅涉及实际事实，还涉及所有可能的事实，“（2.0123）如果我了解一个对象，我也了解它在各种事实中的所有可能发生。（这些可能性中的每一个都必须是对象本质的一部分。）新的可能性不能以后才被发现。”卡尔纳普正是从这些思想中发展出了他的理论。

Carnap从一个固定的形式语言开始，其细节现在不需要我们关心。在这种语言中，包含每个原子句中的A或¬A中的一个的原子句的类别被称为状态描述。在每个状态描述中，根据通常的真值功能规则确定语言中每个句子的真实性或虚假性-量词被替代处理，并且假定语言具有足够的常量。因此，真实性是相对于状态描述的。现在，Carnap引入了一个比真实性更强的概念，即L-真实性，旨在成为“哲学家所称之为逻辑真理、必然真理或分析真理的解释”。最初，他以相对非正式的方式提出了这个概念，“如果一个句子在状态描述S中是真实的，并且其真实性可以仅仅基于系统S的语义规则，在没有任何（超语言的）事实参考的情况下得到证实，那么它在状态描述S中是L-真实的。”但是，这很快被一个更精确的语义版本所取代，“如果一个句子在每个状态描述中都成立，那么它是L-真实的”。

在L-真理中，可以认出一种使用可能世界语义的必然真理版本。没有可及性关系，因此被捕捉到的更像是S5而不是其他模态逻辑。但它也不是S5语义，因为有一组由语言本身确定的状态描述。 （如果P是任何命题原子，某个状态描述将包含P，因此将验证◊P。）尽管如此，这是对可能世界语义的明确预期。但我们在这里关心的是Carnap在这种情况下如何处理指定术语。考虑谓词P和Q。对于Carnap来说，如果∀x（Px≡Qx）是一个L-真理，那么它们在每个状态描述中具有相同的外延，它们在内涵上是等价的。没有明确说明，Carnap提出谓词的内涵是将其分配给每个状态描述的外延的一种方式-内涵上的一致性意味着在所有状态描述中的外延上的一致性，而不仅仅是在实际状态描述中。因此，谓词“H”，即人类，和谓词“FB”，即无羽双足动物，具有相同的外延-在实际状态描述中，它们适用于相同的存在物-但它们的内涵不同，因为在其他状态描述中它们的外延可能不同。以类似的方式，可以对个体表达进行建模，“个体表达的外延是它所指的个体。”因此，“Scott”和“Waverly的作者”具有相同的外延（在实际状态描述中）。Carnap提出将个体表达的内涵称为个体概念，并且在每个状态描述中，这种概念指代该状态描述中的个体。然后，“Scott”和“Waverly的作者”具有不同的内涵，因为正如我们大多数人愿意说的那样，它们本可以不同，也就是说，在它们不同的状态描述中存在。 （在这个例子中，我忽略了非指定问题。）)

卡尔纳普的基本思想是，无论考虑的实体是什么，内涵都可以被给予一个精确的数学体现，作为对状态的函数，而外延是相对于单个状态的。当然，这一思想已经被后续的研究者进一步发展，当然还加入了现代可能世界语义。卡尔纳普的方法并不是唯一的方法，但它确实带领我们走进了内涵的森林。尽管它并不能完全带领我们穿越，但在它起作用时，它是具体、直观和自然的。因此，在这里，我们将主要考虑这个版本。

### 2.4 马库斯

卡纳普的工作主要是语义学的，结果产生了一种与此前研究的任何形式系统都不相符的逻辑学。公理化呈现的命题模态逻辑已经得到了很好的建立，因此重要的是要看看（或者是否）可以扩展以包括量词和相等性。问题在于量词的范围是什么样的事物，并且等同物的可替代性。需要解决奎因的模态异议。鲁思·巴肯·马库斯在（马库斯 1946 年）中开始了一条发展线，通过正式扩展 C.I.刘易斯的命题系统 S2 以包括量化，并以《数学原理》的风格公理化发展。显然，除了 S2 之外，还可以使用其他标准的模态逻辑，而 S4 则明确讨论了这一点。巴肯公式以◊(∃α)A ⊃(∃α)◊A 的形式首次出现在（马库斯 1946 年）[1]，尽管对其意义的充分理解还需要等待可能世界语义的发展。对于本文来说，特别重要的是，她的系统在（马库斯 1947 年）中进一步扩展以允许抽象和恒等性。考虑了两个版本的恒等性，取决于事物是否具有相同的属性（抽象）或必然具有它们。在 S2 系统中，这两个版本被证明是等价的，在 S4 系统中，必然等价。在后来的一篇论文中（马库斯 1953 年），演绎定理的基本作用也得到了充分的探讨。

马库斯证明了在她的系统中，如果是真的，那么身份是必要的，对于不同性质也是如此。她在随后的作品中有力地主张（主要是马库斯 1961 年），既避免了晨星/夜星问题。名字被理解为标签。它们可以通过对一个确定描述的初始使用或其他方式来指定其指定，但除此之外，名字没有意义，只有一个指定。因此，它们不像确定描述那样行为，确定描述不仅仅是标签。嗯，“晨星”标记的对象和“夜星”标记的对象是相同的，对象之间的身份永远不是偶然的。

关键点已经被提出。人们可以开发带有量词和相等性的形式模态系统。这些想法具有一致性。仍然缺少的是一种语义学，可以帮助理解形式主义，但这已经在拐角处。

### 2.5 蒙塔古、蒂奇、布雷桑和加林

卡尔纳普的思想被理查德·蒙塔古、帕维尔·蒂奇和阿尔多·布雷桑独立地扩展和形式化。他们都使用了某种版本的克里普克/欣蒂卡可能世界语义，而不是卡尔纳普更专门的结构。他们都以功能方式处理内涵。

在某种程度上，布雷桑希望为物理学提供一个逻辑基础。与物理学的联系在于，当我们说某物具有某种质量时，我们的意思是，如果我们进行了某些实验，我们将得到某些结果。这并不意味着我们确实进行了那些实验，因此会出现替代状态（或者布雷桑称之为案例）。因此，需要一个包括数字和物理对象在内的丰富的模态语言。在布雷桑 1972 年的著作中，开发了一个复杂的模态系统，其中包括像《数学原理》中的数字一样的完整类型层次结构。

蒙塔古的工作主要在蒙塔古 1960 年和 1970 年的著作中，其主要动机是自然语言。这种处理是语义的，但在加林 1975 年的著作中，提出了一个公理系统。加林公理化的逻辑是一个完整的类型理论系统，每种类型都有内涵对象。相对于亨金模型的类高阶经典逻辑，证明了完备性。

Tichý创立了一种非常类似于 Montague 的内涵逻辑系统，从 Tichý 1971 开始，以英语为基础，在 Tichý 1988 中进行了详细的介绍。不幸的是，他的工作并没有广为人知。像 Montague 的语义学一样，Tichý的形式工作是基于一种类型层次结构，其中内涵在每个类型层次上将世界映射到外延，但在某些方面超越了 Montague。首先，内涵不仅依赖于世界，还依赖于时间。其次，除了内涵和外延，Tichý还考虑了构造。其思想是表达式确定内涵和外延，而这本身是一个形式过程，在这个过程中，复合表达式使用构成它们的更简单的表达式；换句话说，构造层面上的组合性。使用这个形式机制，“1+4”和“2+3”规定了不同的构造；它们的意义不仅仅是通过它们的内涵表示来捕捉，正如本文所讨论的那样。

## 3. 一个特定的内涵逻辑

正如之前多次指出的那样，形式内涵逻辑已经发展出了一个完整的更高类型的层次结构，例如Church、Montague、Bressan、Tichý等。这样的逻辑可能相当可怕，但是Carnap的思想往往（当然并不总是）是这些逻辑的核心，这些思想很简单，足以让我们讨论几个常见的内涵问题。根据其意义（内涵、含义），一个指定短语可能在不同的条件下指定不同的事物——在不同的状态下。例如，“行星的数量”在古代被认为指定为6（包括地球）。在1781年发现天王星后，“行星的数量”被认为指定为7。如果我们将古代人所构想的宇宙和1781年后所构想的宇宙视为认知事态，那么在一个状态下，“行星的数量”指定为6，在另一个状态下指定为7。在这两种状态下，人们对行星的概念并没有错误，而是对构成宇宙的事态错误。如果我们忽略了所有关于意义如何确定、意义如何选择参照物的问题，以及所有关于什么构成可能事态的问题，也就是说，如果我们将所有这些都抽象掉，每个指定术语的共同特征就是指定可能会从一个状态变化到另一个状态——因此它可以通过从状态到对象的函数来形式化。这种简化的方法足以处理许多原本棘手的问题。

为了简化问题，我们不考虑完整的类型层次结构——一阶逻辑足以传达基本概念。例如，Gallin 1975的逻辑的一阶片段就足够了。这里提出的具体表述来自于Fitting 2004，扩展了Fitting和Mendelsohn 1998的内容。谓词符号是内涵的，就像Kripke风格语义的每个版本一样，其解释取决于可能世界。这里考虑的唯一其他内涵项是个体概念，由在不同可能世界中可以指定不同对象的常量和变量形式表示。相同的思想可以扩展到更高的类型，但这些思想在这个相对简单的层次上已经可以看到了。内涵逻辑通常只有内涵，外延是被推断出来但并不明确的。然而，过于简化的方法可能会增加困难，因此在这里我们明确允许既有对象也有涵括对象的个体概念。有两种类型的量化，分别适用于这两种排序。外延和内涵对象都是一等公民。

基本思想是以语义方式呈现，而不是以证明论方式呈现，尽管存在公理系统和表格系统。即便如此，技术细节可能变得复杂，因此我们将尽可能地将非正式呈现与其正式对应物分开，非正式呈现足以获得一般思想，而正式对应物则更具专业兴趣。假定对模态逻辑有一般了解（尽管有一个非常简短的讨论来建立符号，符号在不同作者之间可能有所不同）。值得注意的是，这里使用模态语义，在两种不同的方式上通常使用。通常，人们心中有一个特定的克里普克模型，尽管可以非正式地指定。例如，我们可以考虑一个克里普克模型，其中状态是当前时刻和所有过去时刻，后续状态可从先前状态访问。这样的模型在讨论“法国国王”时是启发性的，即使时刻的概念有些模糊。但除了这种非正式指定具体模型的用法外，还有形式化的克里普克语义，这是一个数学上精确的东西。如果在所有形式化的克里普克模型中都可以验证某个命题，比如□(X⊃Y)⊃(□X⊃□Y)，我们可以假设在我们模糊指定的直观模型中也是如此，无论我们如何尝试使它们更加精确。非正式模型贯穿我们的讨论，它们的基本属性来自形式语义。

### 3.1 命题模态逻辑

命题语言由命题符号 P、Q 等构建，使用∧、∨、⊃、¬等命题连接词，以及□（必然）和◊（可能）作为模态运算符。这些运算符可以被视为真理、道义、时间、认知等，最终会有所区别，但目前并不重要。同样，□可能有多个版本，比如具有多个知识者的知识逻辑，这也不会产生任何实质性的差异。

对于命题模态逻辑的 Kripke 语义学，现在已经是非常熟悉的事情了。这里是一个快速的介绍，用于建立符号表示，并指出 Frege 的一个提议如何适应其中。更详细的介绍可以在本百科全书中关于模态逻辑的文章中找到。

#### 3.1.1 非正式版本

一个模型由一组状态组成，确定哪些状态与哪些状态相关，并且还规定了哪些命题符号在这些状态中成立。状态可以是不同时间的现实世界的状态，或者是知识、信念的状态，或者是如果情况不同，可能是现实世界的状态。我们在这里进行了数学抽象。我们并不试图定义所有这些状态可能的“含义”，我们只是假设我们拥有它们。然后，更复杂的公式根据状态的真值进行评估。在每个状态下，命题联结词具有它们惯常的经典行为。对于模态运算符□X，即必然 X，在一个状态下，如果 X 在与该状态相关的每个状态（所有可达状态）中都为真，则□X 为真。同样，对于模态运算符◊X，即可能 X，在一个状态下，如果 X 在某个可达状态中为真，则◊X 为真。如果我们从认识论的角度来看待事物，可达性表示兼容性，因此如果 X 在与该状态兼容的所有状态中都为真，则 X 在该状态中是已知的。如果我们从真理论的角度来看待事物，可达状态可以被视为一个备选的现实，因此如果 X 在所有可能的备选状态中都为真，则 X 在该状态中是必然的。这些想法现在已经非常熟悉了。

#### 3.1.2 正式版本

一个框架是一个结构⟨G,R⟩，其中 G 是一个非空集合，R 是 G 上的二元关系。G 的成员是状态（或可能世界）。R 是一个可达关系。对于Γ,Δ∈G，ΓRΔ读作“Δ从Γ可达”。框架上的（命题）估值是一个映射 V，它将框架的状态映射到真值 true 或 false。为简单起见，我们将用 V(P)(Γ)来缩写 V(P,Γ)。命题模型是一个结构 M=⟨G,R,V⟩，其中⟨G,R⟩是一个框架，V 是该框架上的命题估值。

给定一个命题模型 M=⟨G,R,V⟩，记号 X 在状态Γ上为真将被表示为 M,Γ⊨X，并由以下标准规则所表征，其中 P 是原子命题。

M,Γ⊨PM,Γ⊨X∧Y…M,Γ⊨□XM,Γ⊨◊X⇔V(P,Γ)=true⇔M,Γ⊨X and M,Γ⊨Y⇔…⇔M,Δ⊨X 对于每个 Δ∈G 且 ΓRΔ⇔M,Δ⊨X 对于某个 Δ∈G 且 ΓRΔ

假设我们使用内涵/外延区分来思考公式。给定一个模型 M，对于每个公式 X，我们可以关联一个函数，称之为 fX，将状态映射到真值，其中我们设置 fX(Γ) = true 当且仅当 M,Γ⊨X。

将函数 fX 视为公式 X 的内涵意义——实际上，将其视为公式所表达的命题（相对于特定模型而言）。在状态 Γ，fX(Γ) 是一个真值——将其视为该状态下 X 的外延意义。这是一种回溯到 Frege 的思考方式，他得出结论，句子的指称应该是一个真值，但意义应该是一个命题。他对命题的构成有些模糊——刚刚提出的形式化方法提供了一个自然的数学实体来满足这一目的，并且被 Carnap 明确提出用于此目的。显然，这种数学结构在一般情况下捕捉到了 Frege 思想的一部分。顺便说一句，我们可以毫不损失地将函数 fX 在状态上替换为集合 {Γ∈G∣fX(Γ)=true}。函数 fX 简单地是该集合的特征函数。这类集合在模态逻辑界通常被称为命题。从技术上讲，Frege 在这个特定主题上的思想已经成为共同的观点。

### 3.2 第一阶段的转变

首先我们讨论一些背景直觉，然后引入一个形式语义学。内涵将在第 3.3 节中正式介绍。这里讨论的材料可以在（Fitting 和 Mendelsohn 1998，Hughes 和 Cresswell 1996）等其他地方找到更充分的发展。

#### 3.2.1 实在主义者和可能主义者

如果我们将内涵理解为在不同情况下指定不同事物，我们就需要事物。在命题层面上，真值扮演着事物的角色，但在一阶层面上，需要更多的东西。在经典逻辑中，每个模型都有一个域，即该模型的事物，并且量词被理解为范围在该域的成员上。当然，什么构成了事物是开放的——任何一种集合都可以作为一个域。这样，如果由于哲学或数学考虑而有特殊限制，可以进行适应。由此可见，经典逻辑的有效性是尽可能一般的——无论我们选择什么作为我们的域，无论我们的事物是什么，它们都是真实的。

类似的方法在 Kripke 1963 年的模态逻辑中被引入。域是存在的，但是它们可能由什么组成是开放的。但是有一个没有经典对应的复杂性：在 Kripke 模型中存在多个状态。整个模型是否应该有一个单一的域，还是每个状态都有单独的域？两者都有自然的直觉。

考虑一种Kripke模型的版本，其中每个模型的状态都与一个单独的域相关联。在每个状态下，量词被认为是范围限定在与该状态相关联的域上。这被称为实在主义语义。将与状态相关联的域视为实际存在于该状态的事物。因此，例如，在所谓的真实世界中，胡夫大金字塔在域中，但亚历山大灯塔不在其中。如果我们考虑的是1300年的世界，两者都在域中。在实在主义方法中，我们需要对包含对其他状态存在但不在我们考虑的状态中的事物的引用的公式做出一些决定。有几种方法是合理的；我们可以认为这样的公式是假的，或者我们可以认为它们是无意义的，但这似乎是不必要的限制。毕竟，我们确实会说“亚历山大灯塔已经不存在了”，并且我们认为这是真实的。因此，最有用的形式版本是将量词视为逐个状态范围的域，但允许术语引用任何域的成员。由此产生的语义学通常被称为变动域和实在主义。

假设我们使用实在主义语义，因此每个状态都有一个相关的实际存在事物的领域，但假设我们允许量词在任何领域的成员范围内，没有区别，这意味着量词在每个状态都在同一集合上变动。那个集合的成员是什么？它们是在某个状态存在的事物，因此在每个状态它们都是可能存在的事物-可能存在的事物。将这些单独的领域合并为一个量化的单一领域，实际上意味着我们在量化可能性。因此，一种语义学中存在一个单一领域，量词在每个状态上变动，通常被称为可能性语义学或者当然的，恒定领域语义学。

可能性语义学比实在主义版本更容易处理-我们只有一个领域，而不是许多量词可以变动。而且事实证明，如果我们采用可能性方法，实在主义语义可以被模拟。假设我们有一个量化的单一领域，可能性，和一个特殊的谓词 E，我们认为在每个状态下，它是真实的，对于那个状态下实际存在的事物。如果∀是对可能性领域的量词，我们可以认为相对化的量词∀x(E(x)⊃…)对应于实在主义量化。（我们需要假设，在每个状态下，E 对某些事物是真实的-这对应于假设领域是非空的。）这将实在主义语义嵌入到可能性语义中，这是一个可以正式陈述和证明的结果。在这里，将使用可能性语义学，并假设我们有一个存在谓词 E 可用。

#### 3.2.2 可能性语义学，形式上

要使用的语言是命题模态语言的直接一阶扩展。有一个无限的对象变量列表，x，y，x1，x2，...，和一系列关系符号，R，P，P1，P2，...，具有所有的关系数。其中包括一元符号 E 和二元符号=。可以添加常量和函数符号，但让我们保持事物相对简单，同时也相对简单。如果 x1，...，xn 是对象变量，P 是一个 n 元关系符号，则 P(x1，...，xn)是一个原子公式。我们将在=（x，y）的位置写 x=y。更复杂的公式是使用命题连接词，模态运算符和量词∀和∃按照通常的方式构建的。变量的自由和约束出现具有标准的特征化。

一阶模型是一个结构⟨G，R，DO，I⟩，其中⟨G，R⟩是一个框架，如第 3.1 节所述，DO 是一个非空对象域，I 是一个解释，它将每个 n 元关系符号 P 映射到 G 到 DnO 的子集。我们将 I(P，Γ)写为 I(P)(Γ)的更易读版本。要求对于每个状态Γ，I(=，Γ)是 DO 上的等价关系，对于每个Γ，I(E，Γ)是非空的。模型中的一阶估值是将 DO 的成员分配给每个变量的映射。请注意，一阶估值不像解释那样依赖于状态。如果 v 和 w 除了 x 可能不同之外在所有变量上都一致，则一阶估值 w 是估值 v 的 x *-变体*。在模型 M=⟨G，R，DO，I⟩的状态Γ上，关于一阶估值 v 的真实性如下所示，其中 P(x1，...，xn)是一个原子公式：

M，Γ⊨vP(x1，...，xn)M，Γ⊨vX∧Y…M，Γ⊨v□XM，Γ⊨v◊XM，Γ⊨v∀xXM，Γ⊨v∃xX⇔⟨v(x1)，...，v(xn)⟩∈I(P，Γ)⇔M，Γ⊨vX 和 M，Γ⊨vY⇔…⇔M，Δ⊨vX 对于每个Δ∈G，其中ΓRΔ⇔M，Δ⊨vX 对于某个Δ∈G，其中ΓRΔ⇔M，Γ⊨wX 对于 v 的每个 x-变体 w⇔M，Γ⊨wX 对于 v 的某个 x-变体 w

在上述定义的每个一阶模型的每个状态下，如果一个公式在每个一阶估值下都为真，则称其为有效的。有效性包括通常的模态候选项，如□(X⊃Y)⊃(□X⊃□Y)，以及通常的量化候选项，如∀xX⊃∃xX。我们还有混合情况，如 Barcan 和 converse Barcan 公式：∀x□X≡□∀xX，这是常量域模型的特征，正如 Kripke 1963 中所示。由于等式的处理方式，我们有两个有效性：∀x∀y(x=y⊃□x=y)和∀x∀y(x≠y⊃□x≠y)。关于行星数量和 9 的身份（Quine 1963），或者关于晨星和夜星的身份（Frege 1892），以及这些身份在情态语境中的行为，已经引起了很多讨论。但这在这里并不是一个相关的问题。像“晨星”这样的短语具有内涵的方面，到目前为止所概述的语义并没有考虑内涵问题。事实上，晨星和夜星是同一个对象，正如 Gertrude Stein 可能会说的，“一个对象就是一个对象就是一个对象。”事物与自身的必要性身份不应该令人惊讶。内涵问题将很快得到解决。

量化是可能主义的——域是恒定的。但是，正如在 3.2.1 节中讨论的那样，可以通过使用存在谓词 E 间接引入变化的域，从而允许我们定义实在主义量化。让∀ExX 缩写为∀x(E(x)⊃X)，让∃ExX 缩写为∃x(E(x)∧X)。然后，虽然∀xϕ(x)⊃ϕ(y)是有效的，假设ϕ(x)中的 y 对于 x 是自由的，但我们没有∀Exϕ(x)⊃ϕ(y)的有效性。相反，我们有[∀Exϕ(x)∧E(y)]⊃ϕ(y)的有效性。

作为可能主义者/实在主义者差异的另一个例子，考虑∃x□P(x)⊃□∃xP(x)。使用可能主义量词，这是有效和合理的。它断言如果某些可能性在所有替代状态中具有属性 P，则在每个替代状态中都有某些可能性具有属性 P。但是当可能主义量化被实在主义量化所取代时，∃Ex□P(x)⊃□∃ExP(x)的结果不再有效。作为一个明显（但有些非正式）的例子，假设实际状态是Γ，P 是存在于状态Γ中的属性。那么，在Γ中，∃Ex□P(x)表示实际存在的某个东西在所有替代状态中都具有存在于状态Γ中的属性。这是真实的；事实上，这对于存在于状态Γ中的所有东西都是真实的。但是□∃ExP(x)表示在每个替代状态中都将有一个实际存在的对象，该对象也存在于状态Γ中，这未必是真实的。

### 3.3 添加内涵

在3.2节中，勾勒了一个一阶模态逻辑，其中量化是针对对象的。现在添加了第二种量化方式，即针对内涵的量化。正如已经多次指出的那样，内涵对象或个体概念将由从状态到对象的函数建模，但现在我们要讨论的是应该允许哪些函数。内涵应该与意义相关。如果我们认为意义是人类构建的，那么内涵的构成可能应该受到限制。例如，内涵对象的数量不应该超过能够指定意义的句子的数量，这将限制内涵为可数集。或者我们可以将内涵视为“存在”，并挑选出我们想要思考的内涵，这样基数考虑就不适用了。这可能是一个无法最终解决的问题。相反，即将介绍的语义允许在不同模型中进行不同选择，不要求所有从状态到对象的函数都存在。值得注意的是，尽管这种语义策略具有哲学上的合理性，但它也使得公理化成为可能。其根本观点与从一阶逻辑到二阶逻辑的转变相同。如果我们坚持认为二阶量词的范围涵盖所有集合和关系，那么公理化是不可能的。如果我们使用亨金模型，其中二阶量词的范围具有更大的自由度，那么公理化就变得可行。

公式的构建方式基本上是显而易见的，使用了两种量化变量而不是一种：外延和内涵。但是，语法机制中有一个非常重要的补充，需要进行一些讨论。假设我们有一个内涵f，在每个状态下都选择一个对象。例如，这些状态可能是宇宙可能构成的各种方式，而在每个状态下f选择的是行星的数量，当然可能是0。假设P是一个一元关系符号——P(f)应该意味着什么？一方面，它可以表示内涵f具有属性P，另一方面，它可以表示由内涵f指定的对象具有属性P。这两个版本都很有用，并且对应于我们每天说的事情。我们将允许两者，但是第二个版本需要进行一些整理。假设P(f)的意图是指由f（在某个状态下）指定的对象具有属性P。那么我们应该如何理解◊P(f)？在什么情况下我们应该认为它在状态Γ下为真？它可以被理解为在Γ状态下，f指定的事物（称之为fΓ）具有“可能-P”的属性，因此在某个替代状态Δ中，我们有fΓ具有属性P。这是de re解读，即将可能的属性归属于一个事物。另一种理解◊P(f)的方式是将可能性运算符作为主要内容：在Γ状态下，如果在某个替代状态Δ中我们有P(f)，那么这个公式为真，因此在Δ状态下由f指定的对象（称之为fΔ）具有属性P。这是de dicto解读，可能性适用于一个句子。当然，fΓ和fΔ没有特定的理由是相同的。de re解读和de dicto解读是不同的，两者都需要表示，而我们无法通过常规的语法来处理这个问题。

将使用抽象机制来消除我们的语法歧义。de re 阅读将被符号化为λx◊P(x)，而 de dicto 将被符号化为◊ λxP(x)。不完整的表达式[λxX]通常被称为谓词抽象；可以将其视为从公式 X 中抽象出的谓词。在λx◊P(x)中，我们断言 f 具有可能-P 属性，而在◊ λxP(x)中，我们断言 f 具有 P 属性的可能性。抽象消除了歧义。我们对◊所说的同样适用于□。值得注意的是，可以将抽象简单地看作是一种范围指定设备，这是一个可以追溯到罗素的传统，在他对确定描述的处理中使用了这样的机制。模态逻辑中的抽象可以追溯到 Carnap 1947，但以一种忽略上述讨论的方式。目前的用法来自 Stalnaker＆Thomason 1968 和 Thomason＆Stalnaker 1968。

### 3.4 语义学的形式化

现在开始更加技术性的部分。有两种类型的变量，一种是对象变量，如前所述，另一种是内涵变量或个体概念变量，f，g，g1，g2 等。有了两种类型的变量，原子公式的形成变得稍微复杂一些。从现在开始，一个关系符号不再只是 n 元的，而是与之相关联的类型，其中类型是一个 n 元组，其条目是{O，I}的成员。原子公式是形式为 P(α1，…，αn)的表达式，其中 P 是一个关系符号，其类型为⟨t1，…，tn⟩，对于每个 i，如果 ti=O，则αi 是一个对象变量，如果 ti=I，则αi 是一个内涵变量。在关系符号中，我们仍然有 E，它现在的类型是⟨O⟩，我们还有=，类型为⟨O，O⟩。

公式通常是通过使用命题连接词、模态运算符和两种类型的量词（对象变量和内涵变量）从原子公式构建起来的。除了常规的公式生成机制外，我们还有以下内容。如果 X 是一个公式，x 是一个对象变量，f 是一个内涵变量，那么λxX 是一个公式，其中自由变量的出现除了 x 之外都是 X 的出现，还有 f 的显示出现。

为了区分这里描述的模型与第 3.2.2 节中的模型，我们将其称为 FOIL 模型，代表一阶内涵逻辑。它们在（Fitting 2004）中有更详细的讨论。FOIL 模型是一个结构 M=⟨G,R,DO,Di,I⟩，其中⟨G,R,DO,I⟩满足第 3.2.2 节的条件，并且另外，Di 是一个从 G 到 DO 的非空函数集合；它是内涵域。

FOIL 模型 M 中的一阶估值是一种映射，它将每个对象变量分配给 DO 的成员，与之前一样，将每个内涵变量分配给 Di 的成员。如果 f 是一个内涵变量，我们将用 v(f,Γ)来表示 v(f)(Γ)。现在，在模型 M 的状态Γ下，关于估值 v 的真实性的定义满足第 3.2.2 节中提出的条件，并且还满足以下条件：

M,Γ⊨v∀fX⇔M,Γ⊨v∃fX⇔M,Γ⊨v λxX⇔M,Γ⊨wX，对于 v 的每个 f-变体 w，M,Γ⊨wX，对于 v 的某个 f-变体 w，M,Γ⊨wX，其中 w 与 v 相似，除了 w(x)=v(f,Γ)。(1)

让我们约定在方便的时候用[λx λyX](f)来缩写为λxyX。假设 f 是“晨星”的内涵，g 是“夜星”的内涵。很可能 f 和 g 是不同的内涵。即使如此，在现实世界中[λxyx=y](f,%20g)是正确的——f 和 g 确实指代同一个对象。

这里有另一个例子，可能有助于更清楚地区分 de re / de dicto。假设 f 是“最高的人”的内涵，g 是“最年长的人”的内涵，并且假设此刻这些人是同一个人。同时，让我们将□解释为认识论上的。我们不太可能说□[λxyx=y](f,%20g)成立。我们可以将□[λxyx=y](f,%20g)解读为我们知道 f 和 g 是相同的。它断言在所有认识论的替代状态中——即与我们所知相容的世界的各种可能方式中——f 和 g 指代同一个对象，而这显然不是事实。然而，我们有[λxy□(x=y)](f,%20g)，我们可以将其解读为我们知道 f 和 g，也就是它们的指称，是相同的，这是可能的。它断言在所有认识论的替代状态中，f 和 g 在这个状态中所指代的将是相同的。在所描述的情况下，f 和 g 确实指代同一个对象，并且对象的同一性在不同的状态中保持不变。

需要注意的是，刚才给出的指定术语的例子都是明确的描述。它们在不同的可能世界中自然地选择了不同的对象。而对于专有名词和数学来说，情况是不同的，将在第 3.6 节中讨论。

#### 3.4.1 一个形式的例子

这里有一个例子来展示语义学如何以技术方式工作。如果内涵是恒定的，即在每个状态下都相同，那么它就是刚性的。我们可以将刚性内涵看作是一个伪装的对象，将其与其恒定值进行等同。因此，对于刚性内涵来说，de re 和 de dicto 之间的区别消失并不令人意外。事实上，还可以证明更强的一点。不是刚性，而是考虑 Fitting 和 Mendelsohn 1998 年提出的较弱概念，即局部刚性：如果一个内涵在某个状态下具有与所有可访问状态相同的指定，则它在该状态下是局部刚性的。因此，说 f 在某个状态下是局部刚性的，等于在该状态下断言[λx□ λyx=y](f)的真实性。在某个状态下的局部刚性意味着 de re/de dicto 的区别在该状态下消失。为了展示形式语义学的工作原理，下面是一个验证的例子，证明了有效性。

[λx□λyx=y](f)⊃([λx◊X](f)⊃◊[λxX](f))(2)

以类似的方式，可以证明

[λx□λyx=y](f)⊃[◊](3)​[λxXλx◊X](f)

从这两者中可以得出的是

[λx□λyx=y](f)⊃([λx◊X](f)≡◊[λxX](f))(4)

这直接说明了局部刚性意味着 de re /de dicto 区别消失。

假设(2)无效。那么就会存在一个模型 M=⟨G,R,DO,Di,I⟩，它的一个状态Γ，以及其中的一个估值 v，使得

M,Γ⊨v[λx□λyx=y](f)(5)

M,Γ⊨v[λx◊X](f)(6)

 非 M,Γ⊨v◊ λxX(7)

从 (6) 我们得到以下结果，其中 w 是 v 的 x-变体，使得 w(x)=v(f,Γ)。

M,Γ⊨w◊X(8)

通过(8)，存在某个Δ∈G，使得ΓRΔ，我们有以下情况。

M,Δ⊨wX(9)

然后，根据(7)的结果，

 非 M, Δ ⊨v λxX(10)

因此我们有以下内容，其中 w' 是 v 的 x-变体，使得 w'(x) = v(f,Δ)。

 非 M, Δ ⊨w'X(11)

现在从(5)开始，由于 w(x)=v(f,Γ)，我们有

M,Γ⊨w□[λyx=y](f)(12)

 因此

M,Δ⊨w[λyx=y](f)(13)

 因此

M,Δ⊨w′′x=y(14)

其中 w′′是 w 的 y-变体，使得 w′′(y)=w(f,Δ)。

我们声称估值 w 和 w′是相同的，这意味着(9)和(11)是矛盾的。由于它们都是 v 的 x-变体，只需证明 w(x)=w′(x)，即 v(f,Γ)=v(f,Δ)，这直观上符合局部刚性的说法。正式推导，v(f,Γ)=w(x)=w′′(x)，因为 w′′是 w 的 y-变体，所以它们在 x 上是一致的。我们还有 v(f,Δ)=w′′(y)。最后，根据(14)，w′′(x)=w′′(y)。

达到矛盾后，我们得出结论(2)必须成立。

#### 3.4.2 可能的额外要求

在模型中，内涵的领域应该是一些从状态到对象的非空函数集合。我们故意模糊了我们必须拥有哪些函数的问题。有一些条件我们可能想要要求。以下是一些相关考虑，从一个方便的缩写开始。

D(f,x) 缩写为 λyy=x(15)

(其中 x 和 y 是不同的对象变量)。

通过 FOIL 语义进行工作，当且仅当 v(f,Γ)=v(x)时，M,Γ⊨vD(f,x)为真。因此，D(f,x)表示内涵 f 指定了对象 x。

在迄今为止描述的 FOIL 模型中，公式∀f∃xD(f,x)是有效的。它只是说内涵总是指定的。另一方面，没有先验的理由相信每个对象都被某个内涵指定，但在特殊情况下，我们可能希望要求这样做。我们可以通过限制自己在具有以下有效性的模型中来实现：

∀x∃fD(f,x)(16)

如果我们要求(16)，那么对于对象的量化可以归约为内涵量化：

∀xΦ≡∀f[λxΦ](f).(17)

更准确地说，蕴涵（16）⊃（17）在 FOIL 语义中是有效的。

我们可能还希望要求存在选择函数。假设我们以某种方式将对象 dΓ与模型的每个状态Γ相关联。如果我们选择 dΓ的方式可以由语言的一个公式来指定，我们可能想说我们已经指定了一个内涵。要求以下公式的有效性似乎是我们在 FOIL 模型上施加这种存在条件的最接近方式。对于每个公式Φ：

□∃xΦ⊃∃f□[λxΦ](f).

### 3.5 部分内涵对象

“法国国王路易十四”指代一个不存在但曾经存在的对象。而“现任法国国王”根本没有指代。为了处理这样的情况，内涵的表示可以从一个从状态到对象的全函数广义为一个部分函数。我们经常谈论不存在的对象——我们谈论法国国王路易十四没有问题。但是关于现任法国国王没有什么可说的——根本就没有这样的存在。这将成为我们语义学中真值条件的指导。

#### 3.5.1 修改语义学

语言保持不变，但内涵变量现在由状态集上的偏函数解释——其定义域可能是状态集的真子集。因此，如果 M=⟨G,R,DO,Di,I⟩是一个部分 FOIL 模型，那么它与第 3.4 节中的情况相同，只是 Di 的成员是从 G 到 DO 的偏函数。给定一个部分 FOIL 模型 M 和其中的一个估值 v，在这个模型中，如果Γ在 v(f)的定义域中，那么内涵变量 f 在状态Γ上相对于 v 指定。

遵循无法对法国现任国王说任何话的观点，我们将第 3.4 节中的条件（1）分为两部分。给定一个部分 FOIL 模型 M 和其中的一个估值 v：

1. 如果 f 在Γ相对于 v 不指定，
    不是这样的情况，即 M,Γ⊨v λxX
2. 如果 f 在Γ中相对于 v 指定，
    M,Γ⊨v[λxX](f)⇔M,Γ⊨wX
    其中 w 类似于 v，除了 w(x)=v(f,Γ)

因此，指定术语的行为与以前相同，但对于非指定术语无法真正断言任何事情。

回想一下，我们引入了一个由 D(f,x)缩写的公式（15）来表示 f 指定 x。使用这个，我们引入了一个进一步的缩写。

D(f)缩写为∃xD(f,x)(18)

这意味着 f 指定。顺便说一句，我们也可以使用λxx=x，从而避免量化。

区分存在和指定是很重要的。在这里，存在是对象的一个属性，但指定实际上适用于形式语言中的术语，在一个上下文中。以 Fitting 和 Mendelsohn 1998 年的一个时间例子为例，通常意义上，“乔治·华盛顿”指定了一个不存在的人，尽管他曾经存在过，而“乔治·华盛顿的长子”根本不指定。一个内涵变量 f 指定一个存在的对象，可以用一个抽象λxE(x)来表示。不过，我们对不存在要小心一点。f 指定一个不存在的事物并不仅仅是对前一个表达式的否定，¬λxE(x)。毕竟，λxE(x)表示 f 指定一个存在的事物，所以它的否定表示 f 要么不指定，要么指定一个不存在的事物。要表达 f 指定，但指定一个不存在的事物，我们需要λx¬E(x)。公式∀f( λxE(x)∨¬λx E(x))是有效的，但∀f( λxE(x)∨ λx¬E(x))不是有效的——可以很容易地构造出使其无效的部分 FOIL 模型。我们确实有以下重要内容。

∀f[D(f)≡(](19)​[λxEλx¬E(x)](f)

换言之，内涵术语必须指定存在或不存在的实体。

#### 3.5.2 确定描述

在本文的前几部分中，已经举了一些内涵和部分内涵的例子，如“法国现任国王”，“最高的人”和“最年长的人”。还可以添加“人数”和“x2−9=0 的正解”。所有这些都是使用明确描述来指定的。在时间模型中，前三个确定了部分内涵（有一段时间没有人）；第四个确定了一个非部分内涵的内涵；第五个确定了一个刚性内涵。

到目前为止，我们一直在非正式地讨论，但是有两种等效的方式可以正式地发展明确描述的思想。伯特兰·罗素（Russell 1905，Whitehead and Russell 1925）引入的方法是广为人知的，可能在这里不需要过多解释。可以说，它可以轻松地扩展到内涵的设置中。在这种方法中，引入了一个类似术语的表达式，ιyϕ(y)，其中ϕ(y)是一个公式，y 是一个对象变量。它的阅读方式是“y 使得ϕ(y)”。这个表达式没有独立的含义，但是在适当的上下文中有一种将其转换的方法。因此，[λxψ(x)]ιyϕ(y))被认为是缩写为∃y[∀z(ϕ(z)≡z=y)∧ψ(y)]的公式。（标准的方法是使用ϕ(z)来表示将ϕ(y)的自由出现替换为 z 的替换实例，并根据需要修改绑定变量，以避免偶然捕获 z。）目前的抽象符号，使用λ，不是罗素的符号，但他使用了一个等效的作用域设备。正如他所指出的那样，罗素的方法使我们能够区分“法国现任国王不是秃头的”，这是错误的，因为现在没有法国国王，“现任法国国王是秃头的不是真的”，这是正确的，因为“现任法国国王是秃头的”是错误的。它成为λx¬Bald(x)和¬ λxBald(x)之间的区别。

作为一种有吸引力的替代方案，可以将明确的描述转化为一流的事物。扩大语言，使得如果ϕ(y)是一个公式，其中 y 是一个对象变量，那么ιyϕ(y)是一个内涵术语，其自由变量是ϕ(y)的变量，除了 y。然后修改公式的定义，允许这些新的内涵术语出现在我们先前允许内涵变量出现的位置。这导致了一个复杂性，因为内涵术语涉及到公式，而公式可以包含内涵术语。实际上，公式和术语必须同时定义，但这并不是一个真正的问题。

从语义上讲，我们可以通过部分内涵来模拟明确的描述。我们说在具有评估 v 的部分 FOIL 模型 M 的状态Γ下，术语ιyϕ(y)指定了一个 y-变体 w，使得 M,Γ⊨wϕ(y)恰好成立。然后，根据第 3.5.1 节的条件进行扩展。

3. 如果在Γ下，ιyϕ(y)不指定与 v 相关的内容，
    不是这样的情况，即 M,Γ⊨v λxX
4. 如果ιyϕ(y)在Γ中相对于 v 指定，
    M,Γ⊨v[λxX](%CE%B9y%CF%95(y))⇔M,Γ⊨wX
    其中 w 是 v 的 y-变体，使得 M,Γ⊨wϕ(y)

可以证明，罗素方法和刚才概述的方法基本上是一样的。但是，如果将确定描述作为语言的形式部分而不仅仅是可移除的缩写词语，我们可以看到它们确定了由公式指定的内涵（可能是部分的）。

一个属性不一定适用于相应的确定描述，即λxϕ(x)不一定有效。这仅仅是因为确定描述可能没有指定。然而，如果它确实指定了，它必须具有其定义的属性。实际上，我们有以下的有效性：

D(ιxϕ(x))≡[λxϕ(x)](%CE%B9x%CF%95(x))

在确定描述和情态运算符之间以及它们与否定之间的相互作用上，人们必须小心。例如，D(ιx◊ϕ(x))⊃◊D(ιxϕ(x))是有效的，但其逆命题则不成立。对于情态/描述相互作用的更具体的例子，假设 K(x)是一个表达 x 是法国国王的公式。在当前状态下，λx◊E(x)是假的，因为确定描述没有指定，但◊ λxE(x)是真的，因为存在一个替代（较早的）状态，在该状态下确定描述指定了一个存在的对象。

### 3.6 刚性的问题

注意到对于刚性术语，de re/de dicto 的区别消失了。实际上，如果 f 和 g 是刚性的，λxy x=y，□ λxy x=y 和λxy □x=y 都是等价的。这是一个问题，限制了目前所呈现的 Carnap 风格逻辑所能处理的范围。两个众所周知的困难领域是数学和专有名词，特别是在认识论的背景下。

#### 3.6.1 数学问题

怎么会有人不知道 1+4=2+3？然而，这种情况在小孩子身上发生过，对于我们这些大一点的孩子来说，我们也会遇到类似但更复杂的数学真理我们不知道的例子。显然，“1+4”和“2+3”的指称是相同的，所以它们的意义必须不同。但是，如果我们将意义建模为从状态到指称的函数，这些函数将是相同的，将每个状态映射到 5。如果问题涉及必要真理，那就没有问题；我们当然希望“1+4=2+3”是一个必要真理。但是，如果考虑认识论问题，由于我们不能有一个可能的世界，在这个世界中，“1+4”和“2+3”指称不同的事物，“1+4=2+3”必须是一个已知的真理。那么，再次问一下，怎么会有人不知道这个，或者任何其他数学真理呢？

一种可能的解决方案是说，对于数学术语来说，内涵与“法国国王”之类的明确描述的内涵是不同的。表达式“1+4”是一种微型计算程序。确切的程序取决于我们如何学习加法，但让我们统一标准为：x+y 指示我们从数字 x 开始，数出接下来的 y 个数字。显然，“1+4”和“2+3”对应于具有相同输出的不同程序。我们可以将程序与意义进行对应，将输出与指称进行对应。然后，我们可以解释为什么不知道“1+4=2+3”，我们说我们没有执行这两个程序，因此无法得出关于输出的任何结论。

将数学术语的内涵与其计算内容进行对应是一个合理的做法。然而，这与本文前面的内容相冲突。像“法国国王”之类的表达方式被处理一种方式，像“1+4”之类的表达方式被处理另一种方式。对于任何给定的表达式，我们如何决定如何处理它？有可能统一所有这些。这里有一种相对简单的方法。如果我们将“1+4”的意义视为一个小程序，那么肯定存在一些状态，即可能的世界，在这些状态中我们尚未执行该程序，还有一些状态我们已经执行了该程序。然后，我们可以将“1+4”的内涵视为对状态的部分函数，其定义域是已执行“1+4”中的指令的状态集，并将这些状态映射到 5。显然，我们可以在认识论可能世界模型的状态中存在我们不知道“1+4”和“2+3”具有相同输出的情况。

这只能推进到这个程度。我们可能会被一些一般的论证所说服，即加法是一个总是被定义的函数。然后我们可以想象，我们可能知道“1+4”指代某个数字，但不知道它是什么。但是，根据迄今为止概述的语义，假设算术术语的行为正确，这是无法捕捉到的。如果在某个状态下我们知道∃x( λy x=y)，也就是说，我们知道“1+4”指代的是什么，那么在所有兼容的状态下，“1+4”指代的都是相同的，由于算术术语的行为正确，在所有兼容的状态下，“1+4”必须指代 5，因此我们必须知道λy 5=y 在原始状态下成立。我们无法在不知道的情况下知道“1+4”指代的是什么。

也可以从完全不同的角度来解决这个问题。人们不会质疑数学真理的必要性——问题在于认识论。对于这个问题，人们早就注意到，Hintikka 风格的知识处理并不涉及实际的知识，而是涉及潜在的知识——不是我们所知道的，而是我们有权知道的。然后就会出现熟悉的逻辑全知问题，我们刚刚又看到了另一个例子。Fagin 和 Halpern 在 1988 年提出了一种解决方法，称为意识逻辑。其思想是用意识函数来丰富 Hintikka 的认识模型，将每个状态映射到我们在该状态下知道的公式集合。这个想法是意识函数反映了我们可以运用的资源的某种限制。通过这样的语义机制，我们可能知道简单的数学真理，但对于更复杂的真理，我们可能不知道，仅仅是因为它们对我们来说太复杂了。

意识，在这个技术意义上，是一个笨拙的工具。在 van Benthem 1991 中提出了一种改进方法：使用明确的知识术语。作为为直觉逻辑提供建设性语义的项目的一部分，Artemov 2001 提出了一种明确证明术语的形式逻辑。随后，Fitting 2006 创建了一个可能世界语义。在这种逻辑中，真理是基于明确的原因而知道的，而这些明确的原因提供了一种复杂性的度量。随后，这项工作被扩展到了一个更一般的合理逻辑家族，这些逻辑是知识逻辑，其中原因被明确说明。

在合理逻辑中，我们不再使用熟悉的认知逻辑的 KX，而是使用 t:X，其中 t 是一个明确的证明术语。公式 t:X 的含义是“X 是基于原因 t 而知道的”。根据所研究的特定合理逻辑的不同，证明术语的结构会有所变化。所有合理逻辑共同具有以下最小机制。首先是证明常量，用于表示已接受的逻辑真理的未分析的证明。其次是证明变量，代表任意的证明。最后是二元操作，至少包括⋅和+。意图是，如果 s 证明 X⊃Y，t 证明 X，那么 s⋅t 证明 Y，而且 s+t 证明 s 证明的任何事物，以及 t 证明的任何事物。合理逻辑与认知逻辑之间存在非常紧密的联系，体现在实现定理中。这不是详细讨论的适当场所；关于合理逻辑的全面讨论可以在本百科全书的合理逻辑条目中找到。

如果一个人遵循证明逻辑学的方法，他可能会说，对于 1+4=2+3 或者更复杂的数学真理，我们可以知道它，但是对于我们来说实际上很难知道。也就是说，体现我们对这个知识的理由的证明术语对我们来说太复杂了。这符合意识逻辑学的一般思想，但是具有特定且在数学上有用的我们意识复杂性的度量。

#### 3.6.2 适当名称

适当名称比数学表达式更加棘手。如今，适当名称通常被理解为刚性指示符，但与数学术语不同的是，它们没有我们可以利用的结构。这里有一个非常标准的例子。假设“Hesperus”被用作晚星的名称，“Phosphorus”被用作晨星的名称。应该理解“晚星”是对一个明确描述“日落后第一个可见的天体”的简写，同样，“晨星”也是如此。明确描述具有结构，它们指代对象，在不同的可能世界中，它们可能指代不同的对象。但是适当名称不是这样的。一旦“Hesperus”和“Phosphorus”的指定被确定下来——碰巧它们都指代金星——那个指定就在可能世界中被确定下来，因此它们是刚性指示符。由此可见，虽然晨星是晚星，但这个等同性并不是必然的，因为明确描述不是刚性的，但是 Hesperus 是 Phosphorus 这个等同性是必然的。那么，Hesperus 和 Phosphorus 的等同性怎么可能是一个已知的真理，而不需要进行任何天文研究呢？

刚刚提到的困境有不止一种解决方案。其中一种方法非常简单。可能世界模型可以用来表示各种类型的模态。它们提供了数学工具，但并不说明这些工具的用途。这取决于使用者。因此，我们可能希望有这样一个模型来表示必然真理，或者我们可能希望有这样一个模型来表示认识问题。适用于适当名称是刚性指示符的论证适用于表示必然真理的模型。但这并不意味着这也适用于认识模型。以下是（Kripke 1980）的一句引文，对这个问题有所启发。

> 但是，如果我们处于完全相同的证据情况下，从定性上讲，可能会发现 Hesperus 不是 Phosphorus；也就是说，在一个反事实的世界中，我们不使用“Hesperus”和“Phosphorus”作为我们现在使用的方式，即作为这颗行星的名称，而是作为其他一些物体的名称，我们可能会有定性上相同的证据，并得出“Hesperus”和“Phosphorus”命名了两个不同的物体的结论。但是，我们现在使用这些名称，可以预先说，如果 Hesperus 和 Phosphorus 是同一个物体，那么在任何其他可能的世界中，它们都不能不同。我们将“Hesperus”用作某个物体的名称，“Phosphorus”用作某个物体的名称。我们在所有可能的世界中都将它们用作这些物体的名称。如果事实上它们是同一个物体，那么在任何其他可能的世界中，我们都必须将它们用作该物体的名称。因此，在任何其他可能的世界中，Hesperus 是 Phosphorus 是真实的。因此，有两个事实是真实的：首先，我们不知道 Hesperus 是 Phosphorus 的先验知识，并且除了通过经验来找到答案之外，我们没有其他方法。其次，这是因为我们可能有与我们现有证据在定性上无法区分的证据，并通过天空中两颗行星的位置来确定这两个名称的指称，而这两颗行星并不相同。

简而言之，在模型中，适当的名称是刚性指示符，其中可能的世界代表逻辑上的替代状态。在可能的世界代表认识上的替代状态的模型中，它们不一定是刚性指示符。Hesperus 和 Phosphorus 是相同的，必然如此，但是我们可以以不同的方式使用“Hesperus”和“Phosphorus”，而无法知道我们正在这样做-这种状态可能在认识上无法区分与实际状态相同。可能存在我们不知道的必然性身份，因为必然真理和已知真理不遵循相同的规则。

#### 3.6.3 非卡纳皮安方法

上述讨论背后的形式机制可以追溯到卡纳普的思想。在这个传统中，可能世界是核心，而意义或内涵是从可能世界到指称的函数。意义决定指称，但关于这是如何发生的详细机制并没有具体说明（除了明确的描述）。不必以这种方式做事。如果遵循教堂的方法，可以简单地说“Hesperus”和“Phosphorus”在刚性上具有相同的指定，因此必然，但即使如此，它们的意义也不相同。这是可能的，因为意义实际上是独立的，不是派生的东西。意义可以在可能世界中确定相同的外延而不相同。

在 Zalta 1988 中可以找到一种打破卡纳皮安模式的逻辑，它是彻底和完全发展的。在这个逻辑中，假设了一类抽象对象，其中一些是普通的。区分了一个物体展示一个属性和编码它。例如，一个抽象对象可能很好地编码“圆方”的属性，但不能展示它。假设了一个普遍的理解原则，即条件决定了编码（而不是展示）条件的抽象个体。如果两个对象都是抽象的并且编码相同的属性，或者它们都是普通的并且展示相同的属性，则认为它们之间存在身份。实际上，这解决了可替代性的问题。这个形式理论（更准确地说，是理论）非常通用，包括逻辑必然性和时间操作符。假设编码不是偶然的，尽管展示可能是，因此属性既有可以在世界之间变化的展示外延，也有刚性的编码外延。有了所有这些可用的机制，可以详细处理专有名词，以及其他许多内容。

## 4. 算法作为意义

在弗雷格之后，数学表达式“1+4”和“2+3”具有相同的指称但不同的内涵。弗雷格并没有明确说明什么是内涵，尽管很明显，内涵以某种方式决定了指称。我们之前谈到了与“1+4”和“2+3”相关的计算，但我们所呈现的是相当简单的。蒂希引入了一种构造的想法，这两个表达式规定了不同的构造。这个想法的一个更加正式的版本出现在一系列论文中，（Moschovakis 1994; Moschovakis 2006; Kalyvianaki and Moschovakis 2008），所有这些论文都可以追溯到（Moschovakis 1989）。在这些论文中，有一个非常复杂的形式化体系，其中一个表达式的内涵或意义是一个算法，算法的执行决定了指称。接下来，我们将概述这些想法，省略了大部分技术细节。

为了保持事物相对简单，我们将讨论限制在一个形式语言的句子上，其中，再次遵循弗雷格的观点，指称仅仅是一个真值。无限多个素数存在和无限多个偶数存在这两个句子在指称上是一致的——都是真的——但显然具有不同的内涵。莫斯科瓦基斯的所有基本思想已经在句子层面上存在，尽管这些思想广泛延伸。我们引用了（Moschovakis 1994）的内容，我们的演示就是基于这篇论文。

> 本文的数学结果涉及形式语言，但它们也适用于那些可以形式化的自然语言片段，就像形式语言的指称语义结果经常应用于自然语言的片段一样。除了谓词逻辑语言的语义相对简单之外，该理论还涵盖了具有描述运算符、任意联结词和模态运算符、广义量词、间接引用和定义自己的真值谓词的语言。

如果将意义与算法等同起来，那么最基本的问题是：什么是算法。对于 Moschovakis 和许多从事数学工作的数学家来说，算法是一个抽象的数学对象，就像一个数一样。当然，人们使用特殊的符号来处理数字或算法，但符号是句法的，而数学对象是语义的（甚至是理想的）。算法的主题可能会有所不同：用于烘焙蛋糕的算法与用于解二次方程的算法不在同一空间中运作。需要一些形式主义来指定算法，并且这个机制应该适用于所有主题，同时尽可能简单。在各种主题范围内，有几种一般但等效的算法规范方法。Moschovakis（1994）引入了一种非常简单、直接的机制，他称之为具有反射的下位谓词演算，其中反射实质上意味着自我引用。当然，并非所有的算法都会终止，因此底层的真值空间需要一些考虑，但是 Kripke 在他的真理理论中提出的解决方案效果很好。我们通过一些（暂时的）非正式示例引导到一个一般的定义。

### 4.1 激励性例子

假设我们有一个具有给定域和一些给定的各种关系的结构，记作⟨D，R1，...，Rn⟩。假设我们以通常的方式形成了一个一阶语言，其中包含关系符号 R1，...，Rn，其元数与给定关系的元数相匹配。我们通常使用排版约定，即 R 是一个关系，R 是由该关系解释的相关形式符号。我们可以按照通常的方式构建一个关于该结构的一阶语言，其中原子公式涉及 R1，...，Rn 和=。常量可以通过使用对单个事物为真的一元关系来模拟。例如，在算术中，我们可以有一个关系 Z，只有当 x=0 时，Z(x)成立。为了易读起见，在这种情况下，我们会假设我们的语言中有一个由 0 解释的常量符号。这样的非正式简化使得公式的阅读更容易，而没有丢失任何重要内容。

在通常的一阶机制中添加的是一个“where”构造。我们将很快给出一个适当的定义，但首先，这里是一个具体的例子。假设我们有一个算术结构，⟨{0,1,2,...}，S，Z⟩。这里，S 是域上的二元后继关系，即我们有 S(0,1)，S(1,2)，...。我们还假设 Z 只对 0 成立，并且根据我们上面关于关系和个体常量的说法，我们假设在形式语言中有一个由 0 解释的常量符号。考虑以下公式，其中 S 是由 S 解释的二元关系符号，E 和 O 是辅助的一元关系符号。

even(x)≡E(x) where {E(x)≃x=0∨(∃y)(S(y,x)∧O(y)),O(x)≃(∃y)(S(y,x)∧E(y))}(20)

暂时将≃理解为“被定义为”的意思。这将在后面进一步讨论。将 E(x)理解为表示“输出”关系。它是以 O 为基础定义的，而 O 又是以 E 为基础定义的。这涉及到相互递归。即使在这个非正式的阶段，我们也不难看出，even 定义了偶数的集合，即对于偶数 x，even(x)的值为 true，对于奇数 x，even(x)的值为 false。下面是一个非正式的计算，展示了 even(2)的值为 true。在计算中，我们使用⇐表示逆向蕴含。此外，我们直接将域中的成员（数字）写入公式中，而不使用将数字赋值给自由变量的估值机制。

even(2)≡E(2)≃2=0∨(∃y)(S(y,2)∧O(y))⇐2=0∨(S(1,2)∧O(1))≃2=0∨(S(1,2)∧(∃y)(S(y,1)∧E(y)))⇐2=0∨(S(1,2)∧(S(0,1)∧E(0)))≃2=0∨(S(1,2)∧(S(0,1)∧(0=0∨(∃y)(S(y,0)∧E(y)))))

我们使用了这个子句三次，分别替换了 E(2)，O(1)和 E(0)。最后一行是真的，因为 S(1,2)，S(0,1)和 0=0 都是真的。

这个例子是一个开始，但它过于简单，会产生误导。这个机制足够丰富，可以允许构造谬误句。在接下来的讨论中，P 是一个辅助的关系符号，其元数为 0，即一个命题符号。我们只写 P 而不写 P()。

 liar≡P，其中{P≃¬P}(21)

显然，上述所示的评估尝试将不会终止。解决非终止的方法在经典递归论和真理理论的研究中是熟悉的：允许我们形式机制定义的关系是部分的。并不是所有关系的实例都必须接收一个真值。但这些是语义问题，在讨论它们之前，我们需要对我们的公式将被写入的语言给出一个适当的句法定义。

### 4.2 语法

在前面，我们谈到了适用于结构⟨D，R1，…，Rn⟩的一阶语言，通过示例展示了这些子句。这里是一个适当的定义。具有反射的下位谓词演算（LPCR）对于⟨D，R1，…，Rn⟩是使用普通一阶逻辑与相等性的机制构建的语言，加上以下形成子句。如果ϕ0，ϕ1，…，ϕk 是公式，P1，…，Pk 是（新的）辅助关系变量，则以下是一个公式。

ϕ0，其中{P1(x1)≃ϕ1，…，Pk(xk)≃ϕk}(22)

在这里，每个 xi 都是一个变量序列，其长度是 Pi 的 arity。Pi 可能出现在ϕ0，…，ϕk 的公式中，因此我们有一组自我引用的定义方程，其中ϕ0 作为“输出”。请注意，在将(22)添加到公式的定义中时，条件可以出现在一些ϕi 中，因此需要防止嵌套条件之间的不适当交互的方法。这是通过自由变量和约束变量的熟悉机制来实现的。符号 P1，…，Pk 被视为关系变量，并且在(22)中被认为是约束的。同样，xi 中的个别变量的出现被理解为在 Pi(xi)≃ϕi 中被约束。实际上，这些是局部变量。

现在 LPCR 语言已经被定义，我们转向意义和指称的概念。

### 4.3 指示

我们一直在讨论带有自由变量的句子和更一般的公式。熟悉的塔斯基语义为我们提供了一个理解的基础，但我们需要修改和扩展来处理这个结构。

空间 S 上的部分函数是一种将值分配给 S 的一些成员（但不一定是全部成员）的函数。换句话说，它是一个定义域是 S 的子集的函数。对于部分函数 f，f(x)≃y 表示 x 在 f 的定义域中且 f(x)=y。（最后我们对之前的例子中使用的≃有了一个正确的解释。）部分关系是从 k 元组到{t,f}的部分函数。我们给定的结构中的关系是通常意义上的关系，但我们可能会发现自己定义的是部分关系。

假设我们有一个结构⟨D,R1,…,Rn⟩，并且假设我们有一个与之相关联的 LPCR 语言。在这个结构中，一个估值 v 是一个从个体变量到 D 的成员的映射，以及从辅助关系符号到 D 上的部分关系的映射。我们想要将每个估值 v 与一个从 LPCR 公式到真值的映射 Tv 相关联，但由于像说谎者句子这样的东西是可公式化的，Tv 必须是一个部分函数，因此我们甚至对于熟悉的命题联结词也必须小心。已经开发了各种三值逻辑；可能最常见的是 Kleene 的强三值逻辑，它受到递归理论的启发，并且在真理理论的许多工作中很常见。下表说明了联结词和量词的行为。未明确涵盖的情况被理解为真值估值未定义的情况。（例如，如果 X 的真值未定义，那么¬X 的真值也是未定义的。）

Tv(¬X)≃tTv(¬X)≃fTv(X∧Y)≃tTv(X∧Y)≃fTv(X∨Y)≃tTv(X∨Y)≃fTv((∀x)X)≃tTv((∀x)X)≃fTv((∃x)X)≃tTv((∃x)X)≃fTv(X)≃fTv(X)≃tTv(X)≃t and Tv(Y)≃tTv(X)≃f or Tv(Y)≃fTv(X)≃t or Tv(Y)≃tTv(X)≃f and Tv(Y)≃fTv′(X)≃t for all x-variants v′ of vTv′(X)≃f for some x-variant v′ of vTv′(X)≃t for some x-variant v′ of vTv′(X)≃f for all x-variants v′ of v

这仍然需要处理公式。假设我们有以下内容。

ϕ0 其中 {P1(x1)≃ϕ1,…,Pk(xk)≃ϕk}(23)

为了避免讨论过于复杂，我们做出了两个简化假设。我们假设没有ϕi 包含嵌套的 where 子句。这个条件下的基本思想已经得到了充分的说明，但是在不太困难的情况下，一切都可以推广到一般情况。对于 xi 中的变量来说，它们在 Pi(xi)≃ϕi 中是“局部”的，也就是说，它们被认为是在这个公式中被绑定的。除此之外，我们还添加了另一个简化假设：xi 中的变量是ϕi 中唯一可能出现自由的变量。大致意思是我们没有参数，只有局部变量。这样可以使我们在讨论问题时更加简洁。同样，一切都可以推广到更一般的情况，而没有根本性的改变。

继续考虑(23)，考虑以下相关方程的集合 E。

P1(x1)P2(x2)Pk(xk)≃ϕ1≃ϕ2⋮≃ϕk(24)

当然，困难在于每个 Pi 都可以出现在一个或多个ϕj 中，甚至可能出现在ϕi 中，因此 E 是自指的。在许多计算机编程语言中，我们会看到类似 x=x+1 的东西。对初学者解释说，这将获取 x 的当前值，加 1，并将结果再次赋给 x。右侧的 x 出现在“之前”，左侧的 x 出现在“之后”。类似地，让我们将 E 的成员视为（同时的）赋值语句。≃右侧的 Pi 出现是当前值，左侧的出现是下一个值。考虑到所有的 P1，…，Pk，我们可以将 E 视为定义了一个将 k 个部分关系（这些关系符号的“之前”值）映射到 k 个部分关系（这些关系符号的“之后”值）的函数。现在，以下是更正式的细节。

假设我们有一个 k 元组⟨P1，…，Pk⟩的部分关系，其中对于每个 i，Pi 的 arity 与部分关系变量 Pi 的 arity 相匹配。这是我们的输入（“之前”值）。对于每个 i，我们想要定义一个输出部分关系，我们称之为 P′i，其 arity 与 Pi 相同，以便⟨P′1，…，P′k⟩作为我们的整体输出（“之后”值）。为了做到这一点，我们必须说明当 P′i（d）映射到 t 时，当它映射到 f 时，以及当它未定义时，对于每个具有来自 D 的分量 d。好吧，让 v 成为一个估值，为每个辅助关系符号 Pi 分配相应的部分关系 Pi（这是我们的部分关系符号的“之前”值的方式），并为 xi 中的变量分配相应的 d 的成员。现在，简单地让 P′i（d）≃Tv（ϕi）。通过这种方式，指定了一个新的部分关系 P′i，更一般地说，一个向量⟨P′1，…，P′k⟩。方程组 E 可以被看作是将 k 元组⟨P1，…，Pk⟩转化为⟨P′1，…，P′k⟩的函数。让我们称这个函数为[E]，并写作 E=⟨P′1，…，P′k⟩。

如果我们希望在逻辑学的环境中使方程 E 表现良好，那么每个 Pi 的估值无论我们在哪里看到它都应该是相同的——我们所称之为左侧和右侧的区别应该不存在；Pi 和 P'i 应该是相同的。换句话说，我们希望有部分关系 P1，…，Pk 来解释 P1，…，Pk，使得 E=⟨P1,…,Pk⟩——“之前”和“之后”的值是一致的。这被称为[E]的一个不动点。因此，我们需要知道[E]是否有一个不动点，如果有多个不动点，则存在一个合理的候选者可以选择为最佳的一个。

如果 f 和 g 是从空间 S 到 R 的两个部分函数，那么写作 f⊆g 意味着每当 f(x)≃w 时，也有 g(x)≃w。对于相同元数的两个部分关系 P 和 Q，P⊆Q 意味着只要 P(d)被定义，Q(d)也被定义，并且两者具有相同的真值。我们可以通过设置⟨P1,…,Pk⟩⊆⟨Q1,…,Qk⟩来将此扩展到 k 元组，如果对于每个 i，Pi⊆Qi。可以很容易地证明上述定义的函数[E]具有单调性质：如果⟨P1,…,Pk⟩⊆⟨Q1,…,Qk⟩，则 E⊆E。有一个非常普遍的关于这样的单调映射的理论，由此可知[E]确实有一个不动点。此外，如果存在多个不动点，则存在一个最小的不动点，即它在⊆关系中是与任何其他不动点相关的。这个最小的不动点正是我们上面提到的最佳候选者，它包含了任何不动点必须具有的信息。

现在我们完成了如何评估公式(23)的说明。首先，构造相关的方程集 E。接下来，构造函数[E]。[E]有一个最小的不动点，假设它是⟨F1,…,Fk⟩。最后，使用 Fi 来解释每个 i 的 Pi 来评估ϕ0。得到的真值，或者未定义，就是与(23)相关联的值（指称）。

我们已经说明了如何将真值或未定义与 LPCR 的每个公式（在我们的简化假设下）相关联。我们有（部分）指示。

### 4.4 意义

LPCR 的每个公式都指定了其评估的算法，即确定其真值（如果可能）。Moschovakis 将公式的意义与该算法等同起来。因为相关联的算法不同，因此评估为相同结果、具有相同指示的两个公式可能具有不同的意义。例如，在（20）中，我们给出了一个定义偶数的公式。这是另一个类似的公式。

even(x)≡E(x) 其中 {E(x)≃x=0∨(∃y)(S(y,x)∧¬E(y))}(25)

我们留给您验证(25)也定义了偶数。直观上可以认为(20)和(25)使用不同的算法进行评估，因此具有不同的内涵。但当然这必须被明确化。需要的是一种统一的算法比较方法。在这里，我们只是简要地概述了这些想法。

有一个非常通用的机制，来自 Moschovakis 1989 年的形式递归语言（FLR）。使用它可以对递归定义和不动点进行彻底的探索。我们在讨论指称时忽略了一些东西，但在这里关注我们的 LPCR 嵌入到 FLR 中，甚至允许嵌套子句和参数。在 FLR 中，有一种将递归定义转换为无法进一步简化的正常形式的方法。该正常形式具有非常简单的结构，由一组自我引用的方程组成，没有任何嵌套。正常形式最清楚地显示了基本的评估结构。当使用单个结构 ⟨D,R1,…,Rn⟩ 时，所有的正常形式都将由一组共同的函数构建。这使得比较正常形式变得容易。思路是，如果两个 LPCR 公式在嵌入到 FLR 中时具有不同的正常形式，那么这两个公式具有不同的内涵。当然，这必须以一定的合理灵活性来理解。例如，只有通过重命名变量或交换方程的顺序而仅有的不同的两组方程在根本上并没有不同。在这种理解下，如果两个 LPCR 公式在嵌入到 FLR 中时真正具有不同的正常形式，那么这两个 LPCR 公式被定义为具有不同的内涵。这满足了人们对内涵概念的所有非正式条件。Moschovakis 甚至证明了一个重要的定理，即在自然条件下，根据刚刚定义的内涵相等性是可判定的。

### 4.5 算法不一定需要有效

“算法”一词暗示着某种有效性，但在这里它被用于更一般的意义上，作为一组指令，由于我们有限的限制，我们可能无法实际执行。再次考虑范式公式（22）。如果ϕi 中包含一个存在量词在正位置（或一个全称量词在负位置），它可以被视为对域 D 进行系统搜索以找到一个验证证人。这对于合理的域是合理的。但是，如果ϕi 中包含一个全称量词在正位置或一个存在量词在负位置，就必须对域中的每个成员进行验证，除非域是有限的，否则这不是一个人类的任务。尽管如此，我们通常相信我们理解量化。我们所处理的是相对于这种理解的算法。

量词的问题对于我们通常使用感觉和指称进行讨论的许多问题是不可避免的。考虑罗素对确定描述的处理。在这种情况下，“A 具有属性 B”被替换为“只有一个东西具有属性 A，并且它具有属性 B”。说只有一个东西具有属性 A 意味着某物具有属性 A，而其他一切都没有。这个问题的第一部分涉及存在量词，第二部分涉及全称量词。然后，如果确定描述出现在正位置，我们有一个全称量词的正出现，如果它出现在负位置，我们有一个存在量词的负出现。无论哪种方式都会出现基本问题。莫斯科瓦基斯并不打算将感觉和指称转化为可计算的东西，而只是提供可以合理形式化所涉及的思想的数学机制，使用广义的算法概念。

在缺乏效力的问题中存在着一个相关的第二个问题。在我们对指称的讨论中，我们考虑了一组方程（24）和与之相关的函数[E]。回想一下，[E]将 k 元组的部分关系映射到 k 元组的部分关系。我们注意到[E]将是单调的，并且根据非常一般的结果，这样的函数总是具有最小不动点。有多种方法可以证明这一点。一个众所周知的论证具有明显的算法风格。它的步骤如下。从最小的 k 元组的部分关系开始-这是每个部分关系始终未定义的情况。将其称为 T0。将函数[E]应用于 T0，得到 T1。将函数[E]应用于 T1，得到 T2，依此类推。很容易证明 T0⊆T1⊆T2⊆…。我们有 T0⊆T1，因为 T0 与每个 k 元组的⊆关系相关。根据单调性，我们有 E⊆E，但这意味着 T1⊆T2。依此类推。继续这个递增序列，最终将达到[E]的最小不动点。

但这是非常误导人的。"继续"是什么意思？我们有 T0，T1，T2，...。这些中没有一个可能是一个不动点。例如，假设我们使用从（20）中得到的用于 even(x)的函数进行这个构造。那么 T0 将是⟨E0，O0⟩，其中 E0 和 O0 都是始终未定义的一元关系。我们留给您检查我们得到的连续的 Ti=⟨Ei，Oi⟩，其中我们有以下情况，未显示的情况是未定义的。

i123⋮EiE1(0)=tE2(0)=tE2(1)=fE3(0)=tE3(1)=fE3(2)=t⋮OiO1(0)=fO2(0)=fO2(1)=tO3(0)=fO3(1)=tO3(2)=f⋮

T0、T1、T2 等都不是一个固定点，但是有一个明确的极限概念，称为 Tω，它累积了沿途产生的结果。在这个例子中，它是最小的固定点。

但是迭代和取极限可能是不够的。考虑以下对(20)的详细阐述。

ϕ(x)≡A(x)，其中{E(x)≃x=0∨(∃y)(S(y,x)∧O(y))，O(x)≃(∃y)(S(y,x)∧E(x))，A(x)≃x=1∧((∀y)(E(y)∨O(y))}(26)

从（26）中得出的方程组有（20）的两个成员，以及一个 A 的额外成员。使用这些方程，为了得出 A（1），我们必须已经有 E（y）或 O（y）对于每个数字 y 的求值为 t。如果我们按照上面概述的构造进行，直到阶段ω之前，E 和 O 都不会满足这一点，因此我们必须再走一步，到达所谓的 Tω+1，才能达到一个不动点。

可以给出越来越极端的例子。不动点构造可能需要继续到更大的超限序数。这是一个众所周知的现象，特别是在真理理论等领域。这是无法避免的。顺便提一下，应该注意的是，Kripke 在他对真理的处理中引入的机制自然地嵌入到 LPCR 中，但我们在这里不讨论这个问题。

<!--md-padding-ignore-begin-->
## Bibliography

* Anderson, C. A. (1984). “General intensional logic,” in D. Gabbay and F. Guenthner (Eds.), *Handbook of Philosophical Logic*, Volume II, Chapter II.7, pp. 355–385, Dordrecht: D. Reidel.
* Anderson, C. A. (1998). “Alonzo Church’s contributions to philosophy and intensional logic,” *The Bulletin of Symbolic Logic*, 4: 129–171.
* Beaney, M. (1997). *The Frege Reader*, Oxford: Blackwell.
* Bressan, A. (1972). *A General Interpreted Modal Calculus*, New Haven: Yale University Press.
* Carnap, R. (1947). *Meaning and Necessity*, Chicago: University of Chicago Press. Enlarged edition 1956.
* Church, A. (1940). “A formulation of the simple theory of types,” *The Journal of Symbolic Logic*, 5: 56–58.
* Church, A. (1944). *Introduction to Mathematical Logic, Part I*, Princeton University Press. Revised and enlarged, 1956.
* Church, A. (1946). “A formulation of the logic of sense and denotation (abstract),” *The Journal of Symbolic Logic*, XI: 31.
* Church, A. (1951). “A formulation of the logic of sense and denotation,” in P. Henle (Ed.), *Structure, Method and Meaning*, New York: The Liberal Arts Press. pp 3–24.
* Church, A. (1973). “Outline of a revised formulation of the logic of sense and denotation (part I),” *Noûs*, 7: 24–33.
* Church, A. (1974). “Outline of a revised formulation of the logic of sense and denotation (part II),” *Noûs*, 8: 135–156.
* Fagin, R. F. and J. Y. Halpern (1988). “Belief, awareness, and limited reasoning,” *Artificial Intelligence*, 34: 39–76.
* Fitting, M. C. (2004). “First-order intensional logic,” *Annals of Pure and Applied Logic*, 127: 171–193.
* Fitting, M. C. (2005). “The logic of proofs, semantically,” *Annals of Pure and Applied Logic*, 132 (1): 1–25.
* Fitting, M. C. (2006), “FOIL axiomatized,” *Studia Logica*, 84: 1–22.
* Fitting, M. C. and R. Mendelsohn (1998). *First-Order Modal Logic*, Dordrecht: Kluwer.
* Frege, G. (1892). Über Sinn und Bedutung. *Zeitschrift für Philosophie und philosophische Kritik*, 100: 25–50. English translation as ‘On Sinn and Bedeutung,’ in (Beaney 1997).
* Gallin, D. (1975). *Intensional and Higher-Order Modal Logic*, Amsterdam: North-Holland.
* Hughes, G. E. and M. J. Cresswell (1996). *A New Introduction to Modal Logic*, London: Routledge.
* Kalyvianaki, E. and Y. N. Moschovakis (2008). Two aspects of situated meaning. In F. Hamm and S. Kepser (Eds.), *Logics for Linguistic Structures*, pp. 57–86. Mouton de Gruyter.
* Kripke, S. (1963). “Semantical considerations on modal logics,” in *Acta Philosophica Fennica*, 16: 83–94.
* Kripke, S. (1980). *Naming and Necessity* (Second edition), Cambridge, MA: Harvard University Press.
* Marcus, R. (1946). “A Functional Calculus of First Order Based on Strict Implication,” *The Journal of Symbolic Logic*, 11: 1–16.
* Marcus, R. (1947). “The Identity of Individuals in a Strict Functional Calculus of Second Order,” *The Journal of Symbolic Logic*, 12: 12–15.
* Marcus, R. (1953). “Strict Implication, Deducibility and the Deduction Theorem,” *The Journal of Symbolic Logic*, 18: 234–236.
* Marcus, R. (1961) “Modalities and intensional Languages,” *Synthese*, XIII: 303–322. Reprinted in *Modalities, Philosophical Essays*, Ruth Barcan Marcus, Oxford University Press, 1993.
* Montague, R. (1960). “On the nature of certain philosophical entities,” *The Monist*, 53: 159–194. Reprinted in (Thomason 1974), 148–187.
* Montague, R. (1970). “Pragmatics and intensional logic,” *Synthèse*, 22: 68–94. Reprinted in (Thomason 1974), 119–147.
* Moschovakis, Y. N. (1989). The formal language of recursion. *54*, 1216–1252.
* Moschovakis, Y. N. (1994). Sense and denotation as algorithm and value. In J. Oikkonen and J. Vaananen (Eds.), *Lecture Notes in Logic*, Volume 2, pp. 210–249. Springer. [Full version of proof of Theorem 4.1 from that paper is [available online](http://www.math.ucla.edu/~ynm/papers/thproof.pdf).]
* Moschovakis, Y. (2006). “A logical calculus of meaning and synonymy,” *Linguistics and Philosophy*, 29: 27–89.
* Quine, W. V. (1963). “Reference and modality,” in *From a Logical Point of View* (second ed.), Chapter VIII, pp. 139–159. New York: Harper Torchbooks.
* Russell, B. (1905). “On denoting,” *Mind*, 14: 479–493. Reprinted in Robert C. Marsh, ed., *Logic and Knowledge: Essays 1901-1950, by Bertrand Russell*, London: Allen & Unwin, 1956.
* Stalnaker, R. and R. Thomason (1968). “Abstraction in first-order modal logic,” *Theoria*, 34: 203–207.
* Thomason, R. and R. Stalnaker (1968). “Modality and reference,” *Noûs*, 2: 359–372.
* Thomason, R. H. (Ed.) (1974). *Formal Philosophy, Selected Papers of Richard Montague*, New Haven and London: Yale University Press.
* Tichý, P. (1971). “An Approach to Intensional Analysis,” *Noûs*, 5: 273–297.
* Tichý, P. (1988). *The foundations of Frege’s logic*, Berlin and New York: De Gruyter.
* van Benthem, J. (1991). “Reflections on epistemic logic,” *Logique & Analyse*, 133/134: 5–14.
* Whitehead, A. N. and B. Russell (1925). *Principia Mathematica* (second ed.), Cambridge: Cambridge University Press (three volumes).
* Wittgenstein, L. (1921). *Tractatus Logico-Philosophicus*, London: Routledge and Kegan Paul.
* Zalta, E. (1988). *Intensional Logic and the Metaphysics of Intentionality*, Cambridge, MA: MIT Press.

### Additional Reading

* Aczel, P. (1989). “Algebraic semantics for intensional logics,” I. In G. Chierchia, B. Partee, and R. Turner (Eds.), *Properties, Types and Meaning. Volume I: Foundational Issues*, pp. 17–45, Dordrecht: Kluwer.
* Bealer, G. (1998). “Intensional entities,” in E. Craig (ed.), *Routledge Encyclopedia of Philosophy*, London: Routledge.
* Fitting, M. (2002). *Types, Tableaus, and Gödel’s God*, Dordrecht: Kluwer.
* Kripke, S. (2008). “Frege’s Theory of Sense and Reference: Some Exegetical Notes,” *Theoria*, 74: 181–218.
* Menzel, C. (1986). “A complete, type-free second order logic and its philosophical foundations,” Technical Report CSLI-86-40, Stanford: Center for the Study of Language and Information Publications.
* Searle, R. (1983). *An Essay in the Philosophy of Mind*, Cambridge: Cambridge University Press.
* Svoboda, V., Jespersen, B., Cheyne, C. (Eds.) (2004): *Pavel Tichý’s Collected Papers in Logic and Philosophy*, Prague: Filosofia, and Dunedin: Otago University Press, Dunedin.
* Thomason, R. (1980). “A model theory for propositional attitudes,” *Linguistics and Philosophy*, 4: 47–70.
* van Benthem, J. (1988). *A Manual of Intensional Logic*, Stanford: CSLI Publications.

## Academic Tools

> | ![sep man icon](../../.gitbook/assets/sepman-icon.png) | [How to cite this entry](https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=logic-intensional). |
> | --- | --- |
> | ![sep man icon](../../.gitbook/assets/sepman-icon.png) | [Preview the PDF version of this entry](https://leibniz.stanford.edu/friends/preview/logic-intensional/) at the [Friends of the SEP Society](https://leibniz.stanford.edu/friends/). |
> | ![inpho icon](../../.gitbook/assets/inpho.png) | [Look up topics and thinkers related to this entry](https://www.inphoproject.org/entity?sep=logic-intensional&redirect=True) at the Internet Philosophy Ontology Project (InPhO). |
> | ![phil papers icon](../../.gitbook/assets/pp.png) | [Enhanced bibliography for this entry](http://philpapers.org/sep/logic-intensional/) at [PhilPapers](http://philpapers.org/), with links to its database. |

## Other Internet Resources

* [Intensional Entities](http://pantheon.yale.edu/~gb275/Intensional%20Entities.pdf), preprint of G. Bealer, in E. Craig (Ed.), *Routledge Encyclopedia of Philosophy*, London: Routledge (1998).
* [An Introduction to Pavel Tichý and Transparent Intensional Logic](http://philsci-archive.pitt.edu/1479/), Andrew Holster, 2003.

## Related Entries

[logic: classical](https://plato.stanford.edu/entries/logic-classical/) | [logic: modal](https://plato.stanford.edu/entries/logic-modal/) | [logic: temporal](https://plato.stanford.edu/entries/logic-temporal/) | [type theory: Church’s type theory](https://plato.stanford.edu/entries/type-theory-church/)

[Copyright © 2015](https://plato.stanford.edu/info.html#c) by  
[Melvin Fitting](https://www.gc.cuny.edu/people/melvin-fitting)
